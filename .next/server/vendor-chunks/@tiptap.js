"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   Fragment: () => (/* binding */ Fragment6),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkView: () => (/* binding */ MarkView),\n/* harmony export */   Node: () => (/* binding */ Node3),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   canInsertNode: () => (/* binding */ canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ extensions_exports),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* binding */ flattenExtensions),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveExtensions: () => (/* binding */ resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   sortExtensions: () => (/* binding */ sortExtensions),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* binding */ updateMarkViewAttributes),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/helpers/createChainableState.ts\nfunction createChainableState(config) {\n  const { state, transaction } = config;\n  let { selection } = transaction;\n  let { doc } = transaction;\n  let { storedMarks } = transaction;\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  };\n}\n\n// src/CommandManager.ts\nvar CommandManager = class {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const { tr } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        const method = (...args) => {\n          const callback = command2(...args)(props);\n          if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n            view.dispatch(tr);\n          }\n          return callback;\n        };\n        return [name, method];\n      })\n    );\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run3 = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every((callback) => callback === true);\n    };\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command2]) => {\n          const chainedCommand = (...args) => {\n            const props = this.buildProps(tr, shouldDispatch);\n            const callback = command2(...args)(props);\n            callbacks.push(callback);\n            return chain;\n          };\n          return [name, chainedCommand];\n        })\n      ),\n      run: run3\n    };\n    return chain;\n  }\n  createCan(startTr) {\n    const { rawCommands, state } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command2]) => {\n        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];\n      })\n    );\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n  buildProps(tr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => void 0 : void 0,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command2]) => {\n            return [name, (...args) => command2(...args)(props)];\n          })\n        );\n      }\n    };\n    return props;\n  }\n};\n\n// src/Editor.ts\n\n\n\n// src/EventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  once(event, fn) {\n    const onceFn = (...args) => {\n      this.off(event, onceFn);\n      fn.apply(this, args);\n    };\n    return this.on(event, onceFn);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n};\n\n// src/ExtensionManager.ts\n\n\n// src/helpers/combineTransactionSteps.ts\n\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(oldDoc);\n  transactions.forEach((transaction) => {\n    transaction.steps.forEach((step) => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\n\n// src/helpers/createNodeFromContent.ts\n\n\n// src/utilities/elementFromString.ts\nvar removeWhitespaces = (node) => {\n  const children = node.childNodes;\n  for (let i = children.length - 1; i >= 0; i -= 1) {\n    const child = children[i];\n    if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n      node.removeChild(child);\n    } else if (child.nodeType === 1) {\n      removeWhitespaces(child);\n    }\n  }\n  return node;\n};\nfunction elementFromString(value) {\n  if (typeof window === \"undefined\") {\n    throw new Error(\"[tiptap error]: there is no window object available, so this function cannot be used\");\n  }\n  const wrappedValue = `<body>${value}</body>`;\n  const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n  return removeWhitespaces(html);\n}\n\n// src/helpers/createNodeFromContent.ts\nfunction createNodeFromContent(content, schema, options) {\n  if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment) {\n    return content;\n  }\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n  const isJSONContent = typeof content === \"object\" && content !== null;\n  const isTextContent = typeof content === \"string\";\n  if (isJSONContent) {\n    try {\n      const isArrayContent = Array.isArray(content) && content.length > 0;\n      if (isArrayContent) {\n        return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));\n      }\n      const node = schema.nodeFromJSON(content);\n      if (options.errorOnInvalidContent) {\n        node.check();\n      }\n      return node;\n    } catch (error) {\n      if (options.errorOnInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid JSON content\", { cause: error });\n      }\n      console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n      return createNodeFromContent(\"\", schema, options);\n    }\n  }\n  if (isTextContent) {\n    if (options.errorOnInvalidContent) {\n      let hasInvalidContent = false;\n      let invalidContent = \"\";\n      const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Schema({\n        topNode: schema.spec.topNode,\n        marks: schema.spec.marks,\n        // Prosemirror's schemas are executed such that: the last to execute, matches last\n        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n        nodes: schema.spec.nodes.append({\n          __tiptap__private__unknown__catch__all__node: {\n            content: \"inline*\",\n            group: \"block\",\n            parseDOM: [\n              {\n                tag: \"*\",\n                getAttrs: (e) => {\n                  hasInvalidContent = true;\n                  invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                  return null;\n                }\n              }\n            ]\n          }\n        })\n      });\n      if (options.slice) {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n      } else {\n        _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n      }\n      if (options.errorOnInvalidContent && hasInvalidContent) {\n        throw new Error(\"[tiptap error]: Invalid HTML content\", {\n          cause: new Error(`Invalid element found: ${invalidContent}`)\n        });\n      }\n    }\n    const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.DOMParser.fromSchema(schema);\n    if (options.slice) {\n      return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n    }\n    return parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent(\"\", schema, options);\n}\n\n// src/helpers/createDocument.ts\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions,\n    errorOnInvalidContent: options.errorOnInvalidContent\n  });\n}\n\n// src/helpers/defaultBlockAt.ts\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\n\n// src/helpers/findChildren.ts\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findChildrenInRange.ts\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\n// src/helpers/findParentNodeClosestToPos.ts\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\n// src/helpers/findParentNode.ts\nfunction findParentNode(predicate) {\n  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\n// src/helpers/getExtensionField.ts\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === void 0 && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === \"function\") {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n  return extension.config[field];\n}\n\n// src/helpers/flattenExtensions.ts\nfunction flattenExtensions(extensions) {\n  return extensions.map((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n    if (addExtensions) {\n      return [extension, ...flattenExtensions(addExtensions())];\n    }\n    return extension;\n  }).flat(10);\n}\n\n// src/helpers/generateHTML.ts\n\n\n// src/helpers/getHTMLFromFragment.ts\n\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement(\"div\");\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\n\n\n// src/utilities/isFunction.ts\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/utilities/callOrReturn.ts\nfunction callOrReturn(value, context = void 0, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\n\n// src/utilities/isEmptyObject.ts\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\n// src/helpers/splitExtensions.ts\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter((extension) => extension.type === \"extension\");\n  const nodeExtensions = extensions.filter((extension) => extension.type === \"node\");\n  const markExtensions = extensions.filter((extension) => extension.type === \"mark\");\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n\n// src/helpers/getAttributesFromExtensions.ts\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    validate: void 0,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      extensions: nodeAndMarkExtensions\n    };\n    const addGlobalAttributes = getExtensionField(\n      extension,\n      \"addGlobalAttributes\",\n      context\n    );\n    if (!addGlobalAttributes) {\n      return;\n    }\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach((globalAttribute) => {\n      globalAttribute.types.forEach((type) => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(\n      extension,\n      \"addAttributes\",\n      context\n    );\n    if (!addAttributes) {\n      return;\n    }\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute\n      };\n      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === \"function\") {\n        mergedAttr.default = mergedAttr.default();\n      }\n      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\n// src/utilities/mergeAttributes.ts\nfunction mergeAttributes(...objects) {\n  return objects.filter((item) => !!item).reduce((items, item) => {\n    const mergedAttributes = { ...items };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === \"class\") {\n        const valueClasses = value ? String(value).split(\" \") : [];\n        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));\n        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(\" \");\n      } else if (key === \"style\") {\n        const newStyles = value ? value.split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style2) => style2.trim()).filter(Boolean) : [];\n        const styleMap = /* @__PURE__ */ new Map();\n        existingStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        newStyles.forEach((style2) => {\n          const [property, val] = style2.split(\":\").map((part) => part.trim());\n          styleMap.set(property, val);\n        });\n        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join(\"; \");\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\n// src/helpers/getRenderedAttributes.ts\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\n// src/utilities/fromString.ts\nfunction fromString(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === \"true\") {\n    return true;\n  }\n  if (value === \"false\") {\n    return false;\n  }\n  return value;\n}\n\n// src/helpers/injectExtensionAttributesToParseRule.ts\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (\"style\" in parseRule) {\n    return parseRule;\n  }\n  return {\n    ...parseRule,\n    getAttrs: (node) => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === void 0) {\n          return items;\n        }\n        return {\n          ...items,\n          [item.name]: value\n        };\n      }, {});\n      return { ...oldAttributes, ...newAttributes };\n    }\n  };\n}\n\n// src/helpers/getSchemaByResolvedExtensions.ts\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === \"attrs\" && isEmptyObject(value)) {\n        return false;\n      }\n      return value !== null && value !== void 0;\n    })\n  );\n}\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, \"topNode\"))) == null ? void 0 : _a.name;\n  const nodes = Object.fromEntries(\n    nodeExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n        return {\n          ...fields,\n          ...extendNodeSchema ? extendNodeSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(getExtensionField(extension, \"content\", context)),\n        marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n        atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n        selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n        draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n        linebreakReplacement: callOrReturn(\n          getExtensionField(extension, \"linebreakReplacement\", context)\n        ),\n        defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n        isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map((extensionAttribute) => {\n            var _a2, _b;\n            return [\n              extensionAttribute.name,\n              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }\n            ];\n          })\n        )\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (node) => renderHTML({\n          node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n        });\n      }\n      const renderText = getExtensionField(extension, \"renderText\", context);\n      if (renderText) {\n        schema.toText = renderText;\n      }\n      return [extension.name, schema];\n    })\n  );\n  const marks = Object.fromEntries(\n    markExtensions.map((extension) => {\n      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor\n      };\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n        return {\n          ...fields,\n          ...extendMarkSchema ? extendMarkSchema(extension) : {}\n        };\n      }, {});\n      const schema = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n        excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n        group: callOrReturn(getExtensionField(extension, \"group\", context)),\n        spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n        code: callOrReturn(getExtensionField(extension, \"code\", context)),\n        attrs: Object.fromEntries(\n          extensionAttributes.map((extensionAttribute) => {\n            var _a2, _b;\n            return [\n              extensionAttribute.name,\n              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }\n            ];\n          })\n        )\n      });\n      const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(\n          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)\n        );\n      }\n      const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n      if (renderHTML) {\n        schema.toDOM = (mark) => renderHTML({\n          mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n        });\n      }\n      return [extension.name, schema];\n    })\n  );\n  return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\n\n// src/utilities/findDuplicates.ts\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return Array.from(new Set(filtered));\n}\n\n// src/helpers/sortExtensions.ts\nfunction sortExtensions(extensions) {\n  const defaultPriority = 100;\n  return extensions.sort((a, b) => {\n    const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n    const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n    if (priorityA > priorityB) {\n      return -1;\n    }\n    if (priorityA < priorityB) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\n// src/helpers/resolveExtensions.ts\nfunction resolveExtensions(extensions) {\n  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));\n  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));\n  if (duplicatedNames.length) {\n    console.warn(\n      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(\", \")}]. This can lead to issues.`\n    );\n  }\n  return resolvedExtensions;\n}\n\n// src/helpers/getSchema.ts\nfunction getSchema(extensions, editor) {\n  const resolvedExtensions = resolveExtensions(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n\n// src/helpers/generateHTML.ts\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Node.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\n\n// src/helpers/generateJSON.ts\n\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\n// src/helpers/generateText.ts\n\n\n// src/helpers/getTextBetween.ts\nfunction getTextBetween(startNode, range, options) {\n  const { from, to } = range;\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  let text = \"\";\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    if (node.isBlock && pos > from) {\n      text += blockSeparator;\n    }\n    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n      return false;\n    }\n    if (node.isText) {\n      text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n    }\n  });\n  return text;\n}\n\n// src/helpers/getText.ts\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\n\n// src/helpers/getTextSerializersFromSchema.ts\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(\n    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])\n  );\n}\n\n// src/helpers/generateText.ts\nfunction generateText(doc, extensions, options) {\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Node.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers\n    }\n  });\n}\n\n// src/helpers/getMarkType.ts\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/helpers/getMarkAttributes.ts\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const { from, to, empty } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, (node) => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find((markItem) => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return { ...mark.attrs };\n}\n\n// src/helpers/getNodeType.ts\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\n\n// src/helpers/getNodeAttributes.ts\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const { from, to } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, (node2) => {\n    nodes.push(node2);\n  });\n  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return { ...node.attrs };\n}\n\n// src/helpers/getSchemaTypeNameByName.ts\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return \"node\";\n  }\n  if (schema.marks[name]) {\n    return \"mark\";\n  }\n  return null;\n}\n\n// src/helpers/getAttributes.ts\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (schemaType === \"node\") {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === \"mark\") {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\n\n// src/utilities/removeDuplicates.ts\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter((item) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n\n// src/helpers/getChangedRanges.ts\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some((otherChange) => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\nfunction getChangedRanges(transform) {\n  const { mapping, steps } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index];\n      if (from === void 0 || to === void 0) {\n        return;\n      }\n      ranges.push({ from, to });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to });\n      });\n    }\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\n\n// src/helpers/getDebugJSON.ts\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map((mark) => {\n    const output2 = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output2.attrs = { ...mark.attrs };\n    }\n    return output2;\n  });\n  const attrs = { ...node.attrs };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) == null ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\n\n// src/utilities/isRegExp.ts\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\n\n// src/utilities/objectIncludes.ts\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every((key) => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\n\n// src/helpers/getMarkRange.ts\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find((item) => {\n    return item.type === type && objectIncludes(\n      // Only check equality for the attributes that are provided\n      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),\n      attributes\n    );\n  });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes) {\n  var _a;\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {\n    return;\n  }\n  attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\n// src/helpers/getMarksBetween.ts\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  if (from === to) {\n    doc.resolve(from).marks().forEach((mark) => {\n      const $pos = doc.resolve(from);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {\n        return;\n      }\n      marks.push(\n        ...node.marks.map((mark) => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark\n        }))\n      );\n    });\n  }\n  return marks;\n}\n\n// src/helpers/getNodeAtPosition.ts\nvar getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos);\n  let currentDepth = maxDepth;\n  let node = null;\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth);\n    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {\n      node = currentNode;\n    } else {\n      currentDepth -= 1;\n    }\n  }\n  return [node, currentDepth];\n};\n\n// src/helpers/getSchemaTypeByName.ts\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\n\n// src/helpers/getSplittedAttributes.ts\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find((item) => {\n        return item.type === typeName && item.name === name;\n      });\n      if (!extensionAttribute) {\n        return false;\n      }\n      return extensionAttribute.attribute.keepOnSplit;\n    })\n  );\n}\n\n// src/helpers/getTextContentFromNodes.ts\nvar getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = \"\";\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || \"%leaf%\";\n    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\n\n// src/helpers/isMarkActive.ts\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const { empty, ranges } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range2 = relativeTo - relativeFrom;\n      selectionRange += range2;\n      markRanges.push(\n        ...node.marks.map((mark) => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo\n        }))\n      );\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  const matchedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const excludedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\n// src/helpers/isNodeActive.ts\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const { from, to, empty } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\n\n// src/helpers/isActive.ts\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === \"node\") {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === \"mark\") {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\n\n// src/helpers/isAtEndOfNode.ts\nvar isAtEndOfNode = (state, nodeType) => {\n  const { $from, $to, $anchor } = state.selection;\n  if (nodeType) {\n    const parentNode = findParentNode((node) => node.type.name === nodeType)(state.selection);\n    if (!parentNode) {\n      return false;\n    }\n    const $parentPos = state.doc.resolve(parentNode.pos + 1);\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true;\n    }\n    return false;\n  }\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isAtStartOfNode.ts\nvar isAtStartOfNode = (state) => {\n  const { $from, $to } = state.selection;\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false;\n  }\n  return true;\n};\n\n// src/helpers/isExtensionRulesEnabled.ts\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some((enabledExtension) => {\n      const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\n\n// src/helpers/isList.ts\nfunction isList(name, extensions) {\n  const { nodeExtensions } = splitExtensions(extensions);\n  const extension = nodeExtensions.find((item) => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, \"group\", context));\n  if (typeof group !== \"string\") {\n    return false;\n  }\n  return group.split(\" \").includes(\"list\");\n}\n\n// src/helpers/isNodeEmpty.ts\nfunction isNodeEmpty(node, {\n  checkChildren = true,\n  ignoreWhitespace = false\n} = {}) {\n  var _a;\n  if (ignoreWhitespace) {\n    if (node.type.name === \"hardBreak\") {\n      return true;\n    }\n    if (node.isText) {\n      return /^\\s*$/m.test((_a = node.text) != null ? _a : \"\");\n    }\n  }\n  if (node.isText) {\n    return !node.text;\n  }\n  if (node.isAtom || node.isLeaf) {\n    return false;\n  }\n  if (node.content.childCount === 0) {\n    return true;\n  }\n  if (checkChildren) {\n    let isContentEmpty = true;\n    node.content.forEach((childNode) => {\n      if (isContentEmpty === false) {\n        return;\n      }\n      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n        isContentEmpty = false;\n      }\n    });\n    return isContentEmpty;\n  }\n  return false;\n}\n\n// src/helpers/isNodeSelection.ts\n\nfunction isNodeSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\n\n// src/helpers/isTextSelection.ts\n\nfunction isTextSelection(value) {\n  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\n\n// src/utilities/minMax.ts\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\n\n// src/helpers/posToDOMRect.ts\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return {\n    ...data,\n    toJSON: () => data\n  };\n}\n\n// src/helpers/resolveFocusPosition.ts\n\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n  const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n  if (position === \"start\" || position === true) {\n    return selectionAtStart;\n  }\n  if (position === \"end\") {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === \"all\") {\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\n// src/helpers/rewriteUnknownContent.ts\nfunction rewriteUnknownContentInner({\n  json,\n  validMarks,\n  validNodes,\n  options,\n  rewrittenContent = []\n}) {\n  if (json.marks && Array.isArray(json.marks)) {\n    json.marks = json.marks.filter((mark) => {\n      const name = typeof mark === \"string\" ? mark : mark.type;\n      if (validMarks.has(name)) {\n        return true;\n      }\n      rewrittenContent.push({\n        original: JSON.parse(JSON.stringify(mark)),\n        unsupported: name\n      });\n      return false;\n    });\n  }\n  if (json.content && Array.isArray(json.content)) {\n    json.content = json.content.map(\n      (value) => rewriteUnknownContentInner({\n        json: value,\n        validMarks,\n        validNodes,\n        options,\n        rewrittenContent\n      }).json\n    ).filter((a) => a !== null && a !== void 0);\n  }\n  if (json.type && !validNodes.has(json.type)) {\n    rewrittenContent.push({\n      original: JSON.parse(JSON.stringify(json)),\n      unsupported: json.type\n    });\n    if (json.content && Array.isArray(json.content) && (options == null ? void 0 : options.fallbackToParagraph) !== false) {\n      json.type = \"paragraph\";\n      return {\n        json,\n        rewrittenContent\n      };\n    }\n    return {\n      json: null,\n      rewrittenContent\n    };\n  }\n  return { json, rewrittenContent };\n}\nfunction rewriteUnknownContent(json, schema, options) {\n  return rewriteUnknownContentInner({\n    json,\n    validNodes: new Set(Object.keys(schema.nodes)),\n    validMarks: new Set(Object.keys(schema.marks)),\n    options\n  });\n}\n\n// src/helpers/selectionToInsertionEnd.ts\n\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\n\n// src/InputRule.ts\n\n\nvar InputRule = class {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n};\nvar inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [inputRuleMatch.text];\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run(config) {\n  var _a;\n  const { editor, from, to, text, rules, plugin } = config;\n  const { view } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if (\n    // check for code node\n    $from.parent.type.spec.code || // check for code mark\n    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))\n  ) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach((rule) => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    });\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\nfunction inputRulesPlugin(props) {\n  const { editor, rules } = props;\n  const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev, state) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n        const isSimulatedInput = !!simulatedInputMeta;\n        if (isSimulatedInput) {\n          setTimeout(() => {\n            let { text } = simulatedInputMeta;\n            if (typeof text === \"string\") {\n              text = text;\n            } else {\n              text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(text), state.schema);\n            }\n            const { from } = simulatedInputMeta;\n            const to = from + text.length;\n            run({\n              editor,\n              from,\n              to,\n              text,\n              rules,\n              plugin\n            });\n          });\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection;\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: \"\",\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== \"Enter\") {\n          return false;\n        }\n        const { $cursor } = view.state.selection;\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: \"\\n\",\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\n\n// src/utilities/isPlainObject.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== \"Object\") {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\n// src/utilities/mergeDeep.ts\nfunction mergeDeep(target, source) {\n  const output = { ...target };\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n        output[key] = mergeDeep(target[key], source[key]);\n      } else {\n        output[key] = source[key];\n      }\n    });\n  }\n  return output;\n}\n\n// src/Extendable.ts\nvar Extendable = class {\n  constructor(config = {}) {\n    this.type = \"extendable\";\n    this.parent = null;\n    this.child = null;\n    this.name = \"\";\n    this.config = {\n      name: this.name\n    };\n    this.config = {\n      ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n  }\n  get options() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addOptions\", {\n          name: this.name\n        })\n      ) || {}\n    };\n  }\n  get storage() {\n    return {\n      ...callOrReturn(\n        getExtensionField(this, \"addStorage\", {\n          name: this.name,\n          options: this.options\n        })\n      ) || {}\n    };\n  }\n  configure(options = {}) {\n    const extension = this.extend({\n      ...this.config,\n      addOptions: () => {\n        return mergeDeep(this.options, options);\n      }\n    });\n    extension.name = this.name;\n    extension.parent = this.parent;\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new this.constructor({ ...this.config, ...extendedConfig });\n    extension.parent = this;\n    this.child = extension;\n    extension.name = \"name\" in extendedConfig ? extendedConfig.name : extension.parent.name;\n    return extension;\n  }\n};\n\n// src/Mark.ts\nvar Mark = class _Mark extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"mark\";\n  }\n  /**\n   * Create a new Mark instance\n   * @param config - Mark configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Mark(resolvedConfig);\n  }\n  static handleExit({ editor, mark }) {\n    const { tr } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(\" \", currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/PasteRule.ts\n\n\n\n// src/utilities/isNumber.ts\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\n\n// src/PasteRule.ts\nvar PasteRule = class {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n};\nvar pasteRuleMatcherHandler = (text, find, event) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text, event);\n  if (!matches) {\n    return [];\n  }\n  return matches.map((pasteRuleMatch) => {\n    const result = [pasteRuleMatch.text];\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run2(config) {\n  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, \"\\uFFFC\");\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n    matches.forEach((match) => {\n      if (match.index === void 0) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every((handler) => handler !== null);\n  return success;\n}\nvar tiptapDragFromOtherEditor = null;\nvar createClipboardPasteEvent = (text) => {\n  var _a;\n  const event = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer()\n  });\n  (_a = event.clipboardData) == null ? void 0 : _a.setData(\"text/html\", text);\n  return event;\n};\nfunction pasteRulesPlugin(props) {\n  const { editor, rules } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n  let dropEvent;\n  try {\n    dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n  } catch {\n    dropEvent = null;\n  }\n  const processEvent = ({\n    state,\n    from,\n    to,\n    rule,\n    pasteEvt\n  }) => {\n    const tr = state.tr;\n    const chainableState = createChainableState({\n      state,\n      transaction: tr\n    });\n    const handler = run2({\n      editor,\n      state: chainableState,\n      from: Math.max(from - 1, 0),\n      to: to.b - 1,\n      rule,\n      pasteEvent: pasteEvt,\n      dropEvent\n    });\n    if (!handler || !tr.steps.length) {\n      return;\n    }\n    try {\n      dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch {\n      dropEvent = null;\n    }\n    pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    return tr;\n  };\n  const plugins = rules.map((rule) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event) => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n          if (dragSourceElement) {\n            tiptapDragFromOtherEditor = editor;\n          }\n        };\n        const handleDragend = () => {\n          if (tiptapDragFromOtherEditor) {\n            tiptapDragFromOtherEditor = null;\n          }\n        };\n        window.addEventListener(\"dragstart\", handleDragstart);\n        window.addEventListener(\"dragend\", handleDragend);\n        return {\n          destroy() {\n            window.removeEventListener(\"dragstart\", handleDragstart);\n            window.removeEventListener(\"dragend\", handleDragend);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view, event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            dropEvent = event;\n            if (!isDroppedFromProseMirror) {\n              const dragFromOtherEditor = tiptapDragFromOtherEditor;\n              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {\n                setTimeout(() => {\n                  const selection = dragFromOtherEditor.state.selection;\n                  if (selection) {\n                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });\n                  }\n                }, 10);\n              }\n            }\n            return false;\n          },\n          paste: (_view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) == null ? void 0 : _a.getData(\"text/html\");\n            pasteEvent = event;\n            isPastedFromProseMirror = !!(html == null ? void 0 : html.includes(\"data-pm-slice\"));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n        const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n        const isSimulatedPaste = !!simulatedPasteMeta;\n        if (!isPaste && !isDrop && !isSimulatedPaste) {\n          return;\n        }\n        if (isSimulatedPaste) {\n          let { text } = simulatedPasteMeta;\n          if (typeof text === \"string\") {\n            text = text;\n          } else {\n            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(text), state.schema);\n          }\n          const { from: from2 } = simulatedPasteMeta;\n          const to2 = from2 + text.length;\n          const pasteEvt = createClipboardPasteEvent(text);\n          return processEvent({\n            rule,\n            state,\n            from: from2,\n            to: { b: to2 },\n            pasteEvt\n          });\n        }\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        return processEvent({\n          rule,\n          state,\n          from,\n          to,\n          pasteEvt: pasteEvent\n        });\n      }\n    });\n  });\n  return plugins;\n}\n\n// src/ExtensionManager.ts\nvar ExtensionManager = class {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = resolveExtensions(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n    this.setupExtensions();\n  }\n  /**\n   * Get all commands from the extensions.\n   * @returns An object with all commands where the key is the command name and the value is the command function\n   */\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, \"addCommands\", context);\n      if (!addCommands) {\n        return commands;\n      }\n      return {\n        ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n  /**\n   * Get all registered Prosemirror plugins from the extensions.\n   * @returns An array of Prosemirror plugins\n   */\n  get plugins() {\n    const { editor } = this;\n    const extensions = sortExtensions([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map((extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(\n        extension,\n        \"addKeyboardShortcuts\",\n        context\n      );\n      let defaultBindings = {};\n      if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(\n          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n            return [shortcut, () => method({ editor })];\n          })\n        );\n        defaultBindings = { ...defaultBindings, ...bindings };\n      }\n      const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(\n        extension,\n        \"addProseMirrorPlugins\",\n        context\n      );\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules\n      }),\n      ...allPlugins\n    ];\n  }\n  /**\n   * Get all attributes from the extensions.\n   * @returns An array of attributes\n   */\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  /**\n   * Get all node views from the extensions.\n   * @returns An object with all node views where the key is the node name and the value is the node view function\n   */\n  get nodeViews() {\n    const { editor } = this;\n    const { nodeExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      nodeExtensions.filter((extension) => !!getExtensionField(extension, \"addNodeView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getNodeType(extension.name, this.schema)\n        };\n        const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n        if (!addNodeView) {\n          return [];\n        }\n        const nodeview = (node, view, getPos, decorations, innerDecorations) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n          return addNodeView()({\n            // pass-through\n            node,\n            view,\n            getPos,\n            decorations,\n            innerDecorations,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes\n          });\n        };\n        return [extension.name, nodeview];\n      })\n    );\n  }\n  get markViews() {\n    const { editor } = this;\n    const { markExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(\n      markExtensions.filter((extension) => !!getExtensionField(extension, \"addMarkView\")).map((extension) => {\n        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: this.editor.extensionStorage[extension.name],\n          editor,\n          type: getMarkType(extension.name, this.schema)\n        };\n        const addMarkView = getExtensionField(extension, \"addMarkView\", context);\n        if (!addMarkView) {\n          return [];\n        }\n        const markView = (mark, view, inline) => {\n          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);\n          return addMarkView()({\n            // pass-through\n            mark,\n            view,\n            inline,\n            // tiptap-specific\n            editor,\n            extension,\n            HTMLAttributes,\n            updateAttributes: (attrs) => {\n              updateMarkViewAttributes(mark, editor, attrs);\n            }\n          });\n        };\n        return [extension.name, markView];\n      })\n    );\n  }\n  /**\n   * Go through all extensions, create extension storages & setup marks\n   * & bind editor event listener.\n   */\n  setupExtensions() {\n    const extensions = this.extensions;\n    this.editor.extensionStorage = Object.fromEntries(\n      extensions.map((extension) => [extension.name, extension.storage])\n    );\n    extensions.forEach((extension) => {\n      var _a;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === \"mark\") {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) != null ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n      const onCreate = getExtensionField(extension, \"onCreate\", context);\n      const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n      const onSelectionUpdate = getExtensionField(\n        extension,\n        \"onSelectionUpdate\",\n        context\n      );\n      const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n      const onFocus = getExtensionField(extension, \"onFocus\", context);\n      const onBlur = getExtensionField(extension, \"onBlur\", context);\n      const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n      if (onBeforeCreate) {\n        this.editor.on(\"beforeCreate\", onBeforeCreate);\n      }\n      if (onCreate) {\n        this.editor.on(\"create\", onCreate);\n      }\n      if (onUpdate) {\n        this.editor.on(\"update\", onUpdate);\n      }\n      if (onSelectionUpdate) {\n        this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n      }\n      if (onTransaction) {\n        this.editor.on(\"transaction\", onTransaction);\n      }\n      if (onFocus) {\n        this.editor.on(\"focus\", onFocus);\n      }\n      if (onBlur) {\n        this.editor.on(\"blur\", onBlur);\n      }\n      if (onDestroy) {\n        this.editor.on(\"destroy\", onDestroy);\n      }\n    });\n  }\n};\nExtensionManager.resolve = resolveExtensions;\nExtensionManager.sort = sortExtensions;\nExtensionManager.flatten = flattenExtensions;\n\n// src/extensions/index.ts\nvar extensions_exports = {};\n__export(extensions_exports, {\n  ClipboardTextSerializer: () => ClipboardTextSerializer,\n  Commands: () => Commands,\n  Delete: () => Delete,\n  Drop: () => Drop,\n  Editable: () => Editable,\n  FocusEvents: () => FocusEvents,\n  Keymap: () => Keymap,\n  Paste: () => Paste,\n  Tabindex: () => Tabindex,\n  focusEventsPluginKey: () => focusEventsPluginKey\n});\n\n// src/extensions/clipboardTextSerializer.ts\n\n\n// src/Extension.ts\nvar Extension = class _Extension extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"extension\";\n  }\n  /**\n   * Create a new Extension instance\n   * @param config - Extension configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Extension(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/extensions/clipboardTextSerializer.ts\nvar ClipboardTextSerializer = Extension.create({\n  name: \"clipboardTextSerializer\",\n  addOptions() {\n    return {\n      blockSeparator: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clipboardTextSerializer\"),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this;\n            const { state, schema } = editor;\n            const { doc, selection } = state;\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range2) => range2.$from.pos));\n            const to = Math.max(...ranges.map((range2) => range2.$to.pos));\n            const textSerializers = getTextSerializersFromSchema(schema);\n            const range = { from, to };\n            return getTextBetween(doc, range, {\n              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},\n              textSerializers\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/commands/index.ts\nvar commands_exports = {};\n__export(commands_exports, {\n  blur: () => blur,\n  clearContent: () => clearContent,\n  clearNodes: () => clearNodes,\n  command: () => command,\n  createParagraphNear: () => createParagraphNear,\n  cut: () => cut,\n  deleteCurrentNode: () => deleteCurrentNode,\n  deleteNode: () => deleteNode,\n  deleteRange: () => deleteRange,\n  deleteSelection: () => deleteSelection,\n  enter: () => enter,\n  exitCode: () => exitCode,\n  extendMarkRange: () => extendMarkRange,\n  first: () => first,\n  focus: () => focus,\n  forEach: () => forEach,\n  insertContent: () => insertContent,\n  insertContentAt: () => insertContentAt,\n  joinBackward: () => joinBackward,\n  joinDown: () => joinDown,\n  joinForward: () => joinForward,\n  joinItemBackward: () => joinItemBackward,\n  joinItemForward: () => joinItemForward,\n  joinTextblockBackward: () => joinTextblockBackward,\n  joinTextblockForward: () => joinTextblockForward,\n  joinUp: () => joinUp,\n  keyboardShortcut: () => keyboardShortcut,\n  lift: () => lift,\n  liftEmptyBlock: () => liftEmptyBlock,\n  liftListItem: () => liftListItem,\n  newlineInCode: () => newlineInCode,\n  resetAttributes: () => resetAttributes,\n  scrollIntoView: () => scrollIntoView,\n  selectAll: () => selectAll,\n  selectNodeBackward: () => selectNodeBackward,\n  selectNodeForward: () => selectNodeForward,\n  selectParentNode: () => selectParentNode,\n  selectTextblockEnd: () => selectTextblockEnd,\n  selectTextblockStart: () => selectTextblockStart,\n  setContent: () => setContent,\n  setMark: () => setMark,\n  setMeta: () => setMeta,\n  setNode: () => setNode,\n  setNodeSelection: () => setNodeSelection,\n  setTextSelection: () => setTextSelection,\n  sinkListItem: () => sinkListItem,\n  splitBlock: () => splitBlock,\n  splitListItem: () => splitListItem,\n  toggleList: () => toggleList,\n  toggleMark: () => toggleMark,\n  toggleNode: () => toggleNode,\n  toggleWrap: () => toggleWrap,\n  undoInputRule: () => undoInputRule,\n  unsetAllMarks: () => unsetAllMarks,\n  unsetMark: () => unsetMark,\n  updateAttributes: () => updateAttributes,\n  wrapIn: () => wrapIn,\n  wrapInList: () => wrapInList\n});\n\n// src/commands/blur.ts\nvar blur = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      ;\n      view.dom.blur();\n      (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\n\n// src/commands/clearContent.ts\nvar clearContent = (emitUpdate = true) => ({ commands }) => {\n  return commands.setContent(\"\", { emitUpdate });\n};\n\n// src/commands/clearNodes.ts\n\nvar clearNodes = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr;\n  const { ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const { doc, mapping } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.liftTarget)(nodeRange);\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\n\n// src/commands/command.ts\nvar command = (fn) => (props) => {\n  return fn(props);\n};\n\n// src/commands/createParagraphNear.ts\n\nvar createParagraphNear = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n};\n\n// src/commands/cut.ts\n\nvar cut = (originRange, targetPos) => ({ editor, tr }) => {\n  const { state } = editor;\n  const contentSlice = state.doc.slice(originRange.from, originRange.to);\n  tr.deleteRange(originRange.from, originRange.to);\n  const newPos = tr.mapping.map(targetPos);\n  tr.insert(newPos, contentSlice.content);\n  tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n  return true;\n};\n\n// src/commands/deleteCurrentNode.ts\nvar deleteCurrentNode = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const currentNode = selection.$anchor.node();\n  if (currentNode.content.size > 0) {\n    return false;\n  }\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === currentNode.type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/deleteNode.ts\nvar deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/deleteRange.ts\nvar deleteRange = (range) => ({ tr, dispatch }) => {\n  const { from, to } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\n\n// src/commands/deleteSelection.ts\n\nvar deleteSelection = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n};\n\n// src/commands/enter.ts\nvar enter = () => ({ commands }) => {\n  return commands.keyboardShortcut(\"Enter\");\n};\n\n// src/commands/exitCode.ts\n\nvar exitCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n};\n\n// src/commands/extendMarkRange.ts\n\nvar extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const { doc, selection } = tr;\n  const { $from, from, to } = selection;\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n  return true;\n};\n\n// src/commands/first.ts\nvar first = (commands) => (props) => {\n  const items = typeof commands === \"function\" ? commands(props) : commands;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/utilities/isAndroid.ts\nfunction isAndroid() {\n  return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\n\n// src/utilities/isiOS.ts\nfunction isiOS() {\n  return [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || // iPad on iOS 13 detection\n  navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\n\n// src/commands/focus.ts\nvar focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {\n  options = {\n    scrollIntoView: true,\n    ...options\n  };\n  const delayedFocus = () => {\n    if (isiOS() || isAndroid()) {\n      ;\n      view.dom.focus();\n    }\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n        if (options == null ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  }\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  }\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    }\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n    delayedFocus();\n  }\n  return true;\n};\n\n// src/commands/forEach.ts\nvar forEach = (items, fn) => (props) => {\n  return items.every((item, index) => fn(item, { ...props, index }));\n};\n\n// src/commands/insertContent.ts\nvar insertContent = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\n\n// src/commands/insertContentAt.ts\n\nvar isFragment = (nodeOrFragment) => {\n  return !(\"type\" in nodeOrFragment);\n};\nvar insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n  var _a;\n  if (dispatch) {\n    options = {\n      parseOptions: editor.options.parseOptions,\n      updateSelection: true,\n      applyInputRules: false,\n      applyPasteRules: false,\n      ...options\n    };\n    let content;\n    const { selection } = editor.state;\n    const emitContentError = (error) => {\n      editor.emit(\"contentError\", {\n        editor,\n        error,\n        disableCollaboration: () => {\n          if (\"collaboration\" in editor.storage && typeof editor.storage.collaboration === \"object\" && editor.storage.collaboration) {\n            ;\n            editor.storage.collaboration.isDisabled = true;\n          }\n        }\n      });\n    };\n    const parseOptions = {\n      preserveWhitespace: \"full\",\n      ...options.parseOptions\n    };\n    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n      try {\n        createNodeFromContent(value, editor.schema, {\n          parseOptions,\n          errorOnInvalidContent: true\n        });\n      } catch (e) {\n        emitContentError(e);\n      }\n    }\n    try {\n      content = createNodeFromContent(value, editor.schema, {\n        parseOptions,\n        errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck\n      });\n    } catch (e) {\n      emitContentError(e);\n      return false;\n    }\n    let { from, to } = typeof position === \"number\" ? { from: position, to: position } : { from: position.from, to: position.to };\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach((node) => {\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    let newContent;\n    if (isOnlyTextContent) {\n      if (Array.isArray(value)) {\n        newContent = value.map((v) => v.text || \"\").join(\"\");\n      } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment) {\n        let text = \"\";\n        value.forEach((node) => {\n          if (node.text) {\n            text += node.text;\n          }\n        });\n        newContent = text;\n      } else if (typeof value === \"object\" && !!value && !!value.text) {\n        newContent = value.text;\n      } else {\n        newContent = value;\n      }\n      tr.insertText(newContent, from, to);\n    } else {\n      newContent = content;\n      const fromSelectionAtStart = selection.$from.parentOffset === 0;\n      const isTextSelection2 = selection.$from.node().isText || selection.$from.node().isTextblock;\n      const hasContent = selection.$from.node().content.size > 0;\n      if (fromSelectionAtStart && isTextSelection2 && hasContent) {\n        from = Math.max(0, from - 1);\n      }\n      tr.replaceWith(from, to, newContent);\n    }\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n    if (options.applyInputRules) {\n      tr.setMeta(\"applyInputRules\", { from, text: newContent });\n    }\n    if (options.applyPasteRules) {\n      tr.setMeta(\"applyPasteRules\", { from, text: newContent });\n    }\n  }\n  return true;\n};\n\n// src/commands/join.ts\n\nvar joinUp = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n};\nvar joinDown = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n};\nvar joinBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n};\nvar joinForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n};\n\n// src/commands/joinItemBackward.ts\n\nvar joinItemBackward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinItemForward.ts\n\nvar joinItemForward = () => ({ state, dispatch, tr }) => {\n  try {\n    const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.joinPoint)(state.doc, state.selection.$from.pos, 1);\n    if (point === null || point === void 0) {\n      return false;\n    }\n    tr.join(point, 2);\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// src/commands/joinTextblockBackward.ts\n\nvar joinTextblockBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n};\n\n// src/commands/joinTextblockForward.ts\n\nvar joinTextblockForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n};\n\n// src/utilities/isMacOS.ts\nfunction isMacOS() {\n  return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\n\n// src/commands/keyboardShortcut.ts\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === \"Space\") {\n    result = \" \";\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nvar keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find((item) => ![\"Alt\", \"Ctrl\", \"Meta\", \"Shift\"].includes(item));\n  const event = new KeyboardEvent(\"keydown\", {\n    key: key === \"Space\" ? \" \" : key,\n    altKey: keys.includes(\"Alt\"),\n    ctrlKey: keys.includes(\"Ctrl\"),\n    metaKey: keys.includes(\"Meta\"),\n    shiftKey: keys.includes(\"Shift\"),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp(\"handleKeyDown\", (f) => f(view, event));\n  });\n  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\n\n// src/commands/lift.ts\n\nvar lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (!isActive2) {\n    return false;\n  }\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n};\n\n// src/commands/liftEmptyBlock.ts\n\nvar liftEmptyBlock = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n};\n\n// src/commands/liftListItem.ts\n\nvar liftListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n};\n\n// src/commands/newlineInCode.ts\n\nvar newlineInCode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n};\n\n// src/utilities/deleteProps.ts\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === \"string\" ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\n\n// src/commands/resetAttributes.ts\nvar resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\n\n// src/commands/scrollIntoView.ts\nvar scrollIntoView = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\n\n// src/commands/selectAll.ts\n\nvar selectAll = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection(tr.doc);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/selectNodeBackward.ts\n\nvar selectNodeBackward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n};\n\n// src/commands/selectNodeForward.ts\n\nvar selectNodeForward = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n};\n\n// src/commands/selectParentNode.ts\n\nvar selectParentNode = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n};\n\n// src/commands/selectTextblockEnd.ts\n\nvar selectTextblockEnd = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n};\n\n// src/commands/selectTextblockStart.ts\n\nvar selectTextblockStart = () => ({ state, dispatch }) => {\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n};\n\n// src/commands/setContent.ts\nvar setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr, dispatch, commands }) => {\n  const { doc } = tr;\n  if (parseOptions.preserveWhitespace !== \"full\") {\n    const document2 = createDocument(content, editor.schema, parseOptions, {\n      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n    });\n    if (dispatch) {\n      tr.replaceWith(0, doc.content.size, document2).setMeta(\"preventUpdate\", !emitUpdate);\n    }\n    return true;\n  }\n  if (dispatch) {\n    tr.setMeta(\"preventUpdate\", !emitUpdate);\n  }\n  return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n    parseOptions,\n    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck\n  });\n};\n\n// src/commands/setMark.ts\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const { selection } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));\n  }\n  const { ranges } = selection;\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nvar setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(\n        type.create({\n          ...oldAttributes,\n          ...attributes\n        })\n      );\n    } else {\n      ranges.forEach((range) => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find((mark) => mark.type === type);\n          if (someHasMark) {\n            node.marks.forEach((mark) => {\n              if (type === mark.type) {\n                tr.addMark(\n                  trimmedFrom,\n                  trimmedTo,\n                  type.create({\n                    ...mark.attrs,\n                    ...attributes\n                  })\n                );\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n  return canSetMark(state, tr, type);\n};\n\n// src/commands/setMeta.ts\nvar setMeta = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value);\n  return true;\n};\n\n// src/commands/setNode.ts\n\nvar setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n  return chain().command(({ commands }) => {\n    const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(state);\n    if (canSetBlock) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).command(({ state: updatedState }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);\n  }).run();\n};\n\n// src/commands/setNodeSelection.ts\n\nvar setNodeSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/setTextSelection.ts\n\nvar setTextSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const { from, to } = typeof position === \"number\" ? { from: position, to: position } : position;\n    const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n    const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\n\n// src/commands/sinkListItem.ts\n\nvar sinkListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n};\n\n// src/commands/splitBlock.ts\n\n\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nvar splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {\n  const { selection, doc } = tr;\n  const { $from, $to } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(doc, $from.pos)) {\n      return false;\n    }\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.split($from.pos).scrollIntoView();\n    }\n    return true;\n  }\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n  const atEnd = $to.parentOffset === $to.parent.content.size;\n  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n  let types = atEnd && deflt ? [\n    {\n      type: deflt,\n      attrs: newAttributes\n    }\n  ] : void 0;\n  let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n  if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {\n    can = true;\n    types = deflt ? [\n      {\n        type: deflt,\n        attrs: newAttributes\n      }\n    ] : void 0;\n  }\n  if (dispatch) {\n    if (can) {\n      if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n        tr.deleteSelection();\n      }\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first2 = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first2);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n    tr.scrollIntoView();\n  }\n  return can;\n};\n\n// src/commands/splitListItem.ts\n\n\n\nvar splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const { $from, $to } = state.selection;\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.empty;\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.from($from.node(d).copy(wrap));\n      }\n      const depthAfter = (\n        // eslint-disable-next-line no-nested-ternary\n        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n      );\n      const newNextTypeAttributes2 = {\n        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n        ...overrideAttrs\n      };\n      const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;\n      wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(type.createAndFill(null, nextType2) || void 0));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_4__.Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n    ...overrideAttrs\n  };\n  const newNextTypeAttributes = {\n    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n    ...overrideAttrs\n  };\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [\n    { type, attrs: newTypeAttributes },\n    { type: nextType, attrs: newNextTypeAttributes }\n  ] : [{ type, attrs: newTypeAttributes }];\n  if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    const { selection, storedMarks } = state;\n    const { splittableMarks } = editor.extensionManager;\n    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n    tr.split($from.pos, 2, types).scrollIntoView();\n    if (!marks || !dispatch) {\n      return true;\n    }\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n  }\n  return true;\n};\n\n// src/commands/toggleList.ts\n\nvar joinListBackwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === void 0) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nvar joinListForwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === void 0) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nvar toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can }) => {\n  const { extensions, splittableMarks } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const { selection, storedMarks } = state;\n  const { $from, $to } = selection;\n  const range = $from.blockRange($to);\n  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    }\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  if (!keepMarks || !marks || !dispatch) {\n    return chain().command(() => {\n      const canWrapInList = can().wrapInList(listType, attributes);\n      if (canWrapInList) {\n        return true;\n      }\n      return commands.clearNodes();\n    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n  }\n  return chain().command(() => {\n    const canWrapInList = can().wrapInList(listType, attributes);\n    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n    tr.ensureMarks(filteredMarks);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands.clearNodes();\n  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\n\n// src/commands/toggleMark.ts\nvar toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive2 = isMarkActive(state, type, attributes);\n  if (isActive2) {\n    return commands.unsetMark(type, { extendEmptyMarkRange });\n  }\n  return commands.setMark(type, attributes);\n};\n\n// src/commands/toggleNode.ts\nvar toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  let attributesToCopy;\n  if (state.selection.$anchor.sameParent(state.selection.$head)) {\n    attributesToCopy = state.selection.$anchor.parent.attrs;\n  }\n  if (isActive2) {\n    return commands.setNode(toggleType, attributesToCopy);\n  }\n  return commands.setNode(type, { ...attributesToCopy, ...attributes });\n};\n\n// src/commands/toggleWrap.ts\nvar toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (isActive2) {\n    return commands.lift(type);\n  }\n  return commands.wrapIn(type, attributes);\n};\n\n// src/commands/undoInputRule.ts\nvar undoInputRule = () => ({ state, dispatch }) => {\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n// src/commands/unsetAllMarks.ts\nvar unsetAllMarks = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\n\n// src/commands/unsetMark.ts\nvar unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  var _a;\n  const { extendEmptyMarkRange = false } = options;\n  const { selection } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const { $from, empty, ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection;\n    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n  tr.removeStoredMark(type);\n  return true;\n};\n\n// src/commands/updateAttributes.ts\nvar updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === \"string\" ? typeOrName : typeOrName.name,\n    state.schema\n  );\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      let lastPos;\n      let lastNode;\n      let trimmedFrom;\n      let trimmedTo;\n      if (tr.selection.empty) {\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (nodeType && nodeType === node.type) {\n            trimmedFrom = Math.max(pos, from);\n            trimmedTo = Math.min(pos + node.nodeSize, to);\n            lastPos = pos;\n            lastNode = node;\n          }\n        });\n      } else {\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          if (pos < from && nodeType && nodeType === node.type) {\n            trimmedFrom = Math.max(pos, from);\n            trimmedTo = Math.min(pos + node.nodeSize, to);\n            lastPos = pos;\n            lastNode = node;\n          }\n          if (pos >= from && pos <= to) {\n            if (nodeType && nodeType === node.type) {\n              tr.setNodeMarkup(pos, void 0, {\n                ...node.attrs,\n                ...attributes\n              });\n            }\n            if (markType && node.marks.length) {\n              node.marks.forEach((mark) => {\n                if (markType === mark.type) {\n                  const trimmedFrom2 = Math.max(pos, from);\n                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                  tr.addMark(\n                    trimmedFrom2,\n                    trimmedTo2,\n                    markType.create({\n                      ...mark.attrs,\n                      ...attributes\n                    })\n                  );\n                }\n              });\n            }\n          }\n        });\n      }\n      if (lastNode) {\n        if (lastPos !== void 0) {\n          tr.setNodeMarkup(lastPos, void 0, {\n            ...lastNode.attrs,\n            ...attributes\n          });\n        }\n        if (markType && lastNode.marks.length) {\n          lastNode.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes\n                })\n              );\n            }\n          });\n        }\n      }\n    });\n  }\n  return true;\n};\n\n// src/commands/wrapIn.ts\n\nvar wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n};\n\n// src/commands/wrapInList.ts\n\nvar wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n};\n\n// src/extensions/commands.ts\nvar Commands = Extension.create({\n  name: \"commands\",\n  addCommands() {\n    return {\n      ...commands_exports\n    };\n  }\n});\n\n// src/extensions/delete.ts\n\nvar Delete = Extension.create({\n  name: \"delete\",\n  onUpdate({ transaction, appendedTransactions }) {\n    var _a, _b, _c;\n    const callback = () => {\n      var _a2, _b2, _c2, _d;\n      if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta(\"y-sync$\")) {\n        return;\n      }\n      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);\n      const changes = getChangedRanges(nextTransaction);\n      changes.forEach((change) => {\n        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {\n          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from) => {\n            const to = from + node.nodeSize - 2;\n            const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to;\n            this.editor.emit(\"delete\", {\n              type: \"node\",\n              node,\n              from,\n              to,\n              newFrom: nextTransaction.mapping.map(from),\n              newTo: nextTransaction.mapping.map(to),\n              deletedRange: change.oldRange,\n              newRange: change.newRange,\n              partial: !isFullyWithinRange,\n              editor: this.editor,\n              transaction,\n              combinedTransform: nextTransaction\n            });\n          });\n        }\n      });\n      const mapping = nextTransaction.mapping;\n      nextTransaction.steps.forEach((step, index) => {\n        var _a3, _b3;\n        if (step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.RemoveMarkStep) {\n          const newStart = mapping.slice(index).map(step.from, -1);\n          const newEnd = mapping.slice(index).map(step.to);\n          const oldStart = mapping.invert().map(newStart, -1);\n          const oldEnd = mapping.invert().map(newEnd);\n          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));\n          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));\n          this.editor.emit(\"delete\", {\n            type: \"mark\",\n            mark: step.mark,\n            from: step.from,\n            to: step.to,\n            deletedRange: {\n              from: oldStart,\n              to: oldEnd\n            },\n            newRange: {\n              from: newStart,\n              to: newEnd\n            },\n            partial: Boolean(foundAfterMark || foundBeforeMark),\n            editor: this.editor,\n            transaction,\n            combinedTransform: nextTransaction\n          });\n        }\n      });\n    };\n    if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {\n      setTimeout(callback, 0);\n    } else {\n      callback();\n    }\n  }\n});\n\n// src/extensions/drop.ts\n\nvar Drop = Extension.create({\n  name: \"drop\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapDrop\"),\n        props: {\n          handleDrop: (_, e, slice, moved) => {\n            this.editor.emit(\"drop\", {\n              editor: this.editor,\n              event: e,\n              slice,\n              moved\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/editable.ts\n\nvar Editable = Extension.create({\n  name: \"editable\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"editable\"),\n        props: {\n          editable: () => this.editor.options.editable\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/focusEvents.ts\n\nvar focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focusEvents\");\nvar FocusEvents = Extension.create({\n  name: \"focusEvents\",\n  addProseMirrorPlugins() {\n    const { editor } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: focusEventsPluginKey,\n        props: {\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true;\n              const transaction = editor.state.tr.setMeta(\"focus\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            },\n            blur: (view, event) => {\n              editor.isFocused = false;\n              const transaction = editor.state.tr.setMeta(\"blur\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            }\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/keymap.ts\n\nvar Keymap = Extension.create({\n  name: \"keymap\",\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr;\n        const { empty, $anchor } = selection;\n        const { pos, parent } = $anchor;\n        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n        const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n        const parentPos = $anchor.pos - $anchor.parentOffset;\n        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n        if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\") {\n          return false;\n        }\n        return commands.clearNodes();\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward()\n    ]);\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.deleteCurrentNode(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward()\n    ]);\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock()\n    ]);\n    const baseKeymap = {\n      Enter: handleEnter,\n      \"Mod-Enter\": () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      \"Mod-Backspace\": handleBackspace,\n      \"Shift-Backspace\": handleBackspace,\n      Delete: handleDelete,\n      \"Mod-Delete\": handleDelete,\n      \"Mod-a\": () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = {\n      ...baseKeymap\n    };\n    const macKeymap = {\n      ...baseKeymap,\n      \"Ctrl-h\": handleBackspace,\n      \"Alt-Backspace\": handleBackspace,\n      \"Ctrl-d\": handleDelete,\n      \"Ctrl-Alt-Backspace\": handleDelete,\n      \"Alt-Delete\": handleDelete,\n      \"Alt-d\": handleDelete,\n      \"Ctrl-a\": () => this.editor.commands.selectTextblockStart(),\n      \"Ctrl-e\": () => this.editor.commands.selectTextblockEnd()\n    };\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well\n      // with many other commands.\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clearDocument\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (transactions.some((tr2) => tr2.getMeta(\"composition\"))) {\n            return;\n          }\n          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n          const ignoreTr = transactions.some((transaction) => transaction.getMeta(\"preventClearDocument\"));\n          if (!docChanges || ignoreTr) {\n            return;\n          }\n          const { empty, from, to } = oldState.selection;\n          const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n          const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n          const allWasSelected = from === allFrom && to === allEnd;\n          if (empty || !allWasSelected) {\n            return;\n          }\n          const isEmpty = isNodeEmpty(newState.doc);\n          if (!isEmpty) {\n            return;\n          }\n          const tr = newState.tr;\n          const state = createChainableState({\n            state: newState,\n            transaction: tr\n          });\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state\n          });\n          commands.clearNodes();\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/paste.ts\n\nvar Paste = Extension.create({\n  name: \"paste\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapPaste\"),\n        props: {\n          handlePaste: (_view, e, slice) => {\n            this.editor.emit(\"paste\", {\n              editor: this.editor,\n              event: e,\n              slice\n            });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/extensions/tabindex.ts\n\nvar Tabindex = Extension.create({\n  name: \"tabindex\",\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tabindex\"),\n        props: {\n          attributes: () => this.editor.isEditable ? { tabindex: \"0\" } : {}\n        }\n      })\n    ];\n  }\n});\n\n// src/NodePos.ts\nvar NodePos = class _NodePos {\n  constructor(pos, editor, isBlock = false, node = null) {\n    this.currentNode = null;\n    this.actualDepth = null;\n    this.isBlock = isBlock;\n    this.resolvedPos = pos;\n    this.editor = editor;\n    this.currentNode = node;\n  }\n  get name() {\n    return this.node.type.name;\n  }\n  get node() {\n    return this.currentNode || this.resolvedPos.node();\n  }\n  get element() {\n    return this.editor.view.domAtPos(this.pos).node;\n  }\n  get depth() {\n    var _a;\n    return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;\n  }\n  get pos() {\n    return this.resolvedPos.pos;\n  }\n  get content() {\n    return this.node.content;\n  }\n  set content(content) {\n    let from = this.from;\n    let to = this.to;\n    if (this.isBlock) {\n      if (this.content.size === 0) {\n        console.error(`You can\\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n        return;\n      }\n      from = this.from + 1;\n      to = this.to - 1;\n    }\n    this.editor.commands.insertContentAt({ from, to }, content);\n  }\n  get attributes() {\n    return this.node.attrs;\n  }\n  get textContent() {\n    return this.node.textContent;\n  }\n  get size() {\n    return this.node.nodeSize;\n  }\n  get from() {\n    if (this.isBlock) {\n      return this.pos;\n    }\n    return this.resolvedPos.start(this.resolvedPos.depth);\n  }\n  get range() {\n    return {\n      from: this.from,\n      to: this.to\n    };\n  }\n  get to() {\n    if (this.isBlock) {\n      return this.pos + this.size;\n    }\n    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n  }\n  get parent() {\n    if (this.depth === 0) {\n      return null;\n    }\n    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n    const $pos = this.resolvedPos.doc.resolve(parentPos);\n    return new _NodePos($pos, this.editor);\n  }\n  get before() {\n    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.from - 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get after() {\n    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.to + 3);\n    }\n    return new _NodePos($pos, this.editor);\n  }\n  get children() {\n    const children = [];\n    this.node.content.forEach((node, offset) => {\n      const isBlock = node.isBlock && !node.isTextblock;\n      const isNonTextAtom = node.isAtom && !node.isText;\n      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n        return;\n      }\n      const $pos = this.resolvedPos.doc.resolve(targetPos);\n      if (!isBlock && $pos.depth <= this.depth) {\n        return;\n      }\n      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n      if (isBlock) {\n        childNodePos.actualDepth = this.depth + 1;\n      }\n      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n    });\n    return children;\n  }\n  get firstChild() {\n    return this.children[0] || null;\n  }\n  get lastChild() {\n    const children = this.children;\n    return children[children.length - 1] || null;\n  }\n  closest(selector, attributes = {}) {\n    let node = null;\n    let currentNode = this.parent;\n    while (currentNode && !node) {\n      if (currentNode.node.type.name === selector) {\n        if (Object.keys(attributes).length > 0) {\n          const nodeAttributes = currentNode.node.attrs;\n          const attrKeys = Object.keys(attributes);\n          for (let index = 0; index < attrKeys.length; index += 1) {\n            const key = attrKeys[index];\n            if (nodeAttributes[key] !== attributes[key]) {\n              break;\n            }\n          }\n        } else {\n          node = currentNode;\n        }\n      }\n      currentNode = currentNode.parent;\n    }\n    return node;\n  }\n  querySelector(selector, attributes = {}) {\n    return this.querySelectorAll(selector, attributes, true)[0] || null;\n  }\n  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n    let nodes = [];\n    if (!this.children || this.children.length === 0) {\n      return nodes;\n    }\n    const attrKeys = Object.keys(attributes);\n    this.children.forEach((childPos) => {\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      if (childPos.node.type.name === selector) {\n        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);\n        if (doesAllAttributesMatch) {\n          nodes.push(childPos);\n        }\n      }\n      if (firstItemOnly && nodes.length > 0) {\n        return;\n      }\n      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n    });\n    return nodes;\n  }\n  setAttribute(attributes) {\n    const { tr } = this.editor.state;\n    tr.setNodeMarkup(this.from, void 0, {\n      ...this.node.attrs,\n      ...attributes\n    });\n    this.editor.view.dispatch(tr);\n  }\n};\n\n// src/style.ts\nvar style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}`;\n\n// src/utilities/createStyleTag.ts\nfunction createStyleTag(style2, nonce, suffix) {\n  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag;\n  }\n  const styleNode = document.createElement(\"style\");\n  if (nonce) {\n    styleNode.setAttribute(\"nonce\", nonce);\n  }\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n  styleNode.innerHTML = style2;\n  document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n  return styleNode;\n}\n\n// src/Editor.ts\nvar Editor = class extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.css = null;\n    this.editorView = null;\n    this.isFocused = false;\n    /**\n     * The editor is considered initialized after the `create` event has been emitted.\n     */\n    this.isInitialized = false;\n    this.extensionStorage = {};\n    /**\n     * A unique ID for this editor instance.\n     */\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.options = {\n      element: typeof document !== \"undefined\" ? document.createElement(\"div\") : null,\n      content: \"\",\n      injectCSS: true,\n      injectNonce: void 0,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      coreExtensionOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      enableContentCheck: false,\n      emitContentError: false,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null,\n      onContentError: ({ error }) => {\n        throw error;\n      },\n      onPaste: () => null,\n      onDrop: () => null,\n      onDelete: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on(\"beforeCreate\", this.options.onBeforeCreate);\n    this.emit(\"beforeCreate\", { editor: this });\n    this.on(\"contentError\", this.options.onContentError);\n    this.on(\"create\", this.options.onCreate);\n    this.on(\"update\", this.options.onUpdate);\n    this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n    this.on(\"transaction\", this.options.onTransaction);\n    this.on(\"focus\", this.options.onFocus);\n    this.on(\"blur\", this.options.onBlur);\n    this.on(\"destroy\", this.options.onDestroy);\n    this.on(\"drop\", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));\n    this.on(\"paste\", ({ event, slice }) => this.options.onPaste(event, slice));\n    this.on(\"delete\", this.options.onDelete);\n    const initialDoc = this.createDoc();\n    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);\n    this.editorState = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n      doc: initialDoc,\n      schema: this.schema,\n      selection: selection || void 0\n    });\n    if (this.options.element) {\n      this.mount(this.options.element);\n    }\n  }\n  /**\n   * Attach the editor to the DOM, creating a new editor view.\n   */\n  mount(el) {\n    if (typeof document === \"undefined\") {\n      throw new Error(\n        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`\n      );\n    }\n    this.createView(el);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit(\"create\", { editor: this });\n      this.isInitialized = true;\n    }, 0);\n  }\n  /**\n   * Remove the editor from the DOM, but still allow remounting at a different point in time\n   */\n  unmount() {\n    var _a;\n    if (this.editorView) {\n      const dom = this.editorView.dom;\n      if (dom == null ? void 0 : dom.editor) {\n        delete dom.editor;\n      }\n      this.editorView.destroy();\n    }\n    this.editorView = null;\n    this.isInitialized = false;\n    (_a = this.css) == null ? void 0 : _a.remove();\n    this.css = null;\n  }\n  /**\n   * Returns the editor storage.\n   */\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\n   * An object of all registered commands.\n   */\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  can() {\n    return this.commandManager.can();\n  }\n  /**\n   * Inject CSS styles.\n   */\n  injectCSS() {\n    if (this.options.injectCSS && typeof document !== \"undefined\") {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  setOptions(options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (!this.editorView || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  /**\n   * Update editable state of the editor.\n   */\n  setEditable(editable, emitUpdate = true) {\n    this.setOptions({ editable });\n    if (emitUpdate) {\n      this.emit(\"update\", { editor: this, transaction: this.state.tr, appendedTransactions: [] });\n    }\n  }\n  /**\n   * Returns whether the editor is editable.\n   */\n  get isEditable() {\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\n   * Returns the editor state.\n   */\n  get view() {\n    if (this.editorView) {\n      return this.editorView;\n    }\n    return new Proxy(\n      {\n        state: this.editorState,\n        updateState: (state) => {\n          this.editorState = state;\n        },\n        dispatch: (tr) => {\n          this.editorState = this.state.apply(tr);\n        },\n        // Stub some commonly accessed properties to prevent errors\n        composing: false,\n        dragging: null,\n        editable: true,\n        isDestroyed: false\n      },\n      {\n        get: (obj, key) => {\n          if (key === \"state\") {\n            return this.editorState;\n          }\n          if (key in obj) {\n            return Reflect.get(obj, key);\n          }\n          throw new Error(\n            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`\n          );\n        }\n      }\n    );\n  }\n  /**\n   * Returns the editor state.\n   */\n  get state() {\n    if (this.editorView) {\n      this.editorState = this.view.state;\n    }\n    return this.editorState;\n  }\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   * @returns The new editor state\n   */\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({ plugins });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKeyToRemove The plugins name\n   * @returns The new editor state or undefined if the editor is destroyed\n   */\n  unregisterPlugin(nameOrPluginKeyToRemove) {\n    if (this.isDestroyed) {\n      return void 0;\n    }\n    const prevPlugins = this.state.plugins;\n    let plugins = prevPlugins;\n    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {\n      const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));\n    });\n    if (prevPlugins.length === plugins.length) {\n      return void 0;\n    }\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n    return state;\n  }\n  /**\n   * Creates an extension manager.\n   */\n  createExtensionManager() {\n    var _a, _b;\n    const coreExtensions = this.options.enableCoreExtensions ? [\n      Editable,\n      ClipboardTextSerializer.configure({\n        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator\n      }),\n      Commands,\n      FocusEvents,\n      Keymap,\n      Tabindex,\n      Drop,\n      Paste,\n      Delete\n    ].filter((ext) => {\n      if (typeof this.options.enableCoreExtensions === \"object\") {\n        return this.options.enableCoreExtensions[ext.name] !== false;\n      }\n      return true;\n    }) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {\n      return [\"extension\", \"node\", \"mark\"].includes(extension == null ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\n   * Creates an command manager.\n   */\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\n   * Creates a ProseMirror schema.\n   */\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\n   * Creates the initial document.\n   */\n  createDoc() {\n    let doc;\n    try {\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: this.options.enableContentCheck\n      });\n    } catch (e) {\n      if (!(e instanceof Error) || ![\"[tiptap error]: Invalid JSON content\", \"[tiptap error]: Invalid HTML content\"].includes(e.message)) {\n        throw e;\n      }\n      this.emit(\"contentError\", {\n        editor: this,\n        error: e,\n        disableCollaboration: () => {\n          if (\"collaboration\" in this.storage && typeof this.storage.collaboration === \"object\" && this.storage.collaboration) {\n            ;\n            this.storage.collaboration.isDisabled = true;\n          }\n          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== \"collaboration\");\n          this.createExtensionManager();\n        }\n      });\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: false\n      });\n    }\n    return doc;\n  }\n  /**\n   * Creates a ProseMirror view.\n   */\n  createView(element) {\n    var _a;\n    this.editorView = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(element, {\n      ...this.options.editorProps,\n      attributes: {\n        // add `role=\"textbox\"` to the editor element\n        role: \"textbox\",\n        ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes\n      },\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: this.editorState\n    });\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    this.prependClass();\n    this.injectCSS();\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\n   * Creates all node and mark views.\n   */\n  createNodeViews() {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    this.view.setProps({\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  /**\n   * Prepend class name to element.\n   */\n  prependClass() {\n    this.view.dom.className = `tiptap ${this.view.dom.className}`;\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  dispatchTransaction(transaction) {\n    if (this.view.isDestroyed) {\n      return;\n    }\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach((step) => {\n        var _a;\n        return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const { state, transactions } = this.state.applyTransaction(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    const rootTrWasApplied = transactions.includes(transaction);\n    const prevState = this.state;\n    this.emit(\"beforeTransaction\", {\n      editor: this,\n      transaction,\n      nextState: state\n    });\n    if (!rootTrWasApplied) {\n      return;\n    }\n    this.view.updateState(state);\n    this.emit(\"transaction\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n    if (selectionHasChanged) {\n      this.emit(\"selectionUpdate\", {\n        editor: this,\n        transaction\n      });\n    }\n    const mostRecentFocusTr = transactions.findLast((tr) => tr.getMeta(\"focus\") || tr.getMeta(\"blur\"));\n    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"focus\");\n    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta(\"blur\");\n    if (focus2) {\n      this.emit(\"focus\", {\n        editor: this,\n        event: focus2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (blur2) {\n      this.emit(\"blur\", {\n        editor: this,\n        event: blur2.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr\n      });\n    }\n    if (transaction.getMeta(\"preventUpdate\") || !transactions.some((tr) => tr.docChanged) || prevState.doc.eq(state.doc)) {\n      return;\n    }\n    this.emit(\"update\", {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1)\n    });\n  }\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\n   * Get the document as JSON.\n   */\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\n   * Get the document as HTML.\n   */\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\n   * Get the document as text.\n   */\n  getText(options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers\n      }\n    });\n  }\n  /**\n   * Check if there is no content.\n   */\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\n   * Destroy the editor.\n   */\n  destroy() {\n    this.emit(\"destroy\");\n    this.unmount();\n    this.removeAllListeners();\n  }\n  /**\n   * Check if the editor is already destroyed.\n   */\n  get isDestroyed() {\n    var _a, _b;\n    return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;\n  }\n  $node(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;\n  }\n  $nodes(selector, attributes) {\n    var _a;\n    return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n  }\n  $pos(pos) {\n    const $pos = this.state.doc.resolve(pos);\n    return new NodePos($pos, this);\n  }\n  get $doc() {\n    return this.$pos(0);\n  }\n};\n\n// src/inputRules/markInputRule.ts\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        const markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// src/inputRules/nodeInputRule.ts\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const { tr } = state;\n      const start = range.from;\n      let end = range.to;\n      const newNode = config.type.create(attributes);\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        tr.replaceWith(matchStart, end, newNode);\n      } else if (match[0]) {\n        const insertionStart = config.type.isInline ? start : start - 1;\n        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n      }\n      tr.scrollIntoView();\n    }\n  });\n}\n\n// src/inputRules/textblockTypeInputRule.ts\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n\n// src/inputRules/textInputRule.ts\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n// src/inputRules/wrappingInputRule.ts\n\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match, chain }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.findWrapping)(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state;\n        const { splittableMarks } = config.editor.extensionManager;\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (marks) {\n          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n          tr.ensureMarks(filteredMarks);\n        }\n      }\n      if (config.keepAttributes) {\n        const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n        chain().updateAttributes(nodeType, attributes).run();\n      }\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\n\n// src/jsx-runtime.ts\nfunction Fragment6(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n// src/utilities/canInsertNode.ts\n\nfunction canInsertNode(state, nodeType) {\n  const { selection } = state;\n  const { $from } = selection;\n  if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {\n    const index = $from.index();\n    const parent = $from.parent;\n    return parent.canReplaceWith(index, index + 1, nodeType);\n  }\n  let depth = $from.depth;\n  while (depth >= 0) {\n    const index = $from.index(depth);\n    const parent = $from.node(depth);\n    const match = parent.contentMatchAt(index);\n    if (match.matchType(nodeType)) {\n      return true;\n    }\n    depth -= 1;\n  }\n  return false;\n}\n\n// src/utilities/escapeForRegEx.ts\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n// src/utilities/isString.ts\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/MarkView.ts\nfunction updateMarkViewAttributes(checkMark, editor, attrs = {}) {\n  const { state } = editor;\n  const { doc, tr } = state;\n  const thisMark = checkMark;\n  doc.descendants((node, pos) => {\n    const from = tr.mapping.map(pos);\n    const to = tr.mapping.map(pos) + node.nodeSize;\n    let foundMark = null;\n    node.marks.forEach((mark) => {\n      if (mark !== thisMark) {\n        return false;\n      }\n      foundMark = mark;\n    });\n    if (!foundMark) {\n      return;\n    }\n    let needsUpdate = false;\n    Object.keys(attrs).forEach((k) => {\n      if (attrs[k] !== foundMark.attrs[k]) {\n        needsUpdate = true;\n      }\n    });\n    if (needsUpdate) {\n      const updatedMark = checkMark.type.create({\n        ...checkMark.attrs,\n        ...attrs\n      });\n      tr.removeMark(from, to, checkMark.type);\n      tr.addMark(from, to, updatedMark);\n    }\n  });\n  if (tr.docChanged) {\n    editor.view.dispatch(tr);\n  }\n}\nvar MarkView = class {\n  constructor(component, props, options) {\n    this.component = component;\n    this.editor = props.editor;\n    this.options = { ...options };\n    this.mark = props.mark;\n    this.HTMLAttributes = props.HTMLAttributes;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  /**\n   * Update the attributes of the mark in the document.\n   * @param attrs The attributes to update.\n   */\n  updateAttributes(attrs, checkMark) {\n    updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/Node.ts\nvar Node3 = class _Node extends Extendable {\n  constructor() {\n    super(...arguments);\n    this.type = \"node\";\n  }\n  /**\n   * Create a new Node instance\n   * @param config - Node configuration object or a function that returns a configuration object\n   */\n  static create(config = {}) {\n    const resolvedConfig = typeof config === \"function\" ? config() : config;\n    return new _Node(resolvedConfig);\n  }\n  configure(options) {\n    return super.configure(options);\n  }\n  extend(extendedConfig) {\n    const resolvedConfig = typeof extendedConfig === \"function\" ? extendedConfig() : extendedConfig;\n    return super.extend(resolvedConfig);\n  }\n};\n\n// src/NodeView.ts\n\nvar NodeView = class {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.innerDecorations = props.innerDecorations;\n    this.view = props.view;\n    this.HTMLAttributes = props.HTMLAttributes;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { view } = this.editor;\n    const target = event.target;\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) == null ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n    if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;\n      const offsetY = (_f = event.offsetY) != null ? _f : (_e = event.nativeEvent) == null ? void 0 : _e.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    const clonedNode = this.dom.cloneNode(true);\n    (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x, y);\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, pos);\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === \"function\") {\n      return this.options.stopEvent({ event });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) == null ? void 0 : _a.contains(target));\n    if (!isInElement) {\n      return false;\n    }\n    const isDragEvent = event.type.startsWith(\"drag\");\n    const isDropEvent = event.type === \"drop\";\n    const isInput = [\"INPUT\", \"BUTTON\", \"SELECT\", \"TEXTAREA\"].includes(target.tagName) || target.isContentEditable;\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true;\n    }\n    const { isEditable } = this.editor;\n    const { isDragging } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === \"copy\";\n    const isPasteEvent = event.type === \"paste\";\n    const isCutEvent = event.type === \"cut\";\n    const isClickEvent = event.type === \"mousedown\";\n    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n      event.preventDefault();\n      return false;\n    }\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest(\"[data-drag-handle]\");\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener(\n          \"dragend\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"drop\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n        document.addEventListener(\n          \"mouseup\",\n          () => {\n            this.isDragging = false;\n          },\n          { once: true }\n        );\n      }\n    }\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n   * @return `true` if it can safely be ignored.\n   */\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Update the attributes of the prosemirror node.\n   */\n  updateAttributes(attributes) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos();\n      if (typeof pos !== \"number\") {\n        return false;\n      }\n      tr.setNodeMarkup(pos, void 0, {\n        ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n  /**\n   * Delete the node.\n   */\n  deleteNode() {\n    const from = this.getPos();\n    if (typeof from !== \"number\") {\n      return;\n    }\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({ from, to });\n  }\n};\n\n// src/pasteRules/markPasteRule.ts\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match, pasteEvent }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n\n// src/pasteRules/nodePasteRule.ts\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range, pasteEvent }) {\n      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);\n      const content = callOrReturn(config.getContent, void 0, attributes);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const node = { type: config.type.name, attrs: attributes };\n      if (content) {\n        node.content = content;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, node);\n      }\n    }\n  });\n}\n\n// src/pasteRules/textPasteRule.ts\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\n// src/Tracker.ts\nvar Tracker = class {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CLFFBQVEsWUFBWTtBQUNwQixRQUFRLE1BQU07QUFDZCxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksT0FBTztBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVE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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsSUFBSTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0dFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanM/Yzc0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnKSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWc7XG4gIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb247XG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvbjtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcbiAgICBwbHVnaW5zOiBzdGF0ZS5wbHVnaW5zLFxuICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcbiAgICB0b0pTT046IHN0YXRlLnRvSlNPTi5iaW5kKHN0YXRlKSxcbiAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICByZXR1cm4gc3RvcmVkTWFya3M7XG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9LFxuICAgIGdldCBkb2MoKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG4gICAgZ2V0IHRyKCkge1xuICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9Db21tYW5kTWFuYWdlci50c1xudmFyIENvbW1hbmRNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xuICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgfVxuICBnZXQgaGFzQ3VzdG9tU3RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGU7XG4gIH1cbiAgZ2V0IGNvbW1hbmRzKCkge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kMiguLi5hcmdzKShwcm9wcyk7XG4gICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKFwicHJldmVudERpc3BhdGNoXCIpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF07XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IGNoYWluKCkge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKCk7XG4gIH1cbiAgZ2V0IGNhbigpIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKTtcbiAgfVxuICBjcmVhdGVDaGFpbihzdGFydFRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgIGNvbnN0IHJ1bjMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWhhc1N0YXJ0VHJhbnNhY3Rpb24gJiYgc2hvdWxkRGlzcGF0Y2ggJiYgIXRyLmdldE1ldGEoXCJwcmV2ZW50RGlzcGF0Y2hcIikgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KChjYWxsYmFjaykgPT4gY2FsbGJhY2sgPT09IHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFpbmVkQ29tbWFuZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kMiguLi5hcmdzKShwcm9wcyk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBydW46IHJ1bjNcbiAgICB9O1xuICAgIHJldHVybiBjaGFpbjtcbiAgfVxuICBjcmVhdGVDYW4oc3RhcnRUcikge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2U7XG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaCk7XG4gICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQyKC4uLmFyZ3MpKHsgLi4ucHJvcHMsIGRpc3BhdGNoOiB2b2lkIDAgfSldO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXR0ZWRDb21tYW5kcyxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaClcbiAgICB9O1xuICB9XG4gIGJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICB0cixcbiAgICAgIGVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgICB9KSxcbiAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHZvaWQgMCA6IHZvaWQgMCxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZDJdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzKSA9PiBjb21tYW5kMiguLi5hcmdzKShwcm9wcyldO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbn07XG5cbi8vIHNyYy9FZGl0b3IudHNcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG5cbi8vIHNyYy9FdmVudEVtaXR0ZXIudHNcbnZhciBFdmVudEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIH1cbiAgb24oZXZlbnQsIGZuKSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcigoY2FsbGJhY2spID0+IGNhbGxiYWNrICE9PSBmbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbmNlKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLm9mZihldmVudCwgb25jZUZuKTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIG9uY2VGbik7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIH1cbn07XG5cbi8vIHNyYy9FeHRlbnNpb25NYW5hZ2VyLnRzXG5pbXBvcnQgeyBrZXltYXAgfSBmcm9tIFwiQHRpcHRhcC9wbS9rZXltYXBcIjtcblxuLy8gc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHNcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkRG9jLCB0cmFuc2FjdGlvbnMpIHtcbiAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICB0cmFuc2Zvcm0uc3RlcChzdGVwKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8vIHNyYy9oZWxwZXJzL2NyZWF0ZU5vZGVGcm9tQ29udGVudC50c1xuaW1wb3J0IHsgRE9NUGFyc2VyLCBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcudHNcbnZhciByZW1vdmVXaGl0ZXNwYWNlcyA9IChub2RlKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5ub2RlVmFsdWUgJiYgL14oXFxuXFxzXFxzfFxcbikkLy50ZXN0KGNoaWxkLm5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJlbW92ZVdoaXRlc3BhY2VzKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbdGlwdGFwIGVycm9yXTogdGhlcmUgaXMgbm8gd2luZG93IG9iamVjdCBhdmFpbGFibGUsIHNvIHRoaXMgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWRcIik7XG4gIH1cbiAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XG4gIGNvbnN0IGh0bWwgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkVmFsdWUsIFwidGV4dC9odG1sXCIpLmJvZHk7XG4gIHJldHVybiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgUHJvc2VNaXJyb3JOb2RlIHx8IGNvbnRlbnQgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIG9wdGlvbnMgPSB7XG4gICAgc2xpY2U6IHRydWUsXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGlzSlNPTkNvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gXCJvYmplY3RcIiAmJiBjb250ZW50ICE9PSBudWxsO1xuICBjb25zdCBpc1RleHRDb250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCI7XG4gIGlmIChpc0pTT05Db250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzQXJyYXlDb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDA7XG4gICAgICBpZiAoaXNBcnJheUNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShjb250ZW50Lm1hcCgoaXRlbSkgPT4gc2NoZW1hLm5vZGVGcm9tSlNPTihpdGVtKSkpO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudCk7XG4gICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgbm9kZS5jaGVjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnRcIiwgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuXCIsIFwiUGFzc2VkIHZhbHVlOlwiLCBjb250ZW50LCBcIkVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KFwiXCIsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1RleHRDb250ZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICBsZXQgaGFzSW52YWxpZENvbnRlbnQgPSBmYWxzZTtcbiAgICAgIGxldCBpbnZhbGlkQ29udGVudCA9IFwiXCI7XG4gICAgICBjb25zdCBjb250ZW50Q2hlY2tTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICAgICAgdG9wTm9kZTogc2NoZW1hLnNwZWMudG9wTm9kZSxcbiAgICAgICAgbWFya3M6IHNjaGVtYS5zcGVjLm1hcmtzLFxuICAgICAgICAvLyBQcm9zZW1pcnJvcidzIHNjaGVtYXMgYXJlIGV4ZWN1dGVkIHN1Y2ggdGhhdDogdGhlIGxhc3QgdG8gZXhlY3V0ZSwgbWF0Y2hlcyBsYXN0XG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gYWRkIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZW1hIHRvIGNhdGNoIGFueSBjb250ZW50IHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgIG5vZGVzOiBzY2hlbWEuc3BlYy5ub2Rlcy5hcHBlbmQoe1xuICAgICAgICAgIF9fdGlwdGFwX19wcml2YXRlX191bmtub3duX19jYXRjaF9fYWxsX19ub2RlOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcImlubGluZSpcIixcbiAgICAgICAgICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiBcIipcIixcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGhhc0ludmFsaWRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGludmFsaWRDb250ZW50ID0gdHlwZW9mIGUgPT09IFwic3RyaW5nXCIgPyBlIDogZS5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmIChvcHRpb25zLnNsaWNlKSB7XG4gICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50ICYmIGhhc0ludmFsaWRDb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEhUTUwgY29udGVudFwiLCB7XG4gICAgICAgICAgY2F1c2U6IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGZvdW5kOiAke2ludmFsaWRDb250ZW50fWApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgIGlmIChvcHRpb25zLnNsaWNlKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChcIlwiLCBzY2hlbWEsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvaGVscGVycy9jcmVhdGVEb2N1bWVudC50c1xuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgc2NoZW1hLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCB7XG4gICAgc2xpY2U6IGZhbHNlLFxuICAgIHBhcnNlT3B0aW9ucyxcbiAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50c1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuLnRzXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLmRlc2NlbmRhbnRzKChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5vZGVzV2l0aFBvcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmluZENoaWxkcmVuSW5SYW5nZS50c1xuZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShub2RlLCByYW5nZSwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXNXaXRoUG9zO1xufVxuXG4vLyBzcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50c1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJHBvcywgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIG5vZGVcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIChzZWxlY3Rpb24pID0+IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKHNlbGVjdGlvbi4kZnJvbSwgcHJlZGljYXRlKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHNcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB2b2lkIDAgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnQgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCkgOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZmxhdHRlbkV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGZsYXR0ZW5FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlXG4gICAgfTtcbiAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZEV4dGVuc2lvbnNcIiwgY29udGV4dCk7XG4gICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi5mbGF0dGVuRXh0ZW5zaW9ucyhhZGRFeHRlbnNpb25zKCkpXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgfSkuZmxhdCgxMCk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHNcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudCwgc2NoZW1hKSB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCk7XG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLnRzXG5pbXBvcnQgeyBTY2hlbWEgYXMgU2NoZW1hMiB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNGdW5jdGlvbi50c1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLnRzXG5mdW5jdGlvbiBjYWxsT3JSZXR1cm4odmFsdWUsIGNvbnRleHQgPSB2b2lkIDAsIC4uLnByb3BzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QudHNcbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vLyBzcmMvaGVscGVycy9zcGxpdEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwiZXh0ZW5zaW9uXCIpO1xuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi50eXBlID09PSBcIm5vZGVcIik7XG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9uc1xuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBbXTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGUgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICB2YWxpZGF0ZTogdm9pZCAwLFxuICAgIHJlbmRlcmVkOiB0cnVlLFxuICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgcGFyc2VIVE1MOiBudWxsLFxuICAgIGtlZXBPblNwbGl0OiB0cnVlLFxuICAgIGlzUmVxdWlyZWQ6IGZhbHNlXG4gIH07XG4gIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgIGV4dGVuc2lvbnM6IG5vZGVBbmRNYXJrRXh0ZW5zaW9uc1xuICAgIH07XG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgXCJhZGRHbG9iYWxBdHRyaWJ1dGVzXCIsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICBpZiAoIWFkZEdsb2JhbEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKTtcbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goKGdsb2JhbEF0dHJpYnV0ZSkgPT4ge1xuICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goKGV4dGVuc2lvbikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgIFwiYWRkQXR0cmlidXRlc1wiLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgIC4uLmF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgKG1lcmdlZEF0dHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5pc1JlcXVpcmVkKSAmJiAobWVyZ2VkQXR0ciA9PSBudWxsID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXMgPSB2YWx1ZSA/IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3NlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoKHZhbHVlQ2xhc3MpID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbLi4uZXhpc3RpbmdDbGFzc2VzLCAuLi5pbnNlcnRDbGFzc2VzXS5qb2luKFwiIFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgY29uc3QgbmV3U3R5bGVzID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBleGlzdGluZ1N0eWxlcyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdChcIjtcIikubWFwKChzdHlsZTIpID0+IHN0eWxlMi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGV4aXN0aW5nU3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3U3R5bGVzLmZvckVhY2goKHN0eWxlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlMi5zcGxpdChcIjpcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oXCI7IFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldFJlbmRlcmVkQXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBub2RlT3JNYXJrLnR5cGUubmFtZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZCkubWFwKChpdGVtKSA9PiB7XG4gICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fTtcbiAgfSkucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSk7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvZnJvbVN0cmluZy50c1xuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS50c1xuZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICBpZiAoXCJzdHlsZVwiIGluIHBhcnNlUnVsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzO1xuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSkgOiBmcm9tU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtKGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiYXR0cnNcIiAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMDtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgdG9wTm9kZSA9IChfYSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoKGV4dGVuc2lvbikgPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcInRvcE5vZGVcIikpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZTtcbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9O1xuICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQoZSwgXCJleHRlbmROb2RlU2NoZW1hXCIsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi5leHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge31cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvbnRlbnRcIiwgY29udGV4dCkpLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJtYXJrc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImlubGluZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYXRvbVwiLCBjb250ZXh0KSksXG4gICAgICAgIHNlbGVjdGFibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic2VsZWN0YWJsZVwiLCBjb250ZXh0KSksXG4gICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkcmFnZ2FibGVcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICB3aGl0ZXNwYWNlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIndoaXRlc3BhY2VcIiwgY29udGV4dCkpLFxuICAgICAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJsaW5lYnJlYWtSZXBsYWNlbWVudFwiLCBjb250ZXh0KVxuICAgICAgICApLFxuICAgICAgICBkZWZpbmluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJkZWZpbmluZ1wiLCBjb250ZXh0KSksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpc29sYXRpbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKChleHRlbnNpb25BdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICAgIHsgZGVmYXVsdDogKF9hMiA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWZhdWx0LCB2YWxpZGF0ZTogKF9iID0gZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsaWRhdGUgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG5vZGUpID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicmVuZGVyVGV4dFwiLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZW5kZXJUZXh0KSB7XG4gICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KVxuICApO1xuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3JcbiAgICAgIH07XG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCBcImV4dGVuZE1hcmtTY2hlbWFcIiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLmV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fVxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXG4gICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJpbmNsdXNpdmVcIiwgY29udGV4dCkpLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJleGNsdWRlc1wiLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImdyb3VwXCIsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwic3Bhbm5pbmdcIiwgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImNvZGVcIiwgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKChleHRlbnNpb25BdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICAgIHsgZGVmYXVsdDogKF9hMiA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PSBudWxsID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5kZWZhdWx0LCB2YWxpZGF0ZTogKF9iID0gZXh0ZW5zaW9uQXR0cmlidXRlID09IG51bGwgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsaWRhdGUgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwicGFyc2VIVE1MXCIsIGNvbnRleHQpKTtcbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChcbiAgICAgICAgICAocGFyc2VSdWxlKSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJyZW5kZXJIVE1MXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gKG1hcmspID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEyKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtcykge1xuICBjb25zdCBmaWx0ZXJlZCA9IGl0ZW1zLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpdGVtcy5pbmRleE9mKGVsKSAhPT0gaW5kZXgpO1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3NvcnRFeHRlbnNpb25zLnRzXG5mdW5jdGlvbiBzb3J0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkKGEsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkKGIsIFwicHJpb3JpdHlcIikgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5QSA8IHByaW9yaXR5Qikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcmVzb2x2ZUV4dGVuc2lvbnMudHNcbmZ1bmN0aW9uIHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoZmxhdHRlbkV4dGVuc2lvbnMoZXh0ZW5zaW9ucykpO1xuICBjb25zdCBkdXBsaWNhdGVkTmFtZXMgPSBmaW5kRHVwbGljYXRlcyhyZXNvbHZlZEV4dGVuc2lvbnMubWFwKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lKSk7XG4gIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lcy5tYXAoKGl0ZW0pID0+IGAnJHtpdGVtfSdgKS5qb2luKFwiLCBcIil9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkRXh0ZW5zaW9ucztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hLnRzXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUhUTUwudHNcbmZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2MsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZUpTT04udHNcbmltcG9ydCB7IERPTVBhcnNlciBhcyBET01QYXJzZXIyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sLCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbCk7XG4gIHJldHVybiBET01QYXJzZXIyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHNcbmltcG9ydCB7IE5vZGUgYXMgTm9kZTIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0QmV0d2Vlbi50c1xuZnVuY3Rpb24gZ2V0VGV4dEJldHdlZW4oc3RhcnROb2RlLCByYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9IFwiXFxuXFxuXCIsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHN0YXJ0Tm9kZS5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5vZGUuaXNCbG9jayAmJiBwb3MgPiBmcm9tKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PSBudWxsID8gdm9pZCAwIDogdGV4dFNlcmlhbGl6ZXJzW25vZGUudHlwZS5uYW1lXTtcbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRUZXh0LnRzXG5mdW5jdGlvbiBnZXRUZXh0KG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemVcbiAgfTtcbiAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS50c1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEubm9kZXMpLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpLm1hcCgoW25hbWUsIG5vZGVdKSA9PiBbbmFtZSwgbm9kZS5zcGVjLnRvVGV4dF0pXG4gICk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dlbmVyYXRlVGV4dC50c1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KGRvYywgZXh0ZW5zaW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gXCJcXG5cXG5cIiwgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlMi5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSksXG4gICAgICAuLi50ZXh0U2VyaWFsaXplcnNcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRNYXJrVHlwZS50c1xuZnVuY3Rpb24gZ2V0TWFya1R5cGUobmFtZU9yVHlwZSwgc2NoZW1hKSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXTtcbiAgfVxuICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBtYXJrcyA9IFtdO1xuICBpZiAoZW1wdHkpIHtcbiAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xuICAgIH1cbiAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSkgPT4ge1xuICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYXJrID0gbWFya3MuZmluZCgobWFya0l0ZW0pID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKTtcbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZVR5cGUudHNcbmZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV07XG4gIH1cbiAgcmV0dXJuIG5hbWVPclR5cGU7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE5vZGVBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZTIpID0+IHtcbiAgICBub2Rlcy5wdXNoKG5vZGUyKTtcbiAgfSk7XG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZCgobm9kZUl0ZW0pID0+IG5vZGVJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHNcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9XG4gIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICByZXR1cm4gXCJtYXJrXCI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSBcInN0cmluZ1wiID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWFcbiAgKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xuICB9XG4gIHJldHVybiB7fTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLnRzXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycmF5LCBieSA9IEpTT04uc3RyaW5naWZ5KSB7XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KSA/IGZhbHNlIDogc2VlbltrZXldID0gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldENoYW5nZWRSYW5nZXMudHNcbmZ1bmN0aW9uIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKSB7XG4gIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpO1xuICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDEgPyB1bmlxdWVDaGFuZ2VzIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByZXN0ID0gdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gIXJlc3Quc29tZSgob3RoZXJDaGFuZ2UpID0+IHtcbiAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50byAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSkge1xuICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm07XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgIGlmIChmcm9tID09PSB2b2lkIDAgfHwgdG8gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpO1xuICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKTtcbiAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgIHRvOiBvbGRFbmRcbiAgICAgICAgfSxcbiAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcbiAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzXG5mdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZSwgc3RhcnRPZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDE7XG4gIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldDtcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcCgobWFyaykgPT4ge1xuICAgIGNvbnN0IG91dHB1dDIgPSB7XG4gICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZVxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0Mi5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0MjtcbiAgfSk7XG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH07XG4gIGNvbnN0IG91dHB1dCA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICBmcm9tLFxuICAgIHRvXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gIH1cbiAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgIG91dHB1dC5tYXJrcyA9IG1hcmtzO1xuICB9XG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW107XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBvdXRwdXQuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzUmVnRXhwLnRzXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy50c1xuZnVuY3Rpb24gb2JqZWN0SW5jbHVkZXMob2JqZWN0MSwgb2JqZWN0Miwgb3B0aW9ucyA9IHsgc3RyaWN0OiB0cnVlIH0pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGtleXMuZXZlcnkoKGtleSkgPT4ge1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAob2JqZWN0MltrZXldKSkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XS50ZXN0KG9iamVjdDFba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XTtcbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2dldE1hcmtSYW5nZS50c1xuZnVuY3Rpb24gZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIHJldHVybiBtYXJrcy5maW5kKChpdGVtKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZSAmJiBvYmplY3RJbmNsdWRlcyhcbiAgICAgIC8vIE9ubHkgY2hlY2sgZXF1YWxpdHkgZm9yIHRoZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHByb3ZpZGVkXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKChrKSA9PiBbaywgaXRlbS5hdHRyc1trXV0pKSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgcmV0dXJuICEhZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyk7XG59XG5mdW5jdGlvbiBnZXRNYXJrUmFuZ2UoJHBvcywgdHlwZSwgYXR0cmlidXRlcykge1xuICB2YXIgX2E7XG4gIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KTtcbiAgaWYgKCFzdGFydC5ub2RlIHx8ICFzdGFydC5ub2RlLm1hcmtzLnNvbWUoKG1hcmsyKSA9PiBtYXJrMi50eXBlID09PSB0eXBlKSkge1xuICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICB9XG4gIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKChtYXJrMikgPT4gbWFyazIudHlwZSA9PT0gdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgKChfYSA9IHN0YXJ0Lm5vZGUubWFya3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRycyk7XG4gIGNvbnN0IG1hcmsgPSBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gIGlmICghbWFyaykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmluZGV4O1xuICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXQ7XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxO1xuICBsZXQgZW5kUG9zID0gc3RhcnRQb3MgKyBzdGFydC5ub2RlLm5vZGVTaXplO1xuICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XG4gICAgc3RhcnRJbmRleCAtPSAxO1xuICAgIHN0YXJ0UG9zIC09ICRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpLm5vZGVTaXplO1xuICB9XG4gIHdoaWxlIChlbmRJbmRleCA8ICRwb3MucGFyZW50LmNoaWxkQ291bnQgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XG4gICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZTtcbiAgICBlbmRJbmRleCArPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgZnJvbTogc3RhcnRQb3MsXG4gICAgdG86IGVuZFBvc1xuICB9O1xufVxuXG4vLyBzcmMvaGVscGVycy9nZXRNYXJrc0JldHdlZW4udHNcbmZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tLCB0bywgZG9jKSB7XG4gIGNvbnN0IG1hcmtzID0gW107XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIGRvYy5yZXNvbHZlKGZyb20pLm1hcmtzKCkuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG1hcmssXG4gICAgICAgIC4uLnJhbmdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUubm9kZVNpemUpID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgIG1hcmtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXJrcztcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHNcbnZhciBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZSwgdHlwZU9yTmFtZSwgcG9zLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGg7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgaWYgKChjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUudHlwZS5uYW1lKSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdO1xufTtcblxuLy8gc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50c1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgdHlwZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5maW5kKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXQ7XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMudHNcbnZhciBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSBcIlwiO1xuICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldDtcbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICBub2RlLFxuICAgICAgcG9zLFxuICAgICAgcGFyZW50LFxuICAgICAgaW5kZXhcbiAgICB9KSkgfHwgbm9kZS50ZXh0Q29udGVudCB8fCBcIiVsZWFmJVwiO1xuICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICB9KTtcbiAgcmV0dXJuIHRleHRCZWZvcmU7XG59O1xuXG4vLyBzcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHNcbmZ1bmN0aW9uIGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWU7XG4gICAgfSkuZmluZCgobWFyaykgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgfVxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwO1xuICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgY29uc3QgdG8gPSAkdG8ucG9zO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgY29uc3QgcmFuZ2UyID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlMjtcbiAgICAgIG1hcmtSYW5nZXMucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAoKG1hcmspID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG9cbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXMuZmlsdGVyKChtYXJrUmFuZ2UpID0+IHtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gIH0pLmZpbHRlcigobWFya1JhbmdlKSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKS5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XG4gIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzLmZpbHRlcigobWFya1JhbmdlKSA9PiB7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKTtcbiAgfSkucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlO1xuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50c1xuZnVuY3Rpb24gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbDtcbiAgY29uc3Qgbm9kZVJhbmdlcyA9IFtdO1xuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICBub2RlUmFuZ2VzLnB1c2goe1xuICAgICAgbm9kZSxcbiAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgIHRvOiByZWxhdGl2ZVRvXG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbTtcbiAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzLmZpbHRlcigobm9kZVJhbmdlKSA9PiB7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbm9kZVJhbmdlLm5vZGUudHlwZS5uYW1lO1xuICB9KS5maWx0ZXIoKG5vZGVSYW5nZSkgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSk7XG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aDtcbiAgfVxuICBjb25zdCByYW5nZSA9IG1hdGNoZWROb2RlUmFuZ2VzLnJlZHVjZSgoc3VtLCBub2RlUmFuZ2UpID0+IHN1bSArIG5vZGVSYW5nZS50byAtIG5vZGVSYW5nZS5mcm9tLCAwKTtcbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc0FjdGl2ZS50c1xuZnVuY3Rpb24gaXNBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKSB8fCBpc01hcmtBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJtYXJrXCIpIHtcbiAgICByZXR1cm4gaXNNYXJrQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHNcbnZhciBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlLCBub2RlVHlwZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpO1xuICAgIGlmICgkYW5jaG9yLnBvcyArIDEgPT09ICRwYXJlbnRQb3MuZW5kKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHNcbnZhciBpc0F0U3RhcnRPZk5vZGUgPSAoc3RhdGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLnRzXG5mdW5jdGlvbiBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVuYWJsZWQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICByZXR1cm4gZW5hYmxlZC5zb21lKChlbmFibGVkRXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGVuYWJsZWRFeHRlbnNpb24gPT09IFwic3RyaW5nXCIgPyBlbmFibGVkRXh0ZW5zaW9uIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lO1xuICAgICAgcmV0dXJuIG5hbWUgPT09IGV4dGVuc2lvbi5uYW1lO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmFibGVkO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc0xpc3QudHNcbmZ1bmN0aW9uIGlzTGlzdChuYW1lLCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgY29uc3QgZXh0ZW5zaW9uID0gbm9kZUV4dGVuc2lvbnMuZmluZCgoaXRlbSkgPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZVxuICB9O1xuICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiZ3JvdXBcIiwgY29udGV4dCkpO1xuICBpZiAodHlwZW9mIGdyb3VwICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBncm91cC5zcGxpdChcIiBcIikuaW5jbHVkZXMoXCJsaXN0XCIpO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc05vZGVFbXB0eS50c1xuZnVuY3Rpb24gaXNOb2RlRW1wdHkobm9kZSwge1xuICBjaGVja0NoaWxkcmVuID0gdHJ1ZSxcbiAgaWdub3JlV2hpdGVzcGFjZSA9IGZhbHNlXG59ID0ge30pIHtcbiAgdmFyIF9hO1xuICBpZiAoaWdub3JlV2hpdGVzcGFjZSkge1xuICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gXCJoYXJkQnJlYWtcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuIC9eXFxzKiQvbS50ZXN0KChfYSA9IG5vZGUudGV4dCkgIT0gbnVsbCA/IF9hIDogXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLmlzVGV4dCkge1xuICAgIHJldHVybiAhbm9kZS50ZXh0O1xuICB9XG4gIGlmIChub2RlLmlzQXRvbSB8fCBub2RlLmlzTGVhZikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2hlY2tDaGlsZHJlbikge1xuICAgIGxldCBpc0NvbnRlbnRFbXB0eSA9IHRydWU7XG4gICAgbm9kZS5jb250ZW50LmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgaWYgKGlzQ29udGVudEVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzTm9kZUVtcHR5KGNoaWxkTm9kZSwgeyBpZ25vcmVXaGl0ZXNwYWNlLCBjaGVja0NoaWxkcmVuIH0pKSB7XG4gICAgICAgIGlzQ29udGVudEVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ29udGVudEVtcHR5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvaXNOb2RlU2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uO1xufVxuXG4vLyBzcmMvaGVscGVycy9pc1RleHRTZWxlY3Rpb24udHNcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb247XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvbWluTWF4LnRzXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvcG9zVG9ET01SZWN0LnRzXG5mdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pIHtcbiAgY29uc3QgbWluUG9zID0gMDtcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKTtcbiAgY29uc3QgZW5kID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEVuZCwgLTEpO1xuICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApO1xuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pO1xuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpO1xuICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB4ID0gbGVmdDtcbiAgY29uc3QgeSA9IHRvcDtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgdG9KU09OOiAoKSA9PiBkYXRhXG4gIH07XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLnRzXG5pbXBvcnQgeyBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCBwb3NpdGlvbiA9IG51bGwpIHtcbiAgaWYgKCFwb3NpdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpO1xuICBjb25zdCBzZWxlY3Rpb25BdEVuZCA9IFNlbGVjdGlvbi5hdEVuZChkb2MpO1xuICBpZiAocG9zaXRpb24gPT09IFwic3RhcnRcIiB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0O1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZDtcbiAgfVxuICBjb25zdCBtaW5Qb3MgPSBzZWxlY3Rpb25BdFN0YXJ0LmZyb207XG4gIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvO1xuICBpZiAocG9zaXRpb24gPT09IFwiYWxsXCIpIHtcbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbjIuY3JlYXRlKGRvYywgbWluTWF4KDAsIG1pblBvcywgbWF4UG9zKSwgbWluTWF4KGRvYy5jb250ZW50LnNpemUsIG1pblBvcywgbWF4UG9zKSk7XG4gIH1cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb24yLmNyZWF0ZShkb2MsIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Jld3JpdGVVbmtub3duQ29udGVudC50c1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICBqc29uLFxuICB2YWxpZE1hcmtzLFxuICB2YWxpZE5vZGVzLFxuICBvcHRpb25zLFxuICByZXdyaXR0ZW5Db250ZW50ID0gW11cbn0pIHtcbiAgaWYgKGpzb24ubWFya3MgJiYgQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSkge1xuICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcigobWFyaykgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBtYXJrID09PSBcInN0cmluZ1wiID8gbWFyayA6IG1hcmsudHlwZTtcbiAgICAgIGlmICh2YWxpZE1hcmtzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcmspKSxcbiAgICAgICAgdW5zdXBwb3J0ZWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpKSB7XG4gICAganNvbi5jb250ZW50ID0ganNvbi5jb250ZW50Lm1hcChcbiAgICAgICh2YWx1ZSkgPT4gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICAgICAgICBqc29uOiB2YWx1ZSxcbiAgICAgICAgdmFsaWRNYXJrcyxcbiAgICAgICAgdmFsaWROb2RlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgICAgfSkuanNvblxuICAgICkuZmlsdGVyKChhKSA9PiBhICE9PSBudWxsICYmIGEgIT09IHZvaWQgMCk7XG4gIH1cbiAgaWYgKGpzb24udHlwZSAmJiAhdmFsaWROb2Rlcy5oYXMoanNvbi50eXBlKSkge1xuICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqc29uKSksXG4gICAgICB1bnN1cHBvcnRlZDoganNvbi50eXBlXG4gICAgfSk7XG4gICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkgJiYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tUb1BhcmFncmFwaCkgIT09IGZhbHNlKSB7XG4gICAgICBqc29uLnR5cGUgPSBcInBhcmFncmFwaFwiO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbixcbiAgICAgICAgcmV3cml0dGVuQ29udGVudFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpzb246IG51bGwsXG4gICAgICByZXdyaXR0ZW5Db250ZW50XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBqc29uLCByZXdyaXR0ZW5Db250ZW50IH07XG59XG5mdW5jdGlvbiByZXdyaXRlVW5rbm93bkNvbnRlbnQoanNvbiwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAganNvbixcbiAgICB2YWxpZE5vZGVzOiBuZXcgU2V0KE9iamVjdC5rZXlzKHNjaGVtYS5ub2RlcykpLFxuICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgb3B0aW9uc1xuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQudHNcbmltcG9ydCB7IFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gIGNvbnN0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdO1xuICBsZXQgZW5kID0gMDtcbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvO1xuICAgIH1cbiAgfSk7XG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24yLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG4vLyBzcmMvSW5wdXRSdWxlLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDIgfSBmcm9tIFwiQHRpcHRhcC9wbS9tb2RlbFwiO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBJbnB1dFJ1bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyO1xuICB9XG59O1xudmFyIGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyID0gKHRleHQsIGZpbmQpID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KTtcbiAgfVxuICBjb25zdCBpbnB1dFJ1bGVNYXRjaCA9IGZpbmQodGV4dCk7XG4gIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF07XG4gIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4O1xuICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xuICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGE7XG4gIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcnVuKGNvbmZpZykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiB9ID0gY29uZmlnO1xuICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0ICRmcm9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgICEhKChfYSA9ICRmcm9tLm5vZGVCZWZvcmUgfHwgJGZyb20ubm9kZUFmdGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya3MuZmluZCgobWFyaykgPT4gbWFyay50eXBlLnNwZWMuY29kZSkpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dDtcbiAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgIHN0YXRlOiB2aWV3LnN0YXRlLFxuICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgfSk7XG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICBmcm9tOiBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSxcbiAgICAgIHRvXG4gICAgfTtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcmFuZ2UsXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgY2hhaW4sXG4gICAgICBjYW5cbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgdGV4dFxuICAgIH0pO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIG1hdGNoZWQgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIG1hdGNoZWQ7XG59XG5mdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgcHJldiwgc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pO1xuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaW11bGF0ZWRJbnB1dE1ldGEgPSB0ci5nZXRNZXRhKFwiYXBwbHlJbnB1dFJ1bGVzXCIpO1xuICAgICAgICBjb25zdCBpc1NpbXVsYXRlZElucHV0ID0gISFzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudDIuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgcGx1Z2luXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBydWxlcyxcbiAgICAgICAgICBwbHVnaW5cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiAodmlldykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBhZGQgc3VwcG9ydCBmb3IgaW5wdXQgcnVsZXMgdG8gdHJpZ2dlciBvbiBlbnRlclxuICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgZm9yIGNvZGUgYmxvY2tzXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0ZXh0OiBcIlxcblwiLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBwbHVnaW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gcGx1Z2luO1xufVxuXG4vLyBzcmMvdXRpbGl0aWVzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09IFwiT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9tZXJnZURlZXAudHNcbmZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gc3JjL0V4dGVuZGFibGUudHNcbnZhciBFeHRlbmRhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IFwiZXh0ZW5kYWJsZVwiO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsIFwiYWRkT3B0aW9uc1wiLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH0pXG4gICAgICApIHx8IHt9XG4gICAgfTtcbiAgfVxuICBnZXQgc3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCBcImFkZFN0b3JhZ2VcIiwge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSlcbiAgICAgICkgfHwge31cbiAgICB9O1xuICB9XG4gIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCh7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFkZE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICB9XG4gIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IHRoaXMuY29uc3RydWN0b3IoeyAuLi50aGlzLmNvbmZpZywgLi4uZXh0ZW5kZWRDb25maWcgfSk7XG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICBleHRlbnNpb24ubmFtZSA9IFwibmFtZVwiIGluIGV4dGVuZGVkQ29uZmlnID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICB9XG59O1xuXG4vLyBzcmMvTWFyay50c1xudmFyIE1hcmsgPSBjbGFzcyBfTWFyayBleHRlbmRzIEV4dGVuZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibWFya1wiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTWFyayBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gTWFyayBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcoKSA6IGNvbmZpZztcbiAgICByZXR1cm4gbmV3IF9NYXJrKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlO1xuICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcbiAgICBpZiAoaXNBdEVuZCkge1xuICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gY3VycmVudFBvcy5tYXJrcygpO1xuICAgICAgY29uc3QgaXNJbk1hcmsgPSAhIWN1cnJlbnRNYXJrcy5maW5kKChtKSA9PiAobSA9PSBudWxsID8gdm9pZCAwIDogbS50eXBlLm5hbWUpID09PSBtYXJrLm5hbWUpO1xuICAgICAgaWYgKCFpc0luTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQoKG0pID0+IChtID09IG51bGwgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKHJlbW92ZU1hcmspO1xuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dChcIiBcIiwgY3VycmVudFBvcy5wb3MpO1xuICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL1Bhc3RlUnVsZS50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQzIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW4yIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcblxuLy8gc3JjL3V0aWxpdGllcy9pc051bWJlci50c1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cblxuLy8gc3JjL1Bhc3RlUnVsZS50c1xudmFyIFBhc3RlUnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmQ7XG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXI7XG4gIH1cbn07XG52YXIgcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dCwgZmluZCwgZXZlbnQpID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIFsuLi50ZXh0Lm1hdGNoQWxsKGZpbmQpXTtcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudCk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5tYXAoKHBhc3RlUnVsZU1hdGNoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xuICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IHRleHQ7XG4gICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xuICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJ1bjIoY29uZmlnKSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZlbnQsIGRyb3BFdmVudCB9ID0gY29uZmlnO1xuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdm9pZCAwLCBcIlxcdUZGRkNcIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxO1xuICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICB0bzogc3RhdGUudHIubWFwcGluZy5tYXAoZW5kKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50XG4gICAgICB9KTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoKGhhbmRsZXIpID0+IGhhbmRsZXIgIT09IG51bGwpO1xuICByZXR1cm4gc3VjY2Vzcztcbn1cbnZhciB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gbnVsbDtcbnZhciBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBldmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIsIHtcbiAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKClcbiAgfSk7XG4gIChfYSA9IGV2ZW50LmNsaXBib2FyZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXREYXRhKFwidGV4dC9odG1sXCIsIHRleHQpO1xuICByZXR1cm4gZXZlbnQ7XG59O1xuZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wcykge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzO1xuICBsZXQgZHJhZ1NvdXJjZUVsZW1lbnQgPSBudWxsO1xuICBsZXQgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xuICBsZXQgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpIDogbnVsbDtcbiAgbGV0IGRyb3BFdmVudDtcbiAgdHJ5IHtcbiAgICBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IERyYWdFdmVudChcImRyb3BcIikgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICBkcm9wRXZlbnQgPSBudWxsO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NFdmVudCA9ICh7XG4gICAgc3RhdGUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBydWxlLFxuICAgIHBhc3RlRXZ0XG4gIH0pID0+IHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHJcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVyID0gcnVuMih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXG4gICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICB0bzogdG8uYiAtIDEsXG4gICAgICBydWxlLFxuICAgICAgcGFzdGVFdmVudDogcGFzdGVFdnQsXG4gICAgICBkcm9wRXZlbnRcbiAgICB9KTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBEcmFnRXZlbnQoXCJkcm9wXCIpIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRyb3BFdmVudCA9IG51bGw7XG4gICAgfVxuICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRyO1xuICB9O1xuICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKChydWxlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4yKHtcbiAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICB2aWV3KHZpZXcpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKSA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgIGlmIChkcmFnU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGRyYWdTb3VyY2VFbGVtZW50ID09PSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBkcmFnRnJvbU90aGVyRWRpdG9yID0gdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcjtcbiAgICAgICAgICAgICAgaWYgKGRyYWdGcm9tT3RoZXJFZGl0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGRyYWdGcm9tT3RoZXJFZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZHJhZ0Zyb21PdGhlckVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdGcm9tT3RoZXJFZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiBzZWxlY3Rpb24uZnJvbSwgdG86IHNlbGVjdGlvbi50byB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhc3RlOiAoX3ZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT0gbnVsbCA/IHZvaWQgMCA6IGh0bWwuaW5jbHVkZXMoXCJkYXRhLXBtLXNsaWNlXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zWzBdO1xuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInVpRXZlbnRcIikgPT09IFwicGFzdGVcIiAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3I7XG4gICAgICAgIGNvbnN0IGlzRHJvcCA9IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJ1aUV2ZW50XCIpID09PSBcImRyb3BcIiAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xuICAgICAgICBjb25zdCBzaW11bGF0ZWRQYXN0ZU1ldGEgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKFwiYXBwbHlQYXN0ZVJ1bGVzXCIpO1xuICAgICAgICBjb25zdCBpc1NpbXVsYXRlZFBhc3RlID0gISFzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgbGV0IHsgdGV4dCB9ID0gc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBnZXRIVE1MRnJvbUZyYWdtZW50KEZyYWdtZW50My5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGZyb206IGZyb20yIH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgICAgY29uc3QgdG8yID0gZnJvbTIgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBwYXN0ZUV2dCA9IGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQodGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBmcm9tOiBmcm9tMixcbiAgICAgICAgICAgIHRvOiB7IGI6IHRvMiB9LFxuICAgICAgICAgICAgcGFzdGVFdnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwYXN0ZUV2dDogcGFzdGVFdmVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwbHVnaW5zO1xufVxuXG4vLyBzcmMvRXh0ZW5zaW9uTWFuYWdlci50c1xudmFyIEV4dGVuc2lvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xuICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzID0gW107XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5leHRlbnNpb25zID0gcmVzb2x2ZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgdGhpcy5zY2hlbWEgPSBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMsIGVkaXRvcik7XG4gICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBjb21tYW5kcyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbGwgY29tbWFuZHMgd2hlcmUgdGhlIGtleSBpcyB0aGUgY29tbWFuZCBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGNvbW1hbmQgZnVuY3Rpb25cbiAgICovXG4gIGdldCBjb21tYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLnJlZHVjZSgoY29tbWFuZHMsIGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkQ29tbWFuZHNcIiwgY29udGV4dCk7XG4gICAgICBpZiAoIWFkZENvbW1hbmRzKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbW1hbmRzLFxuICAgICAgICAuLi5hZGRDb21tYW5kcygpXG4gICAgICB9O1xuICAgIH0sIHt9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgUHJvc2VtaXJyb3IgcGx1Z2luc1xuICAgKi9cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNvcnRFeHRlbnNpb25zKFsuLi50aGlzLmV4dGVuc2lvbnNdLnJldmVyc2UoKSk7XG4gICAgY29uc3QgaW5wdXRSdWxlcyA9IFtdO1xuICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBbXTtcbiAgICBjb25zdCBhbGxQbHVnaW5zID0gZXh0ZW5zaW9ucy5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwiYWRkS2V5Ym9hcmRTaG9ydGN1dHNcIixcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGxldCBkZWZhdWx0QmluZGluZ3MgPSB7fTtcbiAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gXCJtYXJrXCIgJiYgZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImV4aXRhYmxlXCIsIGNvbnRleHQpKSB7XG4gICAgICAgIGRlZmF1bHRCaW5kaW5ncy5BcnJvd1JpZ2h0ID0gKCkgPT4gTWFyay5oYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrOiBleHRlbnNpb24gfSk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH07XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKTtcbiAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pO1xuICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhZGRJbnB1dFJ1bGVzXCIsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlSW5wdXRSdWxlcykgJiYgYWRkSW5wdXRSdWxlcykge1xuICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiYWRkUGFzdGVSdWxlc1wiLCBjb250ZXh0KTtcbiAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZVBhc3RlUnVsZXMpICYmIGFkZFBhc3RlUnVsZXMpIHtcbiAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZChcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICBcImFkZFByb3NlTWlycm9yUGx1Z2luc1wiLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgaWYgKGFkZFByb3NlTWlycm9yUGx1Z2lucykge1xuICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcbiAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGx1Z2lucztcbiAgICB9KS5mbGF0KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzXG4gICAgICB9KSxcbiAgICAgIC4uLnBhc3RlUnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzXG4gICAgICB9KSxcbiAgICAgIC4uLmFsbFBsdWdpbnNcbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG5vZGUgdmlld3MgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgKi9cbiAgZ2V0IG5vZGVWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbm9kZUV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE5vZGVWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGV2aWV3ID0gKG5vZGUsIHZpZXcsIGdldFBvcywgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpID0+IHtcbiAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XG4gICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgLy8gdGlwdGFwLXNwZWNpZmljXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld107XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgZ2V0IG1hcmtWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbWFya0V4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIpKS5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcigoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXRNYXJrVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZE1hcmtWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcImFkZE1hcmtWaWV3XCIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZE1hcmtWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtWaWV3ID0gKG1hcmssIHZpZXcsIGlubGluZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgIHJldHVybiBhZGRNYXJrVmlldygpKHtcbiAgICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBpbmxpbmUsXG4gICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJzKSA9PiB7XG4gICAgICAgICAgICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhtYXJrLCBlZGl0b3IsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbWFya1ZpZXddO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICogJiBiaW5kIGVkaXRvciBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2UgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBleHRlbnNpb25zLm1hcCgoZXh0ZW5zaW9uKSA9PiBbZXh0ZW5zaW9uLm5hbWUsIGV4dGVuc2lvbi5zdG9yYWdlXSlcbiAgICApO1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSlcbiAgICAgIH07XG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJrZWVwT25TcGxpdFwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvbkJlZm9yZUNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJlZm9yZUNyZWF0ZVwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBcIm9uQ3JlYXRlXCIsIGNvbnRleHQpO1xuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25VcGRhdGVcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb24gPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25UcmFuc2FjdGlvblwiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25Gb2N1c1wiLCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJvbkJsdXJcIiwgY29udGV4dCk7XG4gICAgICBjb25zdCBvbkRlc3Ryb3kgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwib25EZXN0cm95XCIsIGNvbnRleHQpO1xuICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiYmVmb3JlQ3JlYXRlXCIsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImNyZWF0ZVwiLCBvbkNyZWF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJ1cGRhdGVcIiwgb25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgb25UcmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImJsdXJcIiwgb25CbHVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJkZXN0cm95XCIsIG9uRGVzdHJveSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5FeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUgPSByZXNvbHZlRXh0ZW5zaW9ucztcbkV4dGVuc2lvbk1hbmFnZXIuc29ydCA9IHNvcnRFeHRlbnNpb25zO1xuRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuID0gZmxhdHRlbkV4dGVuc2lvbnM7XG5cbi8vIHNyYy9leHRlbnNpb25zL2luZGV4LnRzXG52YXIgZXh0ZW5zaW9uc19leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRlbnNpb25zX2V4cG9ydHMsIHtcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogKCkgPT4gQ29tbWFuZHMsXG4gIERlbGV0ZTogKCkgPT4gRGVsZXRlLFxuICBEcm9wOiAoKSA9PiBEcm9wLFxuICBFZGl0YWJsZTogKCkgPT4gRWRpdGFibGUsXG4gIEZvY3VzRXZlbnRzOiAoKSA9PiBGb2N1c0V2ZW50cyxcbiAgS2V5bWFwOiAoKSA9PiBLZXltYXAsXG4gIFBhc3RlOiAoKSA9PiBQYXN0ZSxcbiAgVGFiaW5kZXg6ICgpID0+IFRhYmluZGV4LFxuICBmb2N1c0V2ZW50c1BsdWdpbktleTogKCkgPT4gZm9jdXNFdmVudHNQbHVnaW5LZXlcbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9jbGlwYm9hcmRUZXh0U2VyaWFsaXplci50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjMsIFBsdWdpbktleSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5cbi8vIHNyYy9FeHRlbnNpb24udHNcbnZhciBFeHRlbnNpb24gPSBjbGFzcyBfRXh0ZW5zaW9uIGV4dGVuZHMgRXh0ZW5kYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJleHRlbnNpb25cIjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEV4dGVuc2lvbiBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gRXh0ZW5zaW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZygpIDogY29uZmlnO1xuICAgIHJldHVybiBuZXcgX0V4dGVuc2lvbihyZXNvbHZlZENvbmZpZyk7XG4gIH1cbiAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG4gIGV4dGVuZChleHRlbmRlZENvbmZpZykge1xuICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnID0gdHlwZW9mIGV4dGVuZGVkQ29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBleHRlbmRlZENvbmZpZygpIDogZXh0ZW5kZWRDb25maWc7XG4gICAgcmV0dXJuIHN1cGVyLmV4dGVuZChyZXNvbHZlZENvbmZpZyk7XG4gIH1cbn07XG5cbi8vIHNyYy9leHRlbnNpb25zL2NsaXBib2FyZFRleHRTZXJpYWxpemVyLnRzXG52YXIgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja1NlcGFyYXRvcjogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luMyh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleShcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNsaXBib2FyZFRleHRTZXJpYWxpemVyOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAoKHJhbmdlMikgPT4gcmFuZ2UyLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKChyYW5nZTIpID0+IHJhbmdlMi4kdG8ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciAhPT0gdm9pZCAwID8geyBibG9ja1NlcGFyYXRvcjogdGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yIH0gOiB7fSxcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9jb21tYW5kcy9pbmRleC50c1xudmFyIGNvbW1hbmRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbW1hbmRzX2V4cG9ydHMsIHtcbiAgYmx1cjogKCkgPT4gYmx1cixcbiAgY2xlYXJDb250ZW50OiAoKSA9PiBjbGVhckNvbnRlbnQsXG4gIGNsZWFyTm9kZXM6ICgpID0+IGNsZWFyTm9kZXMsXG4gIGNvbW1hbmQ6ICgpID0+IGNvbW1hbmQsXG4gIGNyZWF0ZVBhcmFncmFwaE5lYXI6ICgpID0+IGNyZWF0ZVBhcmFncmFwaE5lYXIsXG4gIGN1dDogKCkgPT4gY3V0LFxuICBkZWxldGVDdXJyZW50Tm9kZTogKCkgPT4gZGVsZXRlQ3VycmVudE5vZGUsXG4gIGRlbGV0ZU5vZGU6ICgpID0+IGRlbGV0ZU5vZGUsXG4gIGRlbGV0ZVJhbmdlOiAoKSA9PiBkZWxldGVSYW5nZSxcbiAgZGVsZXRlU2VsZWN0aW9uOiAoKSA9PiBkZWxldGVTZWxlY3Rpb24sXG4gIGVudGVyOiAoKSA9PiBlbnRlcixcbiAgZXhpdENvZGU6ICgpID0+IGV4aXRDb2RlLFxuICBleHRlbmRNYXJrUmFuZ2U6ICgpID0+IGV4dGVuZE1hcmtSYW5nZSxcbiAgZmlyc3Q6ICgpID0+IGZpcnN0LFxuICBmb2N1czogKCkgPT4gZm9jdXMsXG4gIGZvckVhY2g6ICgpID0+IGZvckVhY2gsXG4gIGluc2VydENvbnRlbnQ6ICgpID0+IGluc2VydENvbnRlbnQsXG4gIGluc2VydENvbnRlbnRBdDogKCkgPT4gaW5zZXJ0Q29udGVudEF0LFxuICBqb2luQmFja3dhcmQ6ICgpID0+IGpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd246ICgpID0+IGpvaW5Eb3duLFxuICBqb2luRm9yd2FyZDogKCkgPT4gam9pbkZvcndhcmQsXG4gIGpvaW5JdGVtQmFja3dhcmQ6ICgpID0+IGpvaW5JdGVtQmFja3dhcmQsXG4gIGpvaW5JdGVtRm9yd2FyZDogKCkgPT4gam9pbkl0ZW1Gb3J3YXJkLFxuICBqb2luVGV4dGJsb2NrQmFja3dhcmQ6ICgpID0+IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCxcbiAgam9pblRleHRibG9ja0ZvcndhcmQ6ICgpID0+IGpvaW5UZXh0YmxvY2tGb3J3YXJkLFxuICBqb2luVXA6ICgpID0+IGpvaW5VcCxcbiAga2V5Ym9hcmRTaG9ydGN1dDogKCkgPT4ga2V5Ym9hcmRTaG9ydGN1dCxcbiAgbGlmdDogKCkgPT4gbGlmdCxcbiAgbGlmdEVtcHR5QmxvY2s6ICgpID0+IGxpZnRFbXB0eUJsb2NrLFxuICBsaWZ0TGlzdEl0ZW06ICgpID0+IGxpZnRMaXN0SXRlbSxcbiAgbmV3bGluZUluQ29kZTogKCkgPT4gbmV3bGluZUluQ29kZSxcbiAgcmVzZXRBdHRyaWJ1dGVzOiAoKSA9PiByZXNldEF0dHJpYnV0ZXMsXG4gIHNjcm9sbEludG9WaWV3OiAoKSA9PiBzY3JvbGxJbnRvVmlldyxcbiAgc2VsZWN0QWxsOiAoKSA9PiBzZWxlY3RBbGwsXG4gIHNlbGVjdE5vZGVCYWNrd2FyZDogKCkgPT4gc2VsZWN0Tm9kZUJhY2t3YXJkLFxuICBzZWxlY3ROb2RlRm9yd2FyZDogKCkgPT4gc2VsZWN0Tm9kZUZvcndhcmQsXG4gIHNlbGVjdFBhcmVudE5vZGU6ICgpID0+IHNlbGVjdFBhcmVudE5vZGUsXG4gIHNlbGVjdFRleHRibG9ja0VuZDogKCkgPT4gc2VsZWN0VGV4dGJsb2NrRW5kLFxuICBzZWxlY3RUZXh0YmxvY2tTdGFydDogKCkgPT4gc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gIHNldENvbnRlbnQ6ICgpID0+IHNldENvbnRlbnQsXG4gIHNldE1hcms6ICgpID0+IHNldE1hcmssXG4gIHNldE1ldGE6ICgpID0+IHNldE1ldGEsXG4gIHNldE5vZGU6ICgpID0+IHNldE5vZGUsXG4gIHNldE5vZGVTZWxlY3Rpb246ICgpID0+IHNldE5vZGVTZWxlY3Rpb24sXG4gIHNldFRleHRTZWxlY3Rpb246ICgpID0+IHNldFRleHRTZWxlY3Rpb24sXG4gIHNpbmtMaXN0SXRlbTogKCkgPT4gc2lua0xpc3RJdGVtLFxuICBzcGxpdEJsb2NrOiAoKSA9PiBzcGxpdEJsb2NrLFxuICBzcGxpdExpc3RJdGVtOiAoKSA9PiBzcGxpdExpc3RJdGVtLFxuICB0b2dnbGVMaXN0OiAoKSA9PiB0b2dnbGVMaXN0LFxuICB0b2dnbGVNYXJrOiAoKSA9PiB0b2dnbGVNYXJrLFxuICB0b2dnbGVOb2RlOiAoKSA9PiB0b2dnbGVOb2RlLFxuICB0b2dnbGVXcmFwOiAoKSA9PiB0b2dnbGVXcmFwLFxuICB1bmRvSW5wdXRSdWxlOiAoKSA9PiB1bmRvSW5wdXRSdWxlLFxuICB1bnNldEFsbE1hcmtzOiAoKSA9PiB1bnNldEFsbE1hcmtzLFxuICB1bnNldE1hcms6ICgpID0+IHVuc2V0TWFyayxcbiAgdXBkYXRlQXR0cmlidXRlczogKCkgPT4gdXBkYXRlQXR0cmlidXRlcyxcbiAgd3JhcEluOiAoKSA9PiB3cmFwSW4sXG4gIHdyYXBJbkxpc3Q6ICgpID0+IHdyYXBJbkxpc3Rcbn0pO1xuXG4vLyBzcmMvY29tbWFuZHMvYmx1ci50c1xudmFyIGJsdXIgPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgO1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGVhckNvbnRlbnQudHNcbnZhciBjbGVhckNvbnRlbnQgPSAoZW1pdFVwZGF0ZSA9IHRydWUpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoXCJcIiwgeyBlbWl0VXBkYXRlIH0pO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHNcbmltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpO1xuICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpO1xuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xuICAgICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpO1xuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAobm9kZVJhbmdlLnN0YXJ0LCBkZWZhdWx0VHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NvbW1hbmQudHNcbnZhciBjb21tYW5kID0gKGZuKSA9PiAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGZuKHByb3BzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzXG5pbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jdXQudHNcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIGN1dCA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xuICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50byk7XG4gIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcyk7XG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uMyh0ci5kb2MucmVzb2x2ZShNYXRoLm1heChuZXdQb3MgLSAxLCAwKSkpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZGVsZXRlQ3VycmVudE5vZGUudHNcbnZhciBkZWxldGVDdXJyZW50Tm9kZSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKCk7XG4gIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzXG52YXIgZGVsZXRlTm9kZSA9ICh0eXBlT3JOYW1lKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVSYW5nZS50c1xudmFyIGRlbGV0ZVJhbmdlID0gKHJhbmdlKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9kZWxldGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvZW50ZXIudHNcbnZhciBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoXCJFbnRlclwiKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9leGl0Q29kZS50c1xuaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgZXhpdENvZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2V4dGVuZE1hcmtSYW5nZS50c1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uNCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgZXh0ZW5kTWFya1JhbmdlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb240LmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9maXJzdC50c1xudmFyIGZpcnN0ID0gKGNvbW1hbmRzKSA9PiAocHJvcHMpID0+IHtcbiAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09IFwiZnVuY3Rpb25cIiA/IGNvbW1hbmRzKHByb3BzKSA6IGNvbW1hbmRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNBbmRyb2lkLnRzXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiQW5kcm9pZFwiIHx8IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9pc2lPUy50c1xuZnVuY3Rpb24gaXNpT1MoKSB7XG4gIHJldHVybiBbXCJpUGFkIFNpbXVsYXRvclwiLCBcImlQaG9uZSBTaW11bGF0b3JcIiwgXCJpUG9kIFNpbXVsYXRvclwiLCBcImlQYWRcIiwgXCJpUGhvbmVcIiwgXCJpUG9kXCJdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJNYWNcIikgJiYgXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQ7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9mb2N1cy50c1xudmFyIGZvY3VzID0gKHBvc2l0aW9uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBkZWxheWVkRm9jdXMgPSAoKSA9PiB7XG4gICAgaWYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpIHtcbiAgICAgIDtcbiAgICAgIHZpZXcuZG9tLmZvY3VzKCk7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgaWYgKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCB8fCBwb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgIGRlbGF5ZWRGb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc1NhbWVTZWxlY3Rpb24pIHtcbiAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcyk7XG4gICAgfVxuICAgIGRlbGF5ZWRGb2N1cygpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2ZvckVhY2gudHNcbnZhciBmb3JFYWNoID0gKGl0ZW1zLCBmbikgPT4gKHByb3BzKSA9PiB7XG4gIHJldHVybiBpdGVtcy5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGZuKGl0ZW0sIHsgLi4ucHJvcHMsIGluZGV4IH0pKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50LnRzXG52YXIgaW5zZXJ0Q29udGVudCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50QXQudHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50NCB9IGZyb20gXCJAdGlwdGFwL3BtL21vZGVsXCI7XG52YXIgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudCkgPT4ge1xuICByZXR1cm4gIShcInR5cGVcIiBpbiBub2RlT3JGcmFnbWVudCk7XG59O1xudmFyIGluc2VydENvbnRlbnRBdCA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGFyc2VPcHRpb25zOiBlZGl0b3Iub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXG4gICAgICBhcHBseUlucHV0UnVsZXM6IGZhbHNlLFxuICAgICAgYXBwbHlQYXN0ZVJ1bGVzOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGxldCBjb250ZW50O1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3Iuc3RhdGU7XG4gICAgY29uc3QgZW1pdENvbnRlbnRFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZWRpdG9yLmVtaXQoXCJjb250ZW50RXJyb3JcIiwge1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgIGlmIChcImNvbGxhYm9yYXRpb25cIiBpbiBlZGl0b3Iuc3RvcmFnZSAmJiB0eXBlb2YgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbiA9PT0gXCJvYmplY3RcIiAmJiBlZGl0b3Iuc3RvcmFnZS5jb2xsYWJvcmF0aW9uKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBlZGl0b3Iuc3RvcmFnZS5jb2xsYWJvcmF0aW9uLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSB7XG4gICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6IFwiZnVsbFwiLFxuICAgICAgLi4ub3B0aW9ucy5wYXJzZU9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgIWVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayAmJiBlZGl0b3Iub3B0aW9ucy5lbWl0Q29udGVudEVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjcmVhdGVOb2RlRnJvbUNvbnRlbnQodmFsdWUsIGVkaXRvci5zY2hlbWEsIHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbWl0Q29udGVudEVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29udGVudCA9IGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9IG51bGwgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZW1pdENvbnRlbnRFcnJvcihlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogeyBmcm9tOiBwb3NpdGlvbi5mcm9tLCB0bzogcG9zaXRpb24udG8gfTtcbiAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlO1xuICAgIGxldCBpc09ubHlCbG9ja0NvbnRlbnQgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5jaGVjaygpO1xuICAgICAgaXNPbmx5VGV4dENvbnRlbnQgPSBpc09ubHlUZXh0Q29udGVudCA/IG5vZGUuaXNUZXh0ICYmIG5vZGUubWFya3MubGVuZ3RoID09PSAwIDogZmFsc2U7XG4gICAgICBpc09ubHlCbG9ja0NvbnRlbnQgPSBpc09ubHlCbG9ja0NvbnRlbnQgPyBub2RlLmlzQmxvY2sgOiBmYWxzZTtcbiAgICB9KTtcbiAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gcGFyZW50LmlzVGV4dGJsb2NrICYmICFwYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgIXBhcmVudC5jaGlsZENvdW50O1xuICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgZnJvbSAtPSAxO1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV3Q29udGVudDtcbiAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUubWFwKCh2KSA9PiB2LnRleHQgfHwgXCJcIikuam9pbihcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudDQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUudGV4dCkge1xuICAgICAgICAgICAgdGV4dCArPSBub2RlLnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3Q29udGVudCA9IHRleHQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xuICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUudGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyLmluc2VydFRleHQobmV3Q29udGVudCwgZnJvbSwgdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDb250ZW50ID0gY29udGVudDtcbiAgICAgIGNvbnN0IGZyb21TZWxlY3Rpb25BdFN0YXJ0ID0gc2VsZWN0aW9uLiRmcm9tLnBhcmVudE9mZnNldCA9PT0gMDtcbiAgICAgIGNvbnN0IGlzVGV4dFNlbGVjdGlvbjIgPSBzZWxlY3Rpb24uJGZyb20ubm9kZSgpLmlzVGV4dCB8fCBzZWxlY3Rpb24uJGZyb20ubm9kZSgpLmlzVGV4dGJsb2NrO1xuICAgICAgY29uc3QgaGFzQ29udGVudCA9IHNlbGVjdGlvbi4kZnJvbS5ub2RlKCkuY29udGVudC5zaXplID4gMDtcbiAgICAgIGlmIChmcm9tU2VsZWN0aW9uQXRTdGFydCAmJiBpc1RleHRTZWxlY3Rpb24yICYmIGhhc0NvbnRlbnQpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KDAsIGZyb20gLSAxKTtcbiAgICAgIH1cbiAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBuZXdDb250ZW50KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgdHIuc3RlcHMubGVuZ3RoIC0gMSwgLTEpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hcHBseUlucHV0UnVsZXMpIHtcbiAgICAgIHRyLnNldE1ldGEoXCJhcHBseUlucHV0UnVsZXNcIiwgeyBmcm9tLCB0ZXh0OiBuZXdDb250ZW50IH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hcHBseVBhc3RlUnVsZXMpIHtcbiAgICAgIHRyLnNldE1ldGEoXCJhcHBseVBhc3RlUnVsZXNcIiwgeyBmcm9tLCB0ZXh0OiBuZXdDb250ZW50IH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9qb2luLnRzXG5pbXBvcnQge1xuICBqb2luQmFja3dhcmQgYXMgb3JpZ2luYWxKb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duIGFzIG9yaWdpbmFsSm9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkIGFzIG9yaWdpbmFsSm9pbkZvcndhcmQsXG4gIGpvaW5VcCBhcyBvcmlnaW5hbEpvaW5VcFxufSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGpvaW5VcCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbnZhciBqb2luRG93biA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Eb3duKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xudmFyIGpvaW5CYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbnZhciBqb2luRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Gb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvam9pbkl0ZW1CYWNrd2FyZC50c1xuaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgam9pbkl0ZW1CYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgdHIgfSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpO1xuICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvam9pbkl0ZW1Gb3J3YXJkLnRzXG5pbXBvcnQgeyBqb2luUG9pbnQgYXMgam9pblBvaW50MiB9IGZyb20gXCJAdGlwdGFwL3BtL3RyYW5zZm9ybVwiO1xudmFyIGpvaW5JdGVtRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgdHIgfSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50MihzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIDEpO1xuICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvam9pblRleHRibG9ja0JhY2t3YXJkLnRzXG5pbXBvcnQgeyBqb2luVGV4dGJsb2NrQmFja3dhcmQgYXMgb3JpZ2luYWxDb21tYW5kIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDb21tYW5kKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvam9pblRleHRibG9ja0ZvcndhcmQudHNcbmltcG9ydCB7IGpvaW5UZXh0YmxvY2tGb3J3YXJkIGFzIG9yaWdpbmFsQ29tbWFuZDIgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ29tbWFuZDIoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNNYWNPUy50c1xuZnVuY3Rpb24gaXNNYWNPUygpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzL2tleWJvYXJkU2hvcnRjdXQudHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gIGlmIChyZXN1bHQgPT09IFwiU3BhY2VcIikge1xuICAgIHJlc3VsdCA9IFwiIFwiO1xuICB9XG4gIGxldCBhbHQ7XG4gIGxldCBjdHJsO1xuICBsZXQgc2hpZnQ7XG4gIGxldCBtZXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIG1ldGEgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBhbHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgY3RybCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgc2hpZnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogJHttb2R9YCk7XG4gICAgfVxuICB9XG4gIGlmIChhbHQpIHtcbiAgICByZXN1bHQgPSBgQWx0LSR7cmVzdWx0fWA7XG4gIH1cbiAgaWYgKGN0cmwpIHtcbiAgICByZXN1bHQgPSBgQ3RybC0ke3Jlc3VsdH1gO1xuICB9XG4gIGlmIChtZXRhKSB7XG4gICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YDtcbiAgfVxuICBpZiAoc2hpZnQpIHtcbiAgICByZXN1bHQgPSBgU2hpZnQtJHtyZXN1bHR9YDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGtleWJvYXJkU2hvcnRjdXQgPSAobmFtZSkgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLyk7XG4gIGNvbnN0IGtleSA9IGtleXMuZmluZCgoaXRlbSkgPT4gIVtcIkFsdFwiLCBcIkN0cmxcIiwgXCJNZXRhXCIsIFwiU2hpZnRcIl0uaW5jbHVkZXMoaXRlbSkpO1xuICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7XG4gICAga2V5OiBrZXkgPT09IFwiU3BhY2VcIiA/IFwiIFwiIDoga2V5LFxuICAgIGFsdEtleToga2V5cy5pbmNsdWRlcyhcIkFsdFwiKSxcbiAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKFwiQ3RybFwiKSxcbiAgICBtZXRhS2V5OiBrZXlzLmluY2x1ZGVzKFwiTWV0YVwiKSxcbiAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcyhcIlNoaWZ0XCIpLFxuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZVxuICB9KTtcbiAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIChmKSA9PiBmKHZpZXcsIGV2ZW50KSk7XG4gIH0pO1xuICBjYXB0dXJlZFRyYW5zYWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICBjb25zdCBuZXdTdGVwID0gc3RlcC5tYXAodHIubWFwcGluZyk7XG4gICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0LnRzXG5pbXBvcnQgeyBsaWZ0IGFzIG9yaWdpbmFsTGlmdCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgbGlmdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCBpc0FjdGl2ZTIgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICBpZiAoIWlzQWN0aXZlMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3JpZ2luYWxMaWZ0KHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvbGlmdEVtcHR5QmxvY2sudHNcbmltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tIFwiQHRpcHRhcC9wbS9jb21tYW5kc1wiO1xudmFyIGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9saWZ0TGlzdEl0ZW0udHNcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgbGlmdExpc3RJdGVtID0gKHR5cGVPck5hbWUpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzXG5pbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvZGVsZXRlUHJvcHMudHNcbmZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaiwgcHJvcE9yUHJvcHMpIHtcbiAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09IFwic3RyaW5nXCIgPyBbcHJvcE9yUHJvcHNdIDogcHJvcE9yUHJvcHM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XG4gICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy9jb21tYW5kcy9yZXNldEF0dHJpYnV0ZXMudHNcbnZhciByZXNldEF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZSA9IG51bGw7XG4gIGxldCBtYXJrVHlwZSA9IG51bGw7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICB0eXBlb2YgdHlwZU9yTmFtZSA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hXG4gICk7XG4gIGlmICghc2NoZW1hVHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4ocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHZvaWQgMCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50c1xudmFyIHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RBbGwudHNcbmltcG9ydCB7IEFsbFNlbGVjdGlvbiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgc2VsZWN0QWxsID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IEFsbFNlbGVjdGlvbih0ci5kb2MpO1xuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVCYWNrd2FyZC50c1xuaW1wb3J0IHsgc2VsZWN0Tm9kZUJhY2t3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3ROb2RlQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3ROb2RlRm9yd2FyZC50c1xuaW1wb3J0IHsgc2VsZWN0Tm9kZUZvcndhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0Tm9kZUZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHNcbmltcG9ydCB7IHNlbGVjdFBhcmVudE5vZGUgYXMgb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3RQYXJlbnROb2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja0VuZC50c1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSBcIkB0aXB0YXAvcG0vY29tbWFuZHNcIjtcbnZhciBzZWxlY3RUZXh0YmxvY2tFbmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tFbmQoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tTdGFydC50c1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrU3RhcnQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydCB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydChzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldENvbnRlbnQudHNcbnZhciBzZXRDb250ZW50ID0gKGNvbnRlbnQsIHsgZXJyb3JPbkludmFsaWRDb250ZW50LCBlbWl0VXBkYXRlID0gdHJ1ZSwgcGFyc2VPcHRpb25zID0ge30gfSA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gIGlmIChwYXJzZU9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBcImZ1bGxcIikge1xuICAgIGNvbnN0IGRvY3VtZW50MiA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucywge1xuICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBlcnJvck9uSW52YWxpZENvbnRlbnQgIT0gbnVsbCA/IGVycm9yT25JbnZhbGlkQ29udGVudCA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgIH0pO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQyKS5zZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiLCAhZW1pdFVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNldE1ldGEoXCJwcmV2ZW50VXBkYXRlXCIsICFlbWl0VXBkYXRlKTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogMCwgdG86IGRvYy5jb250ZW50LnNpemUgfSwgY29udGVudCwge1xuICAgIHBhcnNlT3B0aW9ucyxcbiAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGVycm9yT25JbnZhbGlkQ29udGVudCAhPSBudWxsID8gZXJyb3JPbkludmFsaWRDb250ZW50IDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gIH0pO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldE1hcmsudHNcbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgbGV0IGN1cnNvciA9IG51bGw7XG4gIGlmIChpc1RleHRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yO1xuICB9XG4gIGlmIChjdXJzb3IpIHtcbiAgICBjb25zdCBjdXJyZW50TWFya3MgPSAoX2EgPSBzdGF0ZS5zdG9yZWRNYXJrcykgIT0gbnVsbCA/IF9hIDogY3Vyc29yLm1hcmtzKCk7XG4gICAgcmV0dXJuICEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpIHx8ICFjdXJyZW50TWFya3Muc29tZSgobWFyaykgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gIH1cbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwID8gc3RhdGUuZG9jLmlubGluZUNvbnRlbnQgJiYgc3RhdGUuZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpIDogZmFsc2U7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pc0lubGluZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpO1xuICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpIHx8ICFub2RlLm1hcmtzLnNvbWUoKG90aGVyTWFyaykgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKTtcbiAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICB9KTtcbiAgICByZXR1cm4gc29tZU5vZGVTdXBwb3J0c01hcms7XG4gIH0pO1xufVxudmFyIHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcbiAgICAgIHRyLmFkZFN0b3JlZE1hcmsoXG4gICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKChtYXJrKSA9PiBtYXJrLnR5cGUgPT09IHR5cGUpO1xuICAgICAgICAgIGlmIChzb21lSGFzTWFyaykge1xuICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRNZXRhLnRzXG52YXIgc2V0TWV0YSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldE5vZGUudHNcbmltcG9ydCB7IHNldEJsb2NrVHlwZSB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgc2V0Tm9kZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5zYW1lUGFyZW50KHN0YXRlLnNlbGVjdGlvbi4kaGVhZCkpIHtcbiAgICBhdHRyaWJ1dGVzVG9Db3B5ID0gc3RhdGUuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50LmF0dHJzO1xuICB9XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykge1xuICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCBjYW5TZXRCbG9jayA9IHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkoc3RhdGUpO1xuICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gIH0pLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaCk7XG4gIH0pLnJ1bigpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3NldE5vZGVTZWxlY3Rpb24udHNcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gYXMgTm9kZVNlbGVjdGlvbjIgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIHNldE5vZGVTZWxlY3Rpb24gPSAocG9zaXRpb24pID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uMi5jcmVhdGUoZG9jLCBmcm9tKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zZXRUZXh0U2VsZWN0aW9uLnRzXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb241IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBzZXRUZXh0U2VsZWN0aW9uID0gKHBvc2l0aW9uKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSBcIm51bWJlclwiID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcbiAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uNS5hdFN0YXJ0KGRvYykuZnJvbTtcbiAgICBjb25zdCBtYXhQb3MgPSBUZXh0U2VsZWN0aW9uNS5hdEVuZChkb2MpLnRvO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uNS5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zaW5rTGlzdEl0ZW0udHNcbmltcG9ydCB7IHNpbmtMaXN0SXRlbSBhcyBvcmlnaW5hbFNpbmtMaXN0SXRlbSB9IGZyb20gXCJAdGlwdGFwL3BtL3NjaGVtYS1saXN0XCI7XG52YXIgc2lua0xpc3RJdGVtID0gKHR5cGVPck5hbWUpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gb3JpZ2luYWxTaW5rTGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zcGxpdEJsb2NrLnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24zLCBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb242IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XG4gIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gIGlmIChtYXJrcykge1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcyA9PSBudWxsID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgc3RhdGUudHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gIH1cbn1cbnZhciBzcGxpdEJsb2NrID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyO1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKTtcbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24zICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKTtcbiAgICAgIH1cbiAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwID8gdm9pZCAwIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHQgPyBbXG4gICAge1xuICAgICAgdHlwZTogZGVmbHQsXG4gICAgICBhdHRyczogbmV3QXR0cmlidXRlc1xuICAgIH1cbiAgXSA6IHZvaWQgMDtcbiAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdm9pZCAwKSkge1xuICAgIGNhbiA9IHRydWU7XG4gICAgdHlwZXMgPSBkZWZsdCA/IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzXG4gICAgICB9XG4gICAgXSA6IHZvaWQgMDtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoY2FuKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjYpIHtcbiAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0MiA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKTtcbiAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QyKTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgfVxuICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gIH1cbiAgcmV0dXJuIGNhbjtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9zcGxpdExpc3RJdGVtLnRzXG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDUsIFNsaWNlIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjcgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgY2FuU3BsaXQgYXMgY2FuU3BsaXQyIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgc3BsaXRMaXN0SXRlbSA9ICh0eXBlT3JOYW1lLCBvdmVycmlkZUF0dHJzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCBub2RlID0gc3RhdGUuc2VsZWN0aW9uLm5vZGU7XG4gIGlmIChub2RlICYmIG5vZGUuaXNCbG9jayB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICBpZiAoJGZyb20uZGVwdGggPT09IDIgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZSB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudDUuZW1wdHk7XG4gICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgIHdyYXAgPSBGcmFnbWVudDUuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVwdGhBZnRlciA9IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogM1xuICAgICAgKTtcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlczIgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAuLi5vdmVycmlkZUF0dHJzXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV4dFR5cGUyID0gKChfYSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMyKSkgfHwgdm9pZCAwO1xuICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50NS5mcm9tKHR5cGUuY3JlYXRlQW5kRmlsbChudWxsLCBuZXh0VHlwZTIpIHx8IHZvaWQgMCkpO1xuICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmlzVGV4dGJsb2NrICYmIG4uY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb243Lm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgfVxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbmV4dFR5cGUgPSAkdG8ucG9zID09PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgY29uc3QgbmV3VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsIGdyYW5kUGFyZW50LnR5cGUubmFtZSwgZ3JhbmRQYXJlbnQuYXR0cnMpLFxuICAgIC4uLm92ZXJyaWRlQXR0cnNcbiAgfTtcbiAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0ge1xuICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgIC4uLm92ZXJyaWRlQXR0cnNcbiAgfTtcbiAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gIGNvbnN0IHR5cGVzID0gbmV4dFR5cGUgPyBbXG4gICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH1cbiAgXSA6IFt7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9XTtcbiAgaWYgKCFjYW5TcGxpdDIodHIuZG9jLCAkZnJvbS5wb3MsIDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCk7XG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICBpZiAoIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3RvZ2dsZUxpc3QudHNcbmltcG9ydCB7IGNhbkpvaW4gfSBmcm9tIFwiQHRpcHRhcC9wbS90cmFuc2Zvcm1cIjtcbnZhciBqb2luTGlzdEJhY2t3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XG4gIGlmIChiZWZvcmUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5vZGVCZWZvcmUgPSB0ci5kb2Mubm9kZUF0KGJlZm9yZSk7XG4gIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVCZWZvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVCZWZvcmUudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKTtcbiAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHIuam9pbihsaXN0LnBvcyk7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBqb2luTGlzdEZvcndhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aCk7XG4gIGlmIChhZnRlciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XG4gIGNvbnN0IGNhbkpvaW5Gb3J3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSAobm9kZUFmdGVyID09IG51bGwgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0ci5qb2luKGFmdGVyKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHRvZ2dsZUxpc3QgPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbiB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5zaW9ucywgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBhcmVudExpc3QgPSBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcbiAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudCkgJiYgZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiBjaGFpbigpLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudExpc3QucG9zLCBsaXN0VHlwZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSkucnVuKCk7XG4gICAgfVxuICB9XG4gIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICB9KS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKS5ydW4oKTtcbiAgfVxuICByZXR1cm4gY2hhaW4oKS5jb21tYW5kKCgpID0+IHtcbiAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICB9KS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKS5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKS5ydW4oKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVNYXJrLnRzXG52YXIgdG9nZ2xlTWFyayA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGlzQWN0aXZlMikge1xuICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy90b2dnbGVOb2RlLnRzXG52YXIgdG9nZ2xlTm9kZSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5zYW1lUGFyZW50KHN0YXRlLnNlbGVjdGlvbi4kaGVhZCkpIHtcbiAgICBhdHRyaWJ1dGVzVG9Db3B5ID0gc3RhdGUuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50LmF0dHJzO1xuICB9XG4gIGlmIChpc0FjdGl2ZTIpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlLCBhdHRyaWJ1dGVzVG9Db3B5KTtcbiAgfVxuICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdG9nZ2xlV3JhcC50c1xudmFyIHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgaXNBY3RpdmUyID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGlzQWN0aXZlMikge1xuICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpO1xuICB9XG4gIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdW5kb0lucHV0UnVsZS50c1xudmFyIHVuZG9JbnB1dFJ1bGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBsZXQgdW5kb2FibGU7XG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgZm9yIChsZXQgaiA9IHRvVW5kby5zdGVwcy5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpO1xuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50c1xudmFyIHVuc2V0QWxsTWFya3MgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91bnNldE1hcmsudHNcbnZhciB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbXB0eSAmJiBleHRlbmRFbXB0eU1hcmtSYW5nZSkge1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYXR0cnMgPSAoX2EgPSAkZnJvbS5tYXJrcygpLmZpbmQoKG1hcmspID0+IG1hcmsudHlwZSA9PT0gdHlwZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRycztcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgZnJvbSA9IHJhbmdlLmZyb207XG4gICAgICB0byA9IHJhbmdlLnRvO1xuICAgIH1cbiAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcbiAgICB9KTtcbiAgfVxuICB0ci5yZW1vdmVTdG9yZWRNYXJrKHR5cGUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy91cGRhdGVBdHRyaWJ1dGVzLnRzXG52YXIgdXBkYXRlQXR0cmlidXRlcyA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGUgPSBudWxsO1xuICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLFxuICAgIHN0YXRlLnNjaGVtYVxuICApO1xuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcIm1hcmtcIikge1xuICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2goKHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xuICAgICAgbGV0IGxhc3RQb3M7XG4gICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICBsZXQgdHJpbW1lZEZyb207XG4gICAgICBsZXQgdHJpbW1lZFRvO1xuICAgICAgaWYgKHRyLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgIHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb3M7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgcG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbTIgPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvMiA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tMixcbiAgICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvMixcbiAgICAgICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgIGlmIChsYXN0UG9zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKGxhc3RQb3MsIHZvaWQgMCwge1xuICAgICAgICAgICAgLi4ubGFzdE5vZGUuYXR0cnMsXG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIGxhc3ROb2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIGxhc3ROb2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy93cmFwSW4udHNcbmltcG9ydCB7IHdyYXBJbiBhcyBvcmlnaW5hbFdyYXBJbiB9IGZyb20gXCJAdGlwdGFwL3BtL2NvbW1hbmRzXCI7XG52YXIgd3JhcEluID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL3dyYXBJbkxpc3QudHNcbmltcG9ydCB7IHdyYXBJbkxpc3QgYXMgb3JpZ2luYWxXcmFwSW5MaXN0IH0gZnJvbSBcIkB0aXB0YXAvcG0vc2NoZW1hLWxpc3RcIjtcbnZhciB3cmFwSW5MaXN0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbkxpc3QodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIHNyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzXG52YXIgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJjb21tYW5kc1wiLFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbWFuZHNfZXhwb3J0c1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9kZWxldGUudHNcbmltcG9ydCB7IFJlbW92ZU1hcmtTdGVwIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG52YXIgRGVsZXRlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZGVsZXRlXCIsXG4gIG9uVXBkYXRlKHsgdHJhbnNhY3Rpb24sIGFwcGVuZGVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iMiwgX2MyLCBfZDtcbiAgICAgIGlmICgoX2QgPSAoX2MyID0gKF9iMiA9IChfYTIgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlbGV0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5maWx0ZXJUcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKF9iMiwgdHJhbnNhY3Rpb24pKSAhPSBudWxsID8gX2QgOiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwieS1zeW5jJFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0VHJhbnNhY3Rpb24gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyh0cmFuc2FjdGlvbi5iZWZvcmUsIFt0cmFuc2FjdGlvbiwgLi4uYXBwZW5kZWRUcmFuc2FjdGlvbnNdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKG5leHRUcmFuc2FjdGlvbik7XG4gICAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICBpZiAobmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS5mcm9tKS5kZWxldGVkQWZ0ZXIgJiYgbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS50bykuZGVsZXRlZEJlZm9yZSkge1xuICAgICAgICAgIG5leHRUcmFuc2FjdGlvbi5iZWZvcmUubm9kZXNCZXR3ZWVuKGNoYW5nZS5vbGRSYW5nZS5mcm9tLCBjaGFuZ2Uub2xkUmFuZ2UudG8sIChub2RlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplIC0gMjtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVsbHlXaXRoaW5SYW5nZSA9IGNoYW5nZS5vbGRSYW5nZS5mcm9tIDw9IGZyb20gJiYgdG8gPD0gY2hhbmdlLm9sZFJhbmdlLnRvO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcImRlbGV0ZVwiLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgbmV3RnJvbTogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKGZyb20pLFxuICAgICAgICAgICAgICBuZXdUbzogbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwKHRvKSxcbiAgICAgICAgICAgICAgZGVsZXRlZFJhbmdlOiBjaGFuZ2Uub2xkUmFuZ2UsXG4gICAgICAgICAgICAgIG5ld1JhbmdlOiBjaGFuZ2UubmV3UmFuZ2UsXG4gICAgICAgICAgICAgIHBhcnRpYWw6ICFpc0Z1bGx5V2l0aGluUmFuZ2UsXG4gICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBjb21iaW5lZFRyYW5zZm9ybTogbmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmc7XG4gICAgICBuZXh0VHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hMywgX2IzO1xuICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoc3RlcC5mcm9tLCAtMSk7XG4gICAgICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHN0ZXAudG8pO1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kQmVmb3JlTWFyayA9IChfYTMgPSBuZXh0VHJhbnNhY3Rpb24uZG9jLm5vZGVBdChuZXdTdGFydCAtIDEpKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLm1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmsuZXEoc3RlcC5tYXJrKSk7XG4gICAgICAgICAgY29uc3QgZm91bmRBZnRlck1hcmsgPSAoX2IzID0gbmV4dFRyYW5zYWN0aW9uLmRvYy5ub2RlQXQobmV3RW5kKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMy5tYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrLmVxKHN0ZXAubWFyaykpO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkZWxldGVcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICBtYXJrOiBzdGVwLm1hcmssXG4gICAgICAgICAgICBmcm9tOiBzdGVwLmZyb20sXG4gICAgICAgICAgICB0bzogc3RlcC50byxcbiAgICAgICAgICAgIGRlbGV0ZWRSYW5nZToge1xuICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgdG86IG9sZEVuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICB0bzogbmV3RW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGlhbDogQm9vbGVhbihmb3VuZEFmdGVyTWFyayB8fCBmb3VuZEJlZm9yZU1hcmspLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgY29tYmluZWRUcmFuc2Zvcm06IG5leHRUcmFuc2FjdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsZXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXN5bmMpICE9IG51bGwgPyBfYyA6IHRydWUpIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL2Ryb3AudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW40LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5MiB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgRHJvcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImRyb3BcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTIoXCJ0aXB0YXBEcm9wXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoXCJkcm9wXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlLFxuICAgICAgICAgICAgICBtb3ZlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZXh0ZW5zaW9ucy9lZGl0YWJsZS50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjUsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImVkaXRhYmxlXCIsXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjUoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkzKFwiZWRpdGFibGVcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMvZm9jdXNFdmVudHMudHNcbmltcG9ydCB7IFBsdWdpbiBhcyBQbHVnaW42LCBQbHVnaW5LZXkgYXMgUGx1Z2luS2V5NCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG52YXIgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5NChcImZvY3VzRXZlbnRzXCIpO1xudmFyIEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNFdmVudHNcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNih7XG4gICAgICAgIGtleTogZm9jdXNFdmVudHNQbHVnaW5LZXksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiZm9jdXNcIiwgeyBldmVudCB9KS5zZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFwiYmx1clwiLCB7IGV2ZW50IH0pLnNldE1ldGEoXCJhZGRUb0hpc3RvcnlcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2V4dGVuc2lvbnMva2V5bWFwLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUsIFNlbGVjdGlvbiBhcyBTZWxlY3Rpb24zIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJrZXltYXBcIixcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxuICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvcjtcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZztcbiAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldDtcbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gcGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3MgOiBTZWxlY3Rpb24zLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3M7XG4gICAgICAgIGlmICghZW1wdHkgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGggfHwgIWlzQXRTdGFydCB8fCBpc0F0U3RhcnQgJiYgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICB9KSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKVxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpXG4gICAgXSk7XG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpXG4gICAgXSk7XG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgIFwiTW9kLUVudGVyXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiTW9kLURlbGV0ZVwiOiBoYW5kbGVEZWxldGUsXG4gICAgICBcIk1vZC1hXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpXG4gICAgfTtcbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXBcbiAgICB9O1xuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICBcIkN0cmwtaFwiOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBcIkFsdC1CYWNrc3BhY2VcIjogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgXCJDdHJsLWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJBbHQtRGVsZXRlXCI6IGhhbmRsZURlbGV0ZSxcbiAgICAgIFwiQWx0LWRcIjogaGFuZGxlRGVsZXRlLFxuICAgICAgXCJDdHJsLWFcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgIFwiQ3RybC1lXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpXG4gICAgfTtcbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXA7XG4gICAgfVxuICAgIHJldHVybiBwY0tleW1hcDtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW43KHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5NShcImNsZWFyRG9jdW1lbnRcIiksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUoKHRyMikgPT4gdHIyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVRyID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudENsZWFyRG9jdW1lbnRcIikpO1xuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBpZ25vcmVUcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0byB9ID0gb2xkU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24zLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tO1xuICAgICAgICAgIGNvbnN0IGFsbEVuZCA9IFNlbGVjdGlvbjMuYXRFbmQob2xkU3RhdGUuZG9jKS50bztcbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZDtcbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSBpc05vZGVFbXB0eShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0ciA9IG5ld1N0YXRlLnRyO1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3Bhc3RlLnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTYgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFBhc3RlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFzdGVcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOCh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTYoXCJ0aXB0YXBQYXN0ZVwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdChcInBhc3RlXCIsIHtcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHNsaWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luOSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTcgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFiaW5kZXhcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luOSh7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleTcoXCJ0YWJpbmRleFwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiAoKSA9PiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlID8geyB0YWJpbmRleDogXCIwXCIgfSA6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9Ob2RlUG9zLnRzXG52YXIgTm9kZVBvcyA9IGNsYXNzIF9Ob2RlUG9zIHtcbiAgY29uc3RydWN0b3IocG9zLCBlZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZSA9IG51bGwpIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLmFjdHVhbERlcHRoID0gbnVsbDtcbiAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuICAgIHRoaXMucmVzb2x2ZWRQb3MgPSBwb3M7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7XG4gIH1cbiAgZ2V0IG5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudE5vZGUgfHwgdGhpcy5yZXNvbHZlZFBvcy5ub2RlKCk7XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGU7XG4gIH1cbiAgZ2V0IGRlcHRoKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5hY3R1YWxEZXB0aCkgIT0gbnVsbCA/IF9hIDogdGhpcy5yZXNvbHZlZFBvcy5kZXB0aDtcbiAgfVxuICBnZXQgcG9zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvcztcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IGNvbnRlbnQoY29udGVudCkge1xuICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xuICAgIGxldCB0byA9IHRoaXMudG87XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBjYW5cXHUyMDE5dCBzZXQgY29udGVudCBvbiBhIGJsb2NrIG5vZGUuIFRyaWVkIHRvIHNldCBjb250ZW50IG9uICR7dGhpcy5uYW1lfSBhdCAke3RoaXMucG9zfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmcm9tID0gdGhpcy5mcm9tICsgMTtcbiAgICAgIHRvID0gdGhpcy50byAtIDE7XG4gICAgfVxuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb20sIHRvIH0sIGNvbnRlbnQpO1xuICB9XG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuYXR0cnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTtcbiAgfVxuICBnZXQgZnJvbSgpIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpO1xuICB9XG4gIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgdG86IHRoaXMudG9cbiAgICB9O1xuICB9XG4gIGdldCB0bygpIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLmVuZCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKSArICh0aGlzLm5vZGUuaXNUZXh0ID8gMCA6IDEpO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKTtcbiAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZShwYXJlbnRQb3MpO1xuICAgIHJldHVybiBuZXcgX05vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICB9XG4gIGdldCBiZWZvcmUoKSB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpO1xuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgZ2V0IGFmdGVyKCkge1xuICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgKHRoaXMuaXNCbG9jayA/IDIgOiAxKSk7XG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrO1xuICAgICAgY29uc3QgaXNOb25UZXh0QXRvbSA9IG5vZGUuaXNBdG9tICYmICFub2RlLmlzVGV4dDtcbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSk7XG4gICAgICBpZiAodGFyZ2V0UG9zIDwgMCB8fCB0YXJnZXRQb3MgPiB0aGlzLnJlc29sdmVkUG9zLmRvYy5ub2RlU2l6ZSAtIDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGFyZ2V0UG9zKTtcbiAgICAgIGlmICghaXNCbG9jayAmJiAkcG9zLmRlcHRoIDw9IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGROb2RlUG9zID0gbmV3IF9Ob2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpO1xuICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgY2hpbGROb2RlUG9zLmFjdHVhbERlcHRoID0gdGhpcy5kZXB0aCArIDE7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wdXNoKG5ldyBfTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIGdldCBmaXJzdENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cbiAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gIH1cbiAgY2xvc2VzdChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRycztcbiAgICAgICAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyS2V5cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF0dHJLZXlzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChub2RlQXR0cmlidXRlc1trZXldICE9PSBhdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGw7XG4gIH1cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9LCBmaXJzdEl0ZW1Pbmx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICBpZiAoIXRoaXMuY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkUG9zKSA9PiB7XG4gICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZFBvcy5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KChrZXkpID0+IGF0dHJpYnV0ZXNba2V5XSA9PT0gY2hpbGRQb3Mubm9kZS5hdHRyc1trZXldKTtcbiAgICAgICAgaWYgKGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2gpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkUG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpcnN0SXRlbU9ubHkgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBmaXJzdEl0ZW1Pbmx5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgeyB0ciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGU7XG4gICAgdHIuc2V0Tm9kZU1hcmt1cCh0aGlzLmZyb20sIHZvaWQgMCwge1xuICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgLi4uYXR0cmlidXRlc1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59O1xuXG4vLyBzcmMvc3R5bGUudHNcbnZhciBzdHlsZSA9IGAuUHJvc2VNaXJyb3Ige1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Qcm9zZU1pcnJvciB7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogXCJsaWdhXCIgMDsgLyogdGhlIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIEVkZ2UgKi9cbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0gW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0ge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5Qcm9zZU1pcnJvciBwcmUge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbmltZy5Qcm9zZU1pcnJvci1zZXBhcmF0b3Ige1xuICBkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB3aWR0aDogMCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDAgIWltcG9ydGFudDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbjogMDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvcjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTJweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcbiAgYW5pbWF0aW9uOiBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsgMS4xcyBzdGVwcygyLCBzdGFydCkgaW5maW5pdGU7XG59XG5cbkBrZXlmcmFtZXMgUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIHtcbiAgdG8ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKiB7XG4gIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWZvY3VzZWQgLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufWA7XG5cbi8vIHNyYy91dGlsaXRpZXMvY3JlYXRlU3R5bGVUYWcudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlMiwgbm9uY2UsIHN1ZmZpeCkge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiBcIlwifV1gKTtcbiAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRpcHRhcFN0eWxlVGFnO1xuICB9XG4gIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogXCJcIn1gLCBcIlwiKTtcbiAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlMjtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XG4gIHJldHVybiBzdHlsZU5vZGU7XG59XG5cbi8vIHNyYy9FZGl0b3IudHNcbnZhciBFZGl0b3IgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jc3MgPSBudWxsO1xuICAgIHRoaXMuZWRpdG9yVmlldyA9IG51bGw7XG4gICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGNvbnNpZGVyZWQgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGBjcmVhdGVgIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICovXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25TdG9yYWdlID0ge307XG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgSUQgZm9yIHRoaXMgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVsZW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiBudWxsLFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICAgIGluamVjdE5vbmNlOiB2b2lkIDAsXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgIGVkaXRvclByb3BzOiB7fSxcbiAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICBjb3JlRXh0ZW5zaW9uT3B0aW9uczoge30sXG4gICAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgICAgZW5hYmxlUGFzdGVSdWxlczogdHJ1ZSxcbiAgICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxuICAgICAgZW5hYmxlQ29udGVudENoZWNrOiBmYWxzZSxcbiAgICAgIGVtaXRDb250ZW50RXJyb3I6IGZhbHNlLFxuICAgICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiBudWxsLFxuICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgIG9uQ29udGVudEVycm9yOiAoeyBlcnJvciB9KSA9PiB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcbiAgICAgIG9uUGFzdGU6ICgpID0+IG51bGwsXG4gICAgICBvbkRyb3A6ICgpID0+IG51bGwsXG4gICAgICBvbkRlbGV0ZTogKCkgPT4gbnVsbFxuICAgIH07XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5jcmVhdGVDb21tYW5kTWFuYWdlcigpO1xuICAgIHRoaXMuY3JlYXRlU2NoZW1hKCk7XG4gICAgdGhpcy5vbihcImJlZm9yZUNyZWF0ZVwiLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpO1xuICAgIHRoaXMuZW1pdChcImJlZm9yZUNyZWF0ZVwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICB0aGlzLm9uKFwiY29udGVudEVycm9yXCIsIHRoaXMub3B0aW9ucy5vbkNvbnRlbnRFcnJvcik7XG4gICAgdGhpcy5vbihcImNyZWF0ZVwiLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xuICAgIHRoaXMub24oXCJ1cGRhdGVcIiwgdGhpcy5vcHRpb25zLm9uVXBkYXRlKTtcbiAgICB0aGlzLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy5vbihcInRyYW5zYWN0aW9uXCIsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLm9uKFwiZm9jdXNcIiwgdGhpcy5vcHRpb25zLm9uRm9jdXMpO1xuICAgIHRoaXMub24oXCJibHVyXCIsIHRoaXMub3B0aW9ucy5vbkJsdXIpO1xuICAgIHRoaXMub24oXCJkZXN0cm95XCIsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xuICAgIHRoaXMub24oXCJkcm9wXCIsICh7IGV2ZW50LCBzbGljZSwgbW92ZWQgfSkgPT4gdGhpcy5vcHRpb25zLm9uRHJvcChldmVudCwgc2xpY2UsIG1vdmVkKSk7XG4gICAgdGhpcy5vbihcInBhc3RlXCIsICh7IGV2ZW50LCBzbGljZSB9KSA9PiB0aGlzLm9wdGlvbnMub25QYXN0ZShldmVudCwgc2xpY2UpKTtcbiAgICB0aGlzLm9uKFwiZGVsZXRlXCIsIHRoaXMub3B0aW9ucy5vbkRlbGV0ZSk7XG4gICAgY29uc3QgaW5pdGlhbERvYyA9IHRoaXMuY3JlYXRlRG9jKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oaW5pdGlhbERvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JTdGF0ZSA9IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICBkb2M6IGluaXRpYWxEb2MsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdm9pZCAwXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICB0aGlzLm1vdW50KHRoaXMub3B0aW9ucy5lbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCB0aGUgZWRpdG9yIHRvIHRoZSBET00sIGNyZWF0aW5nIGEgbmV3IGVkaXRvciB2aWV3LlxuICAgKi9cbiAgbW91bnQoZWwpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBbdGlwdGFwIGVycm9yXTogVGhlIGVkaXRvciBjYW5ub3QgYmUgbW91bnRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vICdkb2N1bWVudCcgZGVmaW5lZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlVmlldyhlbCk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcbiAgICAgIHRoaXMuZW1pdChcImNyZWF0ZVwiLCB7IGVkaXRvcjogdGhpcyB9KTtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSwgYnV0IHN0aWxsIGFsbG93IHJlbW91bnRpbmcgYXQgYSBkaWZmZXJlbnQgcG9pbnQgaW4gdGltZVxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgY29uc3QgZG9tID0gdGhpcy5lZGl0b3JWaWV3LmRvbTtcbiAgICAgIGlmIChkb20gPT0gbnVsbCA/IHZvaWQgMCA6IGRvbS5lZGl0b3IpIHtcbiAgICAgICAgZGVsZXRlIGRvbS5lZGl0b3I7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvclZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBudWxsO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIChfYSA9IHRoaXMuY3NzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgdGhpcy5jc3MgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICovXG4gIGdldCBzdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvblN0b3JhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIGdldCBjb21tYW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jb21tYW5kcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBjaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqL1xuICBjYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgaW5qZWN0Q1NTKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCF0aGlzLmVkaXRvclZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSB7XG4gICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcbiAgICB9XG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlLCBlbWl0VXBkYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyh7IGVkaXRhYmxlIH0pO1xuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyLCBhcHBlbmRlZFRyYW5zYWN0aW9uczogW10gfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cbiAgICovXG4gIGdldCBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgZ2V0IHZpZXcoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yVmlldztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICB0aGlzLmVkaXRvclN0YXRlID0gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BhdGNoOiAodHIpID0+IHtcbiAgICAgICAgICB0aGlzLmVkaXRvclN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN0dWIgc29tZSBjb21tb25seSBhY2Nlc3NlZCBwcm9wZXJ0aWVzIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgIGNvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBnZXQ6IChvYmosIGtleSkgPT4ge1xuICAgICAgICAgIGlmIChrZXkgPT09IFwic3RhdGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQob2JqLCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgW3RpcHRhcCBlcnJvcl06IFRoZSBlZGl0b3IgdmlldyBpcyBub3QgYXZhaWxhYmxlLiBDYW5ub3QgYWNjZXNzIHZpZXdbJyR7a2V5fSddLiBUaGUgZWRpdG9yIG1heSBub3QgYmUgbW91bnRlZCB5ZXQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgdGhpcy5lZGl0b3JTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yU3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXG4gICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGVcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKSA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVPclBsdWdpbktleVRvUmVtb3ZlIFRoZSBwbHVnaW5zIG5hbWVcbiAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGUgb3IgdW5kZWZpbmVkIGlmIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAqL1xuICB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHByZXZQbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgIGxldCBwbHVnaW5zID0gcHJldlBsdWdpbnM7XG4gICAgW10uY29uY2F0KG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKS5mb3JFYWNoKChuYW1lT3JQbHVnaW5LZXkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSBcInN0cmluZ1wiID8gYCR7bmFtZU9yUGx1Z2luS2V5fSRgIDogbmFtZU9yUGx1Z2luS2V5LmtleTtcbiAgICAgIHBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKTtcbiAgICB9KTtcbiAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnNcbiAgICB9KTtcbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICovXG4gIGNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IFtcbiAgICAgIEVkaXRhYmxlLFxuICAgICAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIuY29uZmlndXJlKHtcbiAgICAgICAgYmxvY2tTZXBhcmF0b3I6IChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsaXBib2FyZFRleHRTZXJpYWxpemVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYmxvY2tTZXBhcmF0b3JcbiAgICAgIH0pLFxuICAgICAgQ29tbWFuZHMsXG4gICAgICBGb2N1c0V2ZW50cyxcbiAgICAgIEtleW1hcCxcbiAgICAgIFRhYmluZGV4LFxuICAgICAgRHJvcCxcbiAgICAgIFBhc3RlLFxuICAgICAgRGVsZXRlXG4gICAgXS5maWx0ZXIoKGV4dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZV0gIT09IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkgOiBbXTtcbiAgICBjb25zdCBhbGxFeHRlbnNpb25zID0gWy4uLmNvcmVFeHRlbnNpb25zLCAuLi50aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc10uZmlsdGVyKChleHRlbnNpb24pID0+IHtcbiAgICAgIHJldHVybiBbXCJleHRlbnNpb25cIiwgXCJub2RlXCIsIFwibWFya1wiXS5pbmNsdWRlcyhleHRlbnNpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVuc2lvbi50eXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAqL1xuICBjcmVhdGVDb21tYW5kTWFuYWdlcigpIHtcbiAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcjogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igc2NoZW1hLlxuICAgKi9cbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgaW5pdGlhbCBkb2N1bWVudC5cbiAgICovXG4gIGNyZWF0ZURvYygpIHtcbiAgICBsZXQgZG9jO1xuICAgIHRyeSB7XG4gICAgICBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgRXJyb3IpIHx8ICFbXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnRcIiwgXCJbdGlwdGFwIGVycm9yXTogSW52YWxpZCBIVE1MIGNvbnRlbnRcIl0uaW5jbHVkZXMoZS5tZXNzYWdlKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiY29udGVudEVycm9yXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICBpZiAoXCJjb2xsYWJvcmF0aW9uXCIgaW4gdGhpcy5zdG9yYWdlICYmIHR5cGVvZiB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbiA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5uYW1lICE9PSBcImNvbGxhYm9yYXRpb25cIik7XG4gICAgICAgICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7XG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igdmlldy5cbiAgICovXG4gIGNyZWF0ZVZpZXcoZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmVkaXRvclZpZXcgPSBuZXcgRWRpdG9yVmlldyhlbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIGFkZCBgcm9sZT1cInRleHRib3hcImAgdG8gdGhlIGVkaXRvciBlbGVtZW50XG4gICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAuLi4oX2EgPSB0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdHRyaWJ1dGVzXG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBzdGF0ZTogdGhpcy5lZGl0b3JTdGF0ZVxuICAgIH0pO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIucGx1Z2luc1xuICAgIH0pO1xuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG4gICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICB0aGlzLnByZXBlbmRDbGFzcygpO1xuICAgIHRoaXMuaW5qZWN0Q1NTKCk7XG4gICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICBkb20uZWRpdG9yID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbGwgbm9kZSBhbmQgbWFyayB2aWV3cy5cbiAgICovXG4gIGNyZWF0ZU5vZGVWaWV3cygpIHtcbiAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICBtYXJrVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5tYXJrVmlld3MsXG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3NcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZCBjbGFzcyBuYW1lIHRvIGVsZW1lbnQuXG4gICAqL1xuICBwcmVwZW5kQ2xhc3MoKSB7XG4gICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YDtcbiAgfVxuICBjYXB0dXJlVHJhbnNhY3Rpb24oZm4pIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgIGZuKCk7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb247XG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICByZXR1cm4gdHI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgIGNvbnN0IHJvb3RUcldhc0FwcGxpZWQgPSB0cmFuc2FjdGlvbnMuaW5jbHVkZXModHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5lbWl0KFwiYmVmb3JlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBuZXh0U3RhdGU6IHN0YXRlXG4gICAgfSk7XG4gICAgaWYgKCFyb290VHJXYXNBcHBsaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgdGhpcy5lbWl0KFwidHJhbnNhY3Rpb25cIiwge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBhcHBlbmRlZFRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnNsaWNlKDEpXG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbkhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChcInNlbGVjdGlvblVwZGF0ZVwiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtb3N0UmVjZW50Rm9jdXNUciA9IHRyYW5zYWN0aW9ucy5maW5kTGFzdCgodHIpID0+IHRyLmdldE1ldGEoXCJmb2N1c1wiKSB8fCB0ci5nZXRNZXRhKFwiYmx1clwiKSk7XG4gICAgY29uc3QgZm9jdXMyID0gbW9zdFJlY2VudEZvY3VzVHIgPT0gbnVsbCA/IHZvaWQgMCA6IG1vc3RSZWNlbnRGb2N1c1RyLmdldE1ldGEoXCJmb2N1c1wiKTtcbiAgICBjb25zdCBibHVyMiA9IG1vc3RSZWNlbnRGb2N1c1RyID09IG51bGwgPyB2b2lkIDAgOiBtb3N0UmVjZW50Rm9jdXNUci5nZXRNZXRhKFwiYmx1clwiKTtcbiAgICBpZiAoZm9jdXMyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJmb2N1c1wiLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGZvY3VzMi5ldmVudCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdHJhbnNhY3Rpb246IG1vc3RSZWNlbnRGb2N1c1RyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsdXIyKSB7XG4gICAgICB0aGlzLmVtaXQoXCJibHVyXCIsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogYmx1cjIuZXZlbnQsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uOiBtb3N0UmVjZW50Rm9jdXNUclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi5nZXRNZXRhKFwicHJldmVudFVwZGF0ZVwiKSB8fCAhdHJhbnNhY3Rpb25zLnNvbWUoKHRyKSA9PiB0ci5kb2NDaGFuZ2VkKSB8fCBwcmV2U3RhdGUuZG9jLmVxKHN0YXRlLmRvYykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5zbGljZSgxKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZSkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpO1xuICB9XG4gIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gXCJzdHJpbmdcIiA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gXCJzdHJpbmdcIiA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEpTT04uXG4gICAqL1xuICBnZXRKU09OKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy50b0pTT04oKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBIVE1MLlxuICAgKi9cbiAgZ2V0SFRNTCgpIHtcbiAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIGdldFRleHQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSBcIlxcblxcblwiLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xuICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgIC4uLnRleHRTZXJpYWxpemVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTm9kZUVtcHR5KHRoaXMuc3RhdGUuZG9jKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZWRpdG9yLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIHRoaXMudW5tb3VudCgpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAqL1xuICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5lZGl0b3JWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNEZXN0cm95ZWQpICE9IG51bGwgPyBfYiA6IHRydWU7XG4gIH1cbiAgJG5vZGUoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLiRkb2MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSkgfHwgbnVsbDtcbiAgfVxuICAkbm9kZXMoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLiRkb2MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSkgfHwgbnVsbDtcbiAgfVxuICAkcG9zKHBvcykge1xuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMpO1xuICB9XG4gIGdldCAkZG9jKCkge1xuICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XG4gIH1cbn07XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL21hcmtJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIG1hcmtJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKS5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKCh0eXBlKSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XG4gICAgICAgIH0pLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL25vZGVJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBzdGFydCA9IHJhbmdlLmZyb207XG4gICAgICBsZXQgZW5kID0gcmFuZ2UudG87XG4gICAgICBjb25zdCBuZXdOb2RlID0gY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldDtcbiAgICAgICAgaWYgKG1hdGNoU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IG1hdGNoU3RhcnQgKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXTtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dChsYXN0Q2hhciwgc3RhcnQgKyBtYXRjaFswXS5sZW5ndGggLSAxKTtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0pIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxO1xuICAgICAgICB0ci5pbnNlcnQoaW5zZXJ0aW9uU3RhcnQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSkuZGVsZXRlKHRyLm1hcHBpbmcubWFwKHN0YXJ0KSwgdHIubWFwcGluZy5tYXAoZW5kKSk7XG4gICAgICB9XG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9pbnB1dFJ1bGVzL3RleHRibG9ja1R5cGVJbnB1dFJ1bGUudHNcbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCkgfHwge307XG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bykuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy90ZXh0SW5wdXRSdWxlLnRzXG5mdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5wdXRSdWxlcy93cmFwcGluZ0lucHV0UnVsZS50c1xuaW1wb3J0IHsgY2FuSm9pbiBhcyBjYW5Kb2luMiwgZmluZFdyYXBwaW5nIH0gZnJvbSBcIkB0aXB0YXAvcG0vdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKTtcbiAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyLndyYXAoYmxvY2tSYW5nZSwgd3JhcHBpbmcpO1xuICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09IFwiYnVsbGV0TGlzdFwiIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09IFwib3JkZXJlZExpc3RcIiA/IFwibGlzdEl0ZW1cIiA6IFwidGFza0xpc3RcIjtcbiAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlO1xuICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgY2FuSm9pbjIodHIuZG9jLCByYW5nZS5mcm9tIC0gMSkgJiYgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpIHtcbiAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2pzeC1ydW50aW1lLnRzXG5mdW5jdGlvbiBGcmFnbWVudDYocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxudmFyIGggPSAodGFnLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGlmICh0YWcgPT09IFwic2xvdFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRhZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRhZyhhdHRyaWJ1dGVzKTtcbiAgfVxuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBhdHRyaWJ1dGVzICE9IG51bGwgPyBhdHRyaWJ1dGVzIDoge307XG4gIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVkcgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEpTWCBzeW50YXgsIHVzZSB0aGUgYXJyYXkgc3ludGF4IGluc3RlYWRcIik7XG4gIH1cbiAgcmV0dXJuIFt0YWcsIHJlc3QsIGNoaWxkcmVuXTtcbn07XG5cbi8vIHNyYy91dGlsaXRpZXMvY2FuSW5zZXJ0Tm9kZS50c1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiBhcyBOb2RlU2VsZWN0aW9uNCB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5mdW5jdGlvbiBjYW5JbnNlcnROb2RlKHN0YXRlLCBub2RlVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gIGNvbnN0IHsgJGZyb20gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb240KSB7XG4gICAgY29uc3QgaW5kZXggPSAkZnJvbS5pbmRleCgpO1xuICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLnBhcmVudDtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgfVxuICBsZXQgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgd2hpbGUgKGRlcHRoID49IDApIHtcbiAgICBjb25zdCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKTtcbiAgICBjb25zdCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBjb25zdCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbmRleCk7XG4gICAgaWYgKG1hdGNoLm1hdGNoVHlwZShub2RlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZXB0aCAtPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL3V0aWxpdGllcy9lc2NhcGVGb3JSZWdFeC50c1xuZnVuY3Rpb24gZXNjYXBlRm9yUmVnRXgoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8vIHNyYy91dGlsaXRpZXMvaXNTdHJpbmcudHNcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9NYXJrVmlldy50c1xuZnVuY3Rpb24gdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzKGNoZWNrTWFyaywgZWRpdG9yLCBhdHRycyA9IHt9KSB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgY29uc3QgeyBkb2MsIHRyIH0gPSBzdGF0ZTtcbiAgY29uc3QgdGhpc01hcmsgPSBjaGVja01hcms7XG4gIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgY29uc3QgZnJvbSA9IHRyLm1hcHBpbmcubWFwKHBvcyk7XG4gICAgY29uc3QgdG8gPSB0ci5tYXBwaW5nLm1hcChwb3MpICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBsZXQgZm91bmRNYXJrID0gbnVsbDtcbiAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgIGlmIChtYXJrICE9PSB0aGlzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3VuZE1hcmsgPSBtYXJrO1xuICAgIH0pO1xuICAgIGlmICghZm91bmRNYXJrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoYXR0cnNba10gIT09IGZvdW5kTWFyay5hdHRyc1trXSkge1xuICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICBjb25zdCB1cGRhdGVkTWFyayA9IGNoZWNrTWFyay50eXBlLmNyZWF0ZSh7XG4gICAgICAgIC4uLmNoZWNrTWFyay5hdHRycyxcbiAgICAgICAgLi4uYXR0cnNcbiAgICAgIH0pO1xuICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgY2hlY2tNYXJrLnR5cGUpO1xuICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgdXBkYXRlZE1hcmspO1xuICAgIH1cbiAgfSk7XG4gIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICB9XG59XG52YXIgTWFya1ZpZXcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm1hcmsgPSBwcm9wcy5tYXJrO1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbTtcbiAgfVxuICBnZXQgY29udGVudERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrIGluIHRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIGF0dHJzIFRoZSBhdHRyaWJ1dGVzIHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMsIGNoZWNrTWFyaykge1xuICAgIHVwZGF0ZU1hcmtWaWV3QXR0cmlidXRlcyhjaGVja01hcmsgfHwgdGhpcy5tYXJrLCB0aGlzLmVkaXRvciwgYXR0cnMpO1xuICB9XG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSAmJiBtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFsuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLCAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyldO1xuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9Ob2RlLnRzXG52YXIgTm9kZTMgPSBjbGFzcyBfTm9kZSBleHRlbmRzIEV4dGVuZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibm9kZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gY29uZmlnIC0gTm9kZSBjb25maWd1cmF0aW9uIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcoKSA6IGNvbmZpZztcbiAgICByZXR1cm4gbmV3IF9Ob2RlKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cbiAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb25maWcgPSB0eXBlb2YgZXh0ZW5kZWRDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IGV4dGVuZGVkQ29uZmlnKCkgOiBleHRlbmRlZENvbmZpZztcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKHJlc29sdmVkQ29uZmlnKTtcbiAgfVxufTtcblxuLy8gc3JjL05vZGVWaWV3LnRzXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb241IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBOb2RlVmlldyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHN0b3BFdmVudDogbnVsbCxcbiAgICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb247XG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICB0aGlzLmRlY29yYXRpb25zID0gcHJvcHMuZGVjb3JhdGlvbnM7XG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gcHJvcHMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlcztcbiAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvcztcbiAgICB0aGlzLm1vdW50KCk7XG4gIH1cbiAgbW91bnQoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBkb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoXCJbZGF0YS1kcmFnLWhhbmRsZV1cIikgOiB0YXJnZXQuY2xvc2VzdChcIltkYXRhLWRyYWctaGFuZGxlXVwiKTtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9IChfZCA9IGV2ZW50Lm9mZnNldFgpICE9IG51bGwgPyBfZCA6IChfYyA9IGV2ZW50Lm5hdGl2ZUV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Mub2Zmc2V0WDtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAoX2YgPSBldmVudC5vZmZzZXRZKSAhPSBudWxsID8gX2YgOiAoX2UgPSBldmVudC5uYXRpdmVFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9mZnNldFk7XG4gICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFg7XG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFk7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgKF9nID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2cuc2V0RHJhZ0ltYWdlKGNsb25lZE5vZGUsIHgsIHkpO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgaWYgKHR5cGVvZiBwb3MgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbjUuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBwb3MpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhKChfYSA9IHRoaXMuY29udGVudERPTSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJkcmFnXCIpO1xuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJkcm9wXCI7XG4gICAgY29uc3QgaXNJbnB1dCA9IFtcIklOUFVUXCIsIFwiQlVUVE9OXCIsIFwiU0VMRUNUXCIsIFwiVEVYVEFSRUFcIl0uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvcjtcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb241LmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJjb3B5XCI7XG4gICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiO1xuICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSBcImN1dFwiO1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09IFwibW91c2Vkb3duXCI7XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kb20pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtZHJhZy1oYW5kbGVdXCIpO1xuICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSk7XG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBcImRyYWdlbmRcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJkcm9wXCIsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwibW91c2V1cFwiLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRHJhZ2dpbmcgfHwgaXNEcm9wRXZlbnQgfHwgaXNDb3B5RXZlbnQgfHwgaXNQYXN0ZUV2ZW50IHx8IGlzQ3V0RXZlbnQgfHwgaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGVkaXRvciBzaG91bGQgcmUtcmVhZCB0aGUgc2VsZWN0aW9uIG9yIHJlLXBhcnNlIHRoZSByYW5nZSBhcm91bmQgdGhlIG11dGF0aW9uXG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGl0IGNhbiBzYWZlbHkgYmUgaWdub3JlZC5cbiAgICovXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSwgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpXTtcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHByb3NlbWlycm9yIG5vZGUuXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdm9pZCAwLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgKi9cbiAgZGVsZXRlTm9kZSgpIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKTtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXN0ZVJ1bGVzL21hcmtQYXN0ZVJ1bGUudHNcbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBwYXN0ZUV2ZW50IH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHZvaWQgMCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XG4gICAgICBsZXQgbWFya0VuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYykuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcbiAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCgodHlwZSkgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICB9KS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcGFzdGVSdWxlcy9ub2RlUGFzdGVSdWxlLnRzXG5mdW5jdGlvbiBub2RlUGFzdGVSdWxlKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQgfSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdm9pZCAwLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRDb250ZW50LCB2b2lkIDAsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgbm9kZS5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Bhc3RlUnVsZXMvdGV4dFBhc3RlUnVsZS50c1xuZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL1RyYWNrZXIudHNcbnZhciBUcmFja2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gIH1cbiAgbWFwKHBvc2l0aW9uKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMuc2xpY2UodGhpcy5jdXJyZW50U3RlcCkucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pO1xuICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgfSwgcG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkXG4gICAgfTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIENvbW1hbmRNYW5hZ2VyLFxuICBFZGl0b3IsXG4gIEV4dGVuc2lvbixcbiAgRnJhZ21lbnQ2IGFzIEZyYWdtZW50LFxuICBJbnB1dFJ1bGUsXG4gIE1hcmssXG4gIE1hcmtWaWV3LFxuICBOb2RlMyBhcyBOb2RlLFxuICBOb2RlUG9zLFxuICBOb2RlVmlldyxcbiAgUGFzdGVSdWxlLFxuICBUcmFja2VyLFxuICBjYWxsT3JSZXR1cm4sXG4gIGNhbkluc2VydE5vZGUsXG4gIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLFxuICBjcmVhdGVDaGFpbmFibGVTdGF0ZSxcbiAgY3JlYXRlRG9jdW1lbnQsXG4gIGggYXMgY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlTm9kZUZyb21Db250ZW50LFxuICBjcmVhdGVTdHlsZVRhZyxcbiAgZGVmYXVsdEJsb2NrQXQsXG4gIGRlbGV0ZVByb3BzLFxuICBlbGVtZW50RnJvbVN0cmluZyxcbiAgZXNjYXBlRm9yUmVnRXgsXG4gIGV4dGVuc2lvbnNfZXhwb3J0cyBhcyBleHRlbnNpb25zLFxuICBmaW5kQ2hpbGRyZW4sXG4gIGZpbmRDaGlsZHJlbkluUmFuZ2UsXG4gIGZpbmREdXBsaWNhdGVzLFxuICBmaW5kUGFyZW50Tm9kZSxcbiAgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MsXG4gIGZsYXR0ZW5FeHRlbnNpb25zLFxuICBmcm9tU3RyaW5nLFxuICBnZW5lcmF0ZUhUTUwsXG4gIGdlbmVyYXRlSlNPTixcbiAgZ2VuZXJhdGVUZXh0LFxuICBnZXRBdHRyaWJ1dGVzLFxuICBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMsXG4gIGdldENoYW5nZWRSYW5nZXMsXG4gIGdldERlYnVnSlNPTixcbiAgZ2V0RXh0ZW5zaW9uRmllbGQsXG4gIGdldEhUTUxGcm9tRnJhZ21lbnQsXG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBnZXRNYXJrUmFuZ2UsXG4gIGdldE1hcmtUeXBlLFxuICBnZXRNYXJrc0JldHdlZW4sXG4gIGdldE5vZGVBdFBvc2l0aW9uLFxuICBnZXROb2RlQXR0cmlidXRlcyxcbiAgZ2V0Tm9kZVR5cGUsXG4gIGdldFJlbmRlcmVkQXR0cmlidXRlcyxcbiAgZ2V0U2NoZW1hLFxuICBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyxcbiAgZ2V0U2NoZW1hVHlwZUJ5TmFtZSxcbiAgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUsXG4gIGdldFNwbGl0dGVkQXR0cmlidXRlcyxcbiAgZ2V0VGV4dCxcbiAgZ2V0VGV4dEJldHdlZW4sXG4gIGdldFRleHRDb250ZW50RnJvbU5vZGVzLFxuICBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLFxuICBoLFxuICBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsXG4gIGlucHV0UnVsZXNQbHVnaW4sXG4gIGlzQWN0aXZlLFxuICBpc0FuZHJvaWQsXG4gIGlzQXRFbmRPZk5vZGUsXG4gIGlzQXRTdGFydE9mTm9kZSxcbiAgaXNFbXB0eU9iamVjdCxcbiAgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzTGlzdCxcbiAgaXNNYWNPUyxcbiAgaXNNYXJrQWN0aXZlLFxuICBpc05vZGVBY3RpdmUsXG4gIGlzTm9kZUVtcHR5LFxuICBpc05vZGVTZWxlY3Rpb24sXG4gIGlzTnVtYmVyLFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1JlZ0V4cCxcbiAgaXNTdHJpbmcsXG4gIGlzVGV4dFNlbGVjdGlvbixcbiAgaXNpT1MsXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbiAgbWVyZ2VEZWVwLFxuICBtaW5NYXgsXG4gIG5vZGVJbnB1dFJ1bGUsXG4gIG5vZGVQYXN0ZVJ1bGUsXG4gIG9iamVjdEluY2x1ZGVzLFxuICBwYXN0ZVJ1bGVzUGx1Z2luLFxuICBwb3NUb0RPTVJlY3QsXG4gIHJlbW92ZUR1cGxpY2F0ZXMsXG4gIHJlc29sdmVFeHRlbnNpb25zLFxuICByZXNvbHZlRm9jdXNQb3NpdGlvbixcbiAgcmV3cml0ZVVua25vd25Db250ZW50LFxuICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCxcbiAgc29ydEV4dGVuc2lvbnMsXG4gIHNwbGl0RXh0ZW5zaW9ucyxcbiAgdGV4dElucHV0UnVsZSxcbiAgdGV4dFBhc3RlUnVsZSxcbiAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSxcbiAgdXBkYXRlTWFya1ZpZXdBdHRyaWJ1dGVzLFxuICB3cmFwcGluZ0lucHV0UnVsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   createElement: () => (/* binding */ h),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   jsx: () => (/* binding */ h),\n/* harmony export */   jsxDEV: () => (/* binding */ h),\n/* harmony export */   jsxs: () => (/* binding */ h)\n/* harmony export */ });\n// src/jsx-runtime.ts\nfunction Fragment(props) {\n  return props.children;\n}\nvar h = (tag, attributes) => {\n  if (tag === \"slot\") {\n    return 0;\n  }\n  if (tag instanceof Function) {\n    return tag(attributes);\n  }\n  const { children, ...rest } = attributes != null ? attributes : {};\n  if (tag === \"svg\") {\n    throw new Error(\"SVG elements are not supported in the JSX syntax, use the array syntax instead\");\n  }\n  return [tag, rest, children];\n};\n\n//# sourceMappingURL=jsx-runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvanN4LXJ1bnRpbWUvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9kaXN0L2pzeC1ydW50aW1lL2pzeC1ydW50aW1lLmpzPzdjY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2pzeC1ydW50aW1lLnRzXG5mdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG52YXIgaCA9ICh0YWcsIGF0dHJpYnV0ZXMpID0+IHtcbiAgaWYgKHRhZyA9PT0gXCJzbG90XCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGFnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdGFnKGF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IGF0dHJpYnV0ZXMgIT0gbnVsbCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgaWYgKHRhZyA9PT0gXCJzdmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNWRyBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgSlNYIHN5bnRheCwgdXNlIHRoZSBhcnJheSBzeW50YXggaW5zdGVhZFwiKTtcbiAgfVxuICByZXR1cm4gW3RhZywgcmVzdCwgY2hpbGRyZW5dO1xufTtcbmV4cG9ydCB7XG4gIEZyYWdtZW50LFxuICBoIGFzIGNyZWF0ZUVsZW1lbnQsXG4gIGgsXG4gIGggYXMganN4LFxuICBoIGFzIGpzeERFVixcbiAgaCBhcyBqc3hzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4LXJ1bnRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/blockquote.tsx\n\n\nvar inputRegex = /^\\s*>\\s$/;\nvar Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"blockquote\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"block+\",\n  group: \"block\",\n  defining: true,\n  parseHTML() {\n    return [{ tag: \"blockquote\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn(this.name);\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap(this.name);\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-b\": () => this.editor.commands.toggleBlockquote()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Blockquote;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0U7QUFDekI7QUFDL0M7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQiwyQkFBMkIsNkRBQUcsaUJBQWlCLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUMzSixHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsT0FBTztBQUNQLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwrREFBaUI7QUFDdkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL2Rpc3QvaW5kZXguanM/OGU5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYmxvY2txdW90ZS50c3hcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwiQHRpcHRhcC9jb3JlL2pzeC1ydW50aW1lXCI7XG52YXIgaW5wdXRSZWdleCA9IC9eXFxzKj5cXHMkLztcbnZhciBCbG9ja3F1b3RlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrcXVvdGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgY29udGVudDogXCJibG9jaytcIixcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJsb2NrcXVvdGVcIiB9XTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImJsb2NrcXVvdGVcIiwgeyAuLi5tZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic2xvdFwiLCB7fSkgfSk7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVXcmFwKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LWJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQmxvY2txdW90ZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBCbG9ja3F1b3RlO1xuZXhwb3J0IHtcbiAgQmxvY2txdW90ZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBpbnB1dFJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core/jsx-runtime */ \"(ssr)/./node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js\");\n// src/bold.tsx\n\n\nvar starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\nvar underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\nvar Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"bold\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"strong\"\n      },\n      {\n        tag: \"b\",\n        getAttrs: (node) => node.style.fontWeight !== \"normal\" && null\n      },\n      {\n        style: \"font-weight=400\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-weight\",\n        getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", { ...(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ (0,_tiptap_core_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"slot\", {}) });\n  },\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-b\": () => this.editor.commands.toggleBold(),\n      \"Mod-B\": () => this.editor.commands.toggleBold()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Bold;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDcEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLDJCQUEyQiw2REFBRyxhQUFhLEdBQUcsNkRBQWUseUVBQXlFLDZEQUFHLFdBQVcsR0FBRztBQUN2SixHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz8yZGM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ib2xkLnRzeFxuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcIkB0aXB0YXAvY29yZS9qc3gtcnVudGltZVwiO1xudmFyIHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC87XG52YXIgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkvZztcbnZhciB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XG52YXIgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nO1xudmFyIEJvbGQgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYm9sZFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cm9uZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiYlwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIiAmJiBudWxsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJmb250LXdlaWdodD00MDBcIixcbiAgICAgICAgY2xlYXJNYXJrOiAobWFyaykgPT4gbWFyay50eXBlLm5hbWUgPT09IHRoaXMubmFtZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IFwiZm9udC13ZWlnaHRcIixcbiAgICAgICAgZ2V0QXR0cnM6ICh2YWx1ZSkgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInN0cm9uZ1wiLCB7IC4uLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzbG90XCIsIHt9KSB9KTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICBcIk1vZC1CXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gQm9sZDtcbmV4cG9ydCB7XG4gIEJvbGQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgc3RhcklucHV0UmVnZXgsXG4gIHN0YXJQYXN0ZVJlZ2V4LFxuICB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgdW5kZXJzY29yZVBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/code-block.ts\n\n\nvar backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nvar tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nvar CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"codeBlock\",\n  addOptions() {\n    return {\n      languageClassPrefix: \"language-\",\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      HTMLAttributes: {}\n    };\n  },\n  content: \"text*\",\n  marks: \"\",\n  group: \"block\",\n  code: true,\n  defining: true,\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: (element) => {\n          var _a;\n          const { languageClassPrefix } = this.options;\n          const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];\n          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, \"\"));\n          const language = languages[0];\n          if (!language) {\n            return null;\n          }\n          return language;\n        },\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"pre\",\n        preserveWhitespace: \"full\"\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"pre\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        \"code\",\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n        },\n        0\n      ]\n    ];\n  },\n  addCommands() {\n    return {\n      setCodeBlock: (attributes) => ({ commands }) => {\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: (attributes) => ({ commands }) => {\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-c\": () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n        return false;\n      },\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n        return editor.chain().command(({ tr }) => {\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection, doc } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        if (!isAtEnd) {\n          return false;\n        }\n        const after = $from.after();\n        if (after === void 0) {\n          return false;\n        }\n        const nodeAfter = doc.nodeAt(after);\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n            return true;\n          });\n        }\n        return editor.commands.exitCode();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false;\n            }\n            if (this.editor.isActive(this.type.name)) {\n              return false;\n            }\n            const text = event.clipboardData.getData(\"text/plain\");\n            const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n            const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n            const language = vscodeData == null ? void 0 : vscodeData.mode;\n            if (!text || !language) {\n              return false;\n            }\n            const { tr, schema } = view.state;\n            const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n            tr.replaceSelectionWith(this.type.create({ language }, textNode));\n            if (tr.selection.$from.parent.type !== this.type) {\n              tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n            }\n            tr.setMeta(\"paste\", true);\n            view.dispatch(tr);\n            return true;\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = CodeBlock;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzZFO0FBQ0U7QUFDL0U7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNLDZEQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQsNEJBQTRCLHVEQUFTO0FBQ3JDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLG9FQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTSxvRUFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBTTtBQUNoQixpQkFBaUIsdURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSx1REFBdUQsVUFBVTtBQUNqRTtBQUNBLDhCQUE4QiwyREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzP2FmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGUtYmxvY2sudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kLztcbnZhciB0aWxkZUlucHV0UmVnZXggPSAvXn5+fihbYS16XSspP1tcXHNcXG5dJC87XG52YXIgQ29kZUJsb2NrID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImNvZGVCbG9ja1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZUNsYXNzUHJlZml4OiBcImxhbmd1YWdlLVwiLFxuICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICBkZWZhdWx0TGFuZ3VhZ2U6IG51bGwsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcInRleHQqXCIsXG4gIG1hcmtzOiBcIlwiLFxuICBncm91cDogXCJibG9ja1wiLFxuICBjb2RlOiB0cnVlLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRMYW5ndWFnZSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWy4uLigoX2EgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0KSB8fCBbXV07XG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lcy5maWx0ZXIoKGNsYXNzTmFtZSkgPT4gY2xhc3NOYW1lLnN0YXJ0c1dpdGgobGFuZ3VhZ2VDbGFzc1ByZWZpeCkpLm1hcCgoY2xhc3NOYW1lKSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCBcIlwiKSk7XG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF07XG4gICAgICAgICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJwcmVcIixcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiBcImZ1bGxcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwicHJlXCIsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICBbXG4gICAgICAgIFwiY29kZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2UgPyB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCArIG5vZGUuYXR0cnMubGFuZ3VhZ2UgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICAgIF1cbiAgICBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZUJsb2NrOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGVCbG9jazogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCBcInBhcmFncmFwaFwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtQWx0LWNcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG4gICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQXRTdGFydCA9ICRhbmNob3IucG9zID09PSAxO1xuICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0F0U3RhcnQgfHwgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIGV4aXQgbm9kZSBvbiB0cmlwbGUgZW50ZXJcbiAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aChcIlxcblxcblwiKTtcbiAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MgLSAyLCAkZnJvbS5wb3MpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5leGl0Q29kZSgpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXG4gICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMjtcbiAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFmdGVyID0gJGZyb20uYWZ0ZXIoKTtcbiAgICAgICAgaWYgKGFmdGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcik7XG4gICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKGRvYy5yZXNvbHZlKGFmdGVyKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoe1xuICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyB0aGlzIHBsdWdpbiBjcmVhdGVzIGEgY29kZSBibG9jayBmb3IgcGFzdGVkIGNvbnRlbnQgZnJvbSBWUyBDb2RlXG4gICAgICAvLyB3ZSBjYW4gYWxzbyBkZXRlY3QgdGhlIGNvcGllZCBjb2RlIGxhbmd1YWdlXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KFwiY29kZUJsb2NrVlNDb2RlSGFuZGxlclwiKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzQWN0aXZlKHRoaXMudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInZzY29kZS1lZGl0b3ItZGF0YVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZURhdGEgPSB2c2NvZGUgPyBKU09OLnBhcnNlKHZzY29kZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IHZzY29kZURhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHZzY29kZURhdGEubW9kZTtcbiAgICAgICAgICAgIGlmICghdGV4dCB8fCAhbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciwgc2NoZW1hIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBzY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpO1xuICAgICAgICAgICAgdHIucmVwbGFjZVNlbGVjdGlvbldpdGgodGhpcy50eXBlLmNyZWF0ZSh7IGxhbmd1YWdlIH0sIHRleHROb2RlKSk7XG4gICAgICAgICAgICBpZiAodHIuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCB0ci5zZWxlY3Rpb24uZnJvbSAtIDIpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBDb2RlQmxvY2s7XG5leHBvcnQge1xuICBDb2RlQmxvY2ssXG4gIGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICB0aWxkZUlucHV0UmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/code.ts\n\nvar inputRegex = /(^|[^`])`([^`]+)`(?!`)/;\nvar pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\nvar Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"code\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  excludes: \"_\",\n  code: true,\n  exitable: true,\n  parseHTML() {\n    return [{ tag: \"code\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"code\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setCode: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleCode: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetCode: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-e\": () => this.editor.commands.toggleCode()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Code;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDbUY7QUFDbkY7QUFDQTtBQUNBLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixvQkFBb0IsNkRBQWU7QUFDbkMsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBLE9BQU87QUFDUCwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLE9BQU87QUFDUCwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvZGlzdC9pbmRleC5qcz8wMTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb2RlLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgaW5wdXRSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApLztcbnZhciBwYXN0ZVJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvZztcbnZhciBDb2RlID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcImNvZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgZXhjbHVkZXM6IFwiX1wiLFxuICBjb2RlOiB0cnVlLFxuICBleGl0YWJsZTogdHJ1ZSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwiY29kZVwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJjb2RlXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLWVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gQ29kZTtcbmV4cG9ydCB7XG4gIENvZGUsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgaW5wdXRSZWdleCxcbiAgcGFzdGVSZWdleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/document.ts\n\nvar Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"block+\"\n});\n\n// src/index.ts\nvar index_default = Document;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvQztBQUNwQyxlQUFlLDhDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcz8wN2U1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kb2N1bWVudC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJkb2NcIixcbiAgdG9wTm9kZTogdHJ1ZSxcbiAgY29udGVudDogXCJibG9jaytcIlxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBEb2N1bWVudDtcbmV4cG9ydCB7XG4gIERvY3VtZW50LFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/hard-break.ts\n\nvar HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"hardBreak\",\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {}\n    };\n  },\n  inline: true,\n  group: \"inline\",\n  selectable: false,\n  linebreakReplacement: true,\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  renderText() {\n    return \"\\n\";\n  },\n  addCommands() {\n    return {\n      setHardBreak: () => ({ commands, chain, state, editor }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state;\n            if (selection.$from.parent.type.spec.isolating) {\n              return false;\n            }\n            const { keepMarks } = this.options;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {\n              if (dispatch && marks && keepMarks) {\n                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n                tr.ensureMarks(filteredMarks);\n              }\n              return true;\n            }).run();\n          })\n        ]);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Enter\": () => this.editor.commands.setHardBreak(),\n      \"Shift-Enter\": () => this.editor.commands.setHardBreak()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = HardBreak;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3FEO0FBQ3JELGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLDJDQUEyQyxpQkFBaUIsYUFBYSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWsvZGlzdC9pbmRleC5qcz9jODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oYXJkLWJyZWFrLnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhhcmRCcmVha1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBpbmxpbmU6IHRydWUsXG4gIGdyb3VwOiBcImlubGluZVwiLFxuICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImJyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImJyXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gIH0sXG4gIHJlbmRlclRleHQoKSB7XG4gICAgcmV0dXJuIFwiXFxuXCI7XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiwgc3RhdGUsIGVkaXRvciB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5maXJzdChbXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsga2VlcE1hcmtzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluKCkuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KS5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pLnJ1bigpO1xuICAgICAgICAgIH0pXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1FbnRlclwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgIFwiU2hpZnQtRW50ZXJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKClcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhhcmRCcmVhaztcbmV4cG9ydCB7XG4gIEhhcmRCcmVhayxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/heading.ts\n\nvar Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"heading\",\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {}\n    };\n  },\n  content: \"inline*\",\n  group: \"block\",\n  defining: true,\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return this.options.levels.map((level) => ({\n      tag: `h${level}`,\n      attrs: { level }\n    }));\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level);\n    const level = hasLevel ? node.attrs.level : this.options.levels[0];\n    return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.setNode(this.name, attributes);\n      },\n      toggleHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })\n        }\n      }),\n      {}\n    );\n  },\n  addInputRules() {\n    return this.options.levels.map((level) => {\n      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level\n        }\n      });\n    });\n  }\n});\n\n// src/index.ts\nvar index_default = Heading;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQzZFO0FBQzdFLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0gsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixNQUFNLEdBQUcsNkRBQWU7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLCtDQUErQyxPQUFPO0FBQ2xGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsb0VBQXNCO0FBQ25DLDhCQUE4QixFQUFFLGlDQUFpQyxHQUFHLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nL2Rpc3QvaW5kZXguanM/MjIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVhZGluZy50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIEhlYWRpbmcgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaGVhZGluZ1wiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja1wiLFxuICBkZWZpbmluZzogdHJ1ZSxcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcCgobGV2ZWwpID0+ICh7XG4gICAgICB0YWc6IGBoJHtsZXZlbH1gLFxuICAgICAgYXR0cnM6IHsgbGV2ZWwgfVxuICAgIH0pKTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCBoYXNMZXZlbCA9IHRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMobm9kZS5hdHRycy5sZXZlbCk7XG4gICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbCA/IG5vZGUuYXR0cnMubGV2ZWwgOiB0aGlzLm9wdGlvbnMubGV2ZWxzWzBdO1xuICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIZWFkaW5nOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkaW5nOiAoYXR0cmlidXRlcykgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCBcInBhcmFncmFwaFwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5yZWR1Y2UoXG4gICAgICAoaXRlbXMsIGxldmVsKSA9PiAoe1xuICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIFtgTW9kLUFsdC0ke2xldmVsfWBdOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVIZWFkaW5nKHsgbGV2ZWwgfSlcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKChsZXZlbCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKGBeKCN7JHtNYXRoLm1pbiguLi50aGlzLm9wdGlvbnMubGV2ZWxzKX0sJHtsZXZlbH19KVxcXFxzJGApLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBsZXZlbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGluZGV4X2RlZmF1bHQgPSBIZWFkaW5nO1xuZXhwb3J0IHtcbiAgSGVhZGluZyxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/horizontal-rule.ts\n\n\nvar HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [{ tag: \"hr\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"hr\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain, state }) => {\n        if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const { selection } = state;\n        const { $to: $originTo } = selection;\n        const currentChain = chain();\n        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({ type: this.name });\n        }\n        return currentChain.command(({ tr, dispatch }) => {\n          var _a;\n          if (dispatch) {\n            const { $to } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              const node = (_a = $to.parent.type.contentMatch.defaultType) == null ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n        find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = HorizontalRule;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ29HO0FBQ3BDO0FBQ2hFLHFCQUFxQiw4Q0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLGtCQUFrQiw2REFBZTtBQUNqQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELGFBQWEsMkRBQWE7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxZQUFZLDZEQUFlO0FBQzNCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFhO0FBQzdDLGdCQUFnQjtBQUNoQixnQ0FBZ0MsMkRBQWE7QUFDN0MsZ0JBQWdCO0FBQ2hCLGdDQUFnQywyREFBYTtBQUM3QztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanM/ODdmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaG9yaXpvbnRhbC1ydWxlLnRzXG5pbXBvcnQgeyBjYW5JbnNlcnROb2RlLCBpc05vZGVTZWxlY3Rpb24sIG1lcmdlQXR0cmlidXRlcywgTm9kZSwgbm9kZUlucHV0UnVsZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xudmFyIEhvcml6b250YWxSdWxlID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImhvcml6b250YWxSdWxlXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcImhyXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImhyXCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIb3Jpem9udGFsUnVsZTogKCkgPT4gKHsgY2hhaW4sIHN0YXRlIH0pID0+IHtcbiAgICAgICAgaWYgKCFjYW5JbnNlcnROb2RlKHN0YXRlLCBzdGF0ZS5zY2hlbWEubm9kZXNbdGhpcy5uYW1lXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7ICR0bzogJG9yaWdpblRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKCk7XG4gICAgICAgIGlmIChpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50QXQoJG9yaWdpblRvLnBvcywge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGFpbi5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgeyAkdG8gfSA9IHRyLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHBvc0FmdGVyID0gJHRvLmVuZCgpO1xuICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zICsgMSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0by5ub2RlQWZ0ZXIuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAoX2EgPSAkdG8ucGFyZW50LnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLnJ1bigpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IEhvcml6b250YWxSdWxlO1xuZXhwb3J0IHtcbiAgSG9yaXpvbnRhbFJ1bGUsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/italic.ts\n\nvar starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\nvar starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\nvar underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\nvar underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\nvar Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"italic\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"em\"\n      },\n      {\n        tag: \"i\",\n        getAttrs: (node) => node.style.fontStyle !== \"normal\" && null\n      },\n      {\n        style: \"font-style=normal\",\n        clearMark: (mark) => mark.type.name === this.name\n      },\n      {\n        style: \"font-style=italic\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"em\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-i\": () => this.editor.commands.toggleItalic(),\n      \"Mod-I\": () => this.editor.commands.toggleItalic()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Italic;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ21GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFlO0FBQ2pDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLDJEQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanM/MWQ5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaXRhbGljLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcbnZhciBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqKD8hXFxzK1xcKikoKD86W14qXSspKVxcKig/IVxccytcXCopKS9nO1xudmFyIHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvO1xudmFyIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xudmFyIEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJpdGFsaWNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJlbVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiaVwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuc3R5bGUuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiICYmIG51bGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9bm9ybWFsXCIsXG4gICAgICAgIGNsZWFyTWFyazogKG1hcmspID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiBcImZvbnQtc3R5bGU9aXRhbGljXCJcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJlbVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1pXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgXCJNb2QtSVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKVxuICAgIH07XG4gIH0sXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gSXRhbGljO1xuZXhwb3J0IHtcbiAgSXRhbGljLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIHN0YXJJbnB1dFJlZ2V4LFxuICBzdGFyUGFzdGVSZWdleCxcbiAgdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   isAllowedUri: () => (/* binding */ isAllowedUri),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ \"(ssr)/./node_modules/linkifyjs/dist/linkify.mjs\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n// src/link.ts\n\n\n\n// src/helpers/autolink.ts\n\n\n\n\n// src/helpers/whitespace.ts\nvar UNICODE_WHITESPACE_PATTERN = \"[\\0- \\xA0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]\";\nvar UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nvar UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nvar UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, \"g\");\n\n// src/helpers/autolink.ts\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return [\"()\", \"[]\"].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\nfunction autolink(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"autolink\"),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some((transaction) => transaction.getMeta(\"preventAutolink\"));\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const { tr } = newState;\n      const transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, [...transactions]);\n      const changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);\n      changes.forEach(({ newRange }) => {\n        const nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, (node) => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            void 0,\n            \" \"\n          );\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \");\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return;\n          }\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, \" \");\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.tokenize)(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          })).filter((link) => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {\n            if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(\n              link.from,\n              link.to,\n              options.type.create({\n                href: link.href\n              })\n            );\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\n\n// src/helpers/clickHandler.ts\n\n\nfunction clickHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handleClickLink\"),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let link = null;\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target;\n        } else {\n          let a = event.target;\n          const els = [];\n          while (a.nodeName !== \"DIV\") {\n            els.push(a);\n            a = a.parentNode;\n          }\n          link = els.find((value) => value.nodeName === \"A\");\n        }\n        if (!link) {\n          return false;\n        }\n        const attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);\n        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;\n        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;\n        if (options.enableClickSelection) {\n          options.editor.commands.extendMarkRange(options.type.name);\n        }\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\n\n// src/helpers/pasteHandler.ts\n\n\nfunction pasteHandler(options) {\n  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"handlePasteLink\"),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view;\n        const { selection } = state;\n        const { empty } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = \"\";\n        slice.content.forEach((node) => {\n          textContent += node.textContent;\n        });\n        const link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          (item) => item.isLink && item.value === textContent\n        );\n        if (!textContent || !link) {\n          return false;\n        }\n        return options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n      }\n    }\n  });\n}\n\n// src/link.ts\nvar pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = [\"http\", \"https\", \"ftp\", \"ftps\", \"mailto\", \"tel\", \"callto\", \"sms\", \"cid\", \"xmpp\"];\n  if (protocols) {\n    protocols.forEach((protocol) => {\n      const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, \"\").match(\n    new RegExp(\n      // eslint-disable-next-line no-useless-escape\n      `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,\n      \"i\"\n    )\n  );\n}\nvar Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({\n  name: \"link\",\n  priority: 1e3,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      this.options.shouldAutoLink = this.options.validate;\n      console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n    }\n    this.options.protocols.forEach((protocol) => {\n      if (typeof protocol === \"string\") {\n        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);\n        return;\n      }\n      (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: \"http\",\n      HTMLAttributes: {\n        target: \"_blank\",\n        rel: \"noopener noreferrer nofollow\",\n        class: null\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: (url) => !!url,\n      shouldAutoLink: (url) => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute(\"href\");\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"a[href]\",\n        getAttrs: (dom) => {\n          const href = dom.getAttribute(\"href\");\n          if (!href || !this.options.isAllowedUri(href, {\n            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol\n          })) {\n            return false;\n          }\n          return null;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    if (!this.options.isAllowedUri(HTMLAttributes.href, {\n      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),\n      protocols: this.options.protocols,\n      defaultProtocol: this.options.defaultProtocol\n    })) {\n      return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, { ...HTMLAttributes, href: \"\" }), 0];\n    }\n    return [\"a\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: (attributes) => ({ chain }) => {\n        const { href } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n      },\n      toggleLink: (attributes) => ({ chain }) => {\n        const { href } = attributes || {};\n        if (href && !this.options.isAllowedUri(href, {\n          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      },\n      unsetLink: () => ({ chain }) => {\n        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta(\"preventAutolink\", true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({\n        find: (text) => {\n          const foundLinks = [];\n          if (text) {\n            const { protocols, defaultProtocol } = this.options;\n            const links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter(\n              (item) => item.isLink && this.options.isAllowedUri(item.value, {\n                defaultValidate: (href) => !!isAllowedUri(href, protocols),\n                protocols,\n                defaultProtocol\n              })\n            );\n            if (links.length) {\n              links.forEach(\n                (link) => foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href\n                  },\n                  index: link.start\n                })\n              );\n            }\n          }\n          return foundLinks;\n        },\n        type: this.type,\n        getAttributes: (match) => {\n          var _a;\n          return {\n            href: (_a = match.data) == null ? void 0 : _a.href\n          };\n        }\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    const { protocols, defaultProtocol } = this.options;\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: (url) => this.options.isAllowedUri(url, {\n            defaultValidate: (href) => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol\n          }),\n          shouldAutoLink: this.options.shouldAutoLink\n        })\n      );\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n          editor: this.editor,\n          enableClickSelection: this.options.enableClickSelection\n        })\n      );\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type\n        })\n      );\n    }\n    return plugins;\n  }\n});\n\n// src/index.ts\nvar index_default = Link;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNvRTtBQUNLOztBQUV6RTtBQUMrRztBQUMxRDtBQUNoQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBTTtBQUNuQixhQUFhLHVEQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQix3QkFBd0IscUVBQXVCO0FBQy9DLHNCQUFzQiw4REFBZ0I7QUFDdEMseUJBQXlCLFVBQVU7QUFDbkMscUNBQXFDLGlFQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGdCQUFnQiw2REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzZDO0FBQ2lDO0FBQzlFO0FBQ0EsYUFBYSxvREFBTztBQUNwQixhQUFhLHVEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvZGlzdC9pbmRleC5qcz9iYWY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saW5rLnRzXG5pbXBvcnQgeyBNYXJrLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBmaW5kIGFzIGZpbmQyLCByZWdpc3RlckN1c3RvbVByb3RvY29sLCByZXNldCB9IGZyb20gXCJsaW5raWZ5anNcIjtcblxuLy8gc3JjL2hlbHBlcnMvYXV0b2xpbmsudHNcbmltcG9ydCB7IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBnZXRDaGFuZ2VkUmFuZ2VzLCBnZXRNYXJrc0JldHdlZW4gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gXCJAdGlwdGFwL3BtL3N0YXRlXCI7XG5pbXBvcnQgeyB0b2tlbml6ZSB9IGZyb20gXCJsaW5raWZ5anNcIjtcblxuLy8gc3JjL2hlbHBlcnMvd2hpdGVzcGFjZS50c1xudmFyIFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOID0gXCJbXFwwLSBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdXCI7XG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYID0gbmV3IFJlZ0V4cChVTklDT0RFX1dISVRFU1BBQ0VfUEFUVEVSTik7XG52YXIgVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0VORCA9IG5ldyBSZWdFeHAoYCR7VU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk59JGApO1xudmFyIFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9HTE9CQUwgPSBuZXcgUmVnRXhwKFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOLCBcImdcIik7XG5cbi8vIHNyYy9oZWxwZXJzL2F1dG9saW5rLnRzXG5mdW5jdGlvbiBpc1ZhbGlkTGlua1N0cnVjdHVyZSh0b2tlbnMpIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdG9rZW5zWzBdLmlzTGluaztcbiAgfVxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMyAmJiB0b2tlbnNbMV0uaXNMaW5rKSB7XG4gICAgcmV0dXJuIFtcIigpXCIsIFwiW11cIl0uaW5jbHVkZXModG9rZW5zWzBdLnZhbHVlICsgdG9rZW5zWzJdLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhdXRvbGluayhvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJhdXRvbGlua1wiKSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKSAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYyk7XG4gICAgICBjb25zdCBwcmV2ZW50QXV0b2xpbmsgPSB0cmFuc2FjdGlvbnMuc29tZSgodHJhbnNhY3Rpb24pID0+IHRyYW5zYWN0aW9uLmdldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIikpO1xuICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IHByZXZlbnRBdXRvbGluaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRyIH0gPSBuZXdTdGF0ZTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZFN0YXRlLmRvYywgWy4uLnRyYW5zYWN0aW9uc10pO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKTtcbiAgICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuZXdSYW5nZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzID0gZmluZENoaWxkcmVuSW5SYW5nZShuZXdTdGF0ZS5kb2MsIG5ld1JhbmdlLCAobm9kZSkgPT4gbm9kZS5pc1RleHRibG9jayk7XG4gICAgICAgIGxldCB0ZXh0QmxvY2s7XG4gICAgICAgIGxldCB0ZXh0QmVmb3JlV2hpdGVzcGFjZTtcbiAgICAgICAgaWYgKG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXTtcbiAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MsXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zICsgdGV4dEJsb2NrLm5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZW5kVGV4dCA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihuZXdSYW5nZS5mcm9tLCBuZXdSYW5nZS50bywgXCIgXCIsIFwiIFwiKTtcbiAgICAgICAgICBpZiAoIVVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9FTkQudGVzdChlbmRUZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXTtcbiAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2Vlbih0ZXh0QmxvY2sucG9zLCBuZXdSYW5nZS50bywgdm9pZCAwLCBcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRCbG9jayAmJiB0ZXh0QmVmb3JlV2hpdGVzcGFjZSkge1xuICAgICAgICAgIGNvbnN0IHdvcmRzQmVmb3JlV2hpdGVzcGFjZSA9IHRleHRCZWZvcmVXaGl0ZXNwYWNlLnNwbGl0KFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgIGlmICh3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGFzdFdvcmRCZWZvcmVTcGFjZSA9IHdvcmRzQmVmb3JlV2hpdGVzcGFjZVt3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIC0gMV07XG4gICAgICAgICAgY29uc3QgbGFzdFdvcmRBbmRCbG9ja09mZnNldCA9IHRleHRCbG9jay5wb3MgKyB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5sYXN0SW5kZXhPZihsYXN0V29yZEJlZm9yZVNwYWNlKTtcbiAgICAgICAgICBpZiAoIWxhc3RXb3JkQmVmb3JlU3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGlua3NCZWZvcmVTcGFjZSA9IHRva2VuaXplKGxhc3RXb3JkQmVmb3JlU3BhY2UpLm1hcCgodCkgPT4gdC50b09iamVjdChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCkpO1xuICAgICAgICAgIGlmICghaXNWYWxpZExpbmtTdHJ1Y3R1cmUobGlua3NCZWZvcmVTcGFjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlua3NCZWZvcmVTcGFjZS5maWx0ZXIoKGxpbmspID0+IGxpbmsuaXNMaW5rKS5tYXAoKGxpbmspID0+ICh7XG4gICAgICAgICAgICAuLi5saW5rLFxuICAgICAgICAgICAgZnJvbTogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuc3RhcnQgKyAxLFxuICAgICAgICAgICAgdG86IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLmVuZCArIDFcbiAgICAgICAgICB9KSkuZmlsdGVyKChsaW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFuZXdTdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGxpbmsuZnJvbSwgbGluay50bywgbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpO1xuICAgICAgICAgIH0pLmZpbHRlcigobGluaykgPT4gb3B0aW9ucy52YWxpZGF0ZShsaW5rLnZhbHVlKSkuZmlsdGVyKChsaW5rKSA9PiBvcHRpb25zLnNob3VsZEF1dG9MaW5rKGxpbmsudmFsdWUpKS5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2V0TWFya3NCZXR3ZWVuKGxpbmsuZnJvbSwgbGluay50bywgbmV3U3RhdGUuZG9jKS5zb21lKChpdGVtKSA9PiBpdGVtLm1hcmsudHlwZSA9PT0gb3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICBsaW5rLmZyb20sXG4gICAgICAgICAgICAgIGxpbmsudG8sXG4gICAgICAgICAgICAgIG9wdGlvbnMudHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHI7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2hlbHBlcnMvY2xpY2tIYW5kbGVyLnRzXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luMih7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5MihcImhhbmRsZUNsaWNrTGlua1wiKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlQ2xpY2s6ICh2aWV3LCBwb3MsIGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5rID0gbnVsbDtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICAgICAgbGluayA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgYSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBjb25zdCBlbHMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoYS5ub2RlTmFtZSAhPT0gXCJESVZcIikge1xuICAgICAgICAgICAgZWxzLnB1c2goYSk7XG4gICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5rID0gZWxzLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZS5ub2RlTmFtZSA9PT0gXCJBXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRycyA9IGdldEF0dHJpYnV0ZXModmlldy5zdGF0ZSwgb3B0aW9ucy50eXBlLm5hbWUpO1xuICAgICAgICBjb25zdCBocmVmID0gKF9hID0gbGluayA9PSBudWxsID8gdm9pZCAwIDogbGluay5ocmVmKSAhPSBudWxsID8gX2EgOiBhdHRycy5ocmVmO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSAoX2IgPSBsaW5rID09IG51bGwgPyB2b2lkIDAgOiBsaW5rLnRhcmdldCkgIT0gbnVsbCA/IF9iIDogYXR0cnMudGFyZ2V0O1xuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVDbGlja1NlbGVjdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMuZWRpdG9yLmNvbW1hbmRzLmV4dGVuZE1hcmtSYW5nZShvcHRpb25zLnR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmsgJiYgaHJlZikge1xuICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzL3Bhc3RlSGFuZGxlci50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjMsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IGZpbmQgfSBmcm9tIFwibGlua2lmeWpzXCI7XG5mdW5jdGlvbiBwYXN0ZUhhbmRsZXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBsdWdpbjMoe1xuICAgIGtleTogbmV3IFBsdWdpbktleTMoXCJoYW5kbGVQYXN0ZUxpbmtcIiksXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQsIHNsaWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBmaW5kKHRleHRDb250ZW50LCB7IGRlZmF1bHRQcm90b2NvbDogb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfSkuZmluZChcbiAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5pc0xpbmsgJiYgaXRlbS52YWx1ZSA9PT0gdGV4dENvbnRlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCAhbGluaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuc2V0TWFyayhvcHRpb25zLnR5cGUsIHtcbiAgICAgICAgICBocmVmOiBsaW5rLmhyZWZcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2xpbmsudHNcbnZhciBwYXN0ZVJlZ2V4ID0gL2h0dHBzPzpcXC9cXC8oPzp3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16QS1aXXsyLH1cXGIoPzpbLWEtekEtWjAtOUA6JS5fK34jPT8hJi9dKikoPzpbLWEtekEtWjAtOUA6JS5fK34jPT8hJi9dKikvZ2k7XG5mdW5jdGlvbiBpc0FsbG93ZWRVcmkodXJpLCBwcm90b2NvbHMpIHtcbiAgY29uc3QgYWxsb3dlZFByb3RvY29scyA9IFtcImh0dHBcIiwgXCJodHRwc1wiLCBcImZ0cFwiLCBcImZ0cHNcIiwgXCJtYWlsdG9cIiwgXCJ0ZWxcIiwgXCJjYWxsdG9cIiwgXCJzbXNcIiwgXCJjaWRcIiwgXCJ4bXBwXCJdO1xuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzLmZvckVhY2goKHByb3RvY29sKSA9PiB7XG4gICAgICBjb25zdCBuZXh0UHJvdG9jb2wgPSB0eXBlb2YgcHJvdG9jb2wgPT09IFwic3RyaW5nXCIgPyBwcm90b2NvbCA6IHByb3RvY29sLnNjaGVtZTtcbiAgICAgIGlmIChuZXh0UHJvdG9jb2wpIHtcbiAgICAgICAgYWxsb3dlZFByb3RvY29scy5wdXNoKG5leHRQcm90b2NvbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICF1cmkgfHwgdXJpLnJlcGxhY2UoVU5JQ09ERV9XSElURVNQQUNFX1JFR0VYX0dMT0JBTCwgXCJcIikubWF0Y2goXG4gICAgbmV3IFJlZ0V4cChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgYF4oPzooPzoke2FsbG93ZWRQcm90b2NvbHMuam9pbihcInxcIil9KTp8W15hLXpdfFthLXowLTkrLi1dKyg/OlteYS16Ky4tOl18JCkpYCxcbiAgICAgIFwiaVwiXG4gICAgKVxuICApO1xufVxudmFyIExpbmsgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlua1wiLFxuICBwcmlvcml0eTogMWUzLFxuICBrZWVwT25TcGxpdDogZmFsc2UsXG4gIGV4aXRhYmxlOiB0cnVlLFxuICBvbkNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlICYmICF0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmspIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluayA9IHRoaXMub3B0aW9ucy52YWxpZGF0ZTtcbiAgICAgIGNvbnNvbGUud2FybihcIlRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBSZW5hbWUgdG8gdGhlIGBzaG91bGRBdXRvTGlua2Agb3B0aW9uIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLmZvckVhY2goKHByb3RvY29sKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvY29sID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWdpc3RlckN1c3RvbVByb3RvY29sKHByb3RvY29sLnNjaGVtZSwgcHJvdG9jb2wub3B0aW9uYWxTbGFzaGVzKTtcbiAgICB9KTtcbiAgfSxcbiAgb25EZXN0cm95KCkge1xuICAgIHJlc2V0KCk7XG4gIH0sXG4gIGluY2x1c2l2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF1dG9saW5rO1xuICB9LFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICAgIGVuYWJsZUNsaWNrU2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgZGVmYXVsdFByb3RvY29sOiBcImh0dHBcIixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7XG4gICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIixcbiAgICAgICAgY2xhc3M6IG51bGxcbiAgICAgIH0sXG4gICAgICBpc0FsbG93ZWRVcmk6ICh1cmwsIGN0eCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCBjdHgucHJvdG9jb2xzKSxcbiAgICAgIHZhbGlkYXRlOiAodXJsKSA9PiAhIXVybCxcbiAgICAgIHNob3VsZEF1dG9MaW5rOiAodXJsKSA9PiAhIXVybFxuICAgIH07XG4gIH0sXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy50YXJnZXRcbiAgICAgIH0sXG4gICAgICByZWw6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnJlbFxuICAgICAgfSxcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy5jbGFzc1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiYVtocmVmXVwiLFxuICAgICAgICBnZXRBdHRyczogKGRvbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGhyZWYgPSBkb20uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgICAgICBpZiAoIWhyZWYgfHwgIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiAodXJsKSA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShIVE1MQXR0cmlidXRlcy5ocmVmLCB7XG4gICAgICBkZWZhdWx0VmFsaWRhdGU6IChocmVmKSA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gW1wiYVwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCB7IC4uLkhUTUxBdHRyaWJ1dGVzLCBocmVmOiBcIlwiIH0pLCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcImFcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldExpbms6IChhdHRyaWJ1dGVzKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6ICh1cmwpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW4oKS5zZXRNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcykuc2V0TWV0YShcInByZXZlbnRBdXRvbGlua1wiLCB0cnVlKS5ydW4oKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVMaW5rOiAoYXR0cmlidXRlcykgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIGlmIChocmVmICYmICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6ICh1cmwpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgdGhpcy5vcHRpb25zLnByb3RvY29scyksXG4gICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcywgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KS5zZXRNZXRhKFwicHJldmVudEF1dG9saW5rXCIsIHRydWUpLnJ1bigpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0TGluazogKCkgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhaW4oKS51bnNldE1hcmsodGhpcy5uYW1lLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pLnNldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIiwgdHJ1ZSkucnVuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6ICh0ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZm91bmRMaW5rcyA9IFtdO1xuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3RvY29scywgZGVmYXVsdFByb3RvY29sIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IGZpbmQyKHRleHQpLmZpbHRlcihcbiAgICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0uaXNMaW5rICYmIHRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaXRlbS52YWx1ZSwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKGhyZWYpID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xzLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChcbiAgICAgICAgICAgICAgICAobGluaykgPT4gZm91bmRMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBsaW5rLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZvdW5kTGlua3M7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiAoX2EgPSBtYXRjaC5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaHJlZlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICBjb25zdCB7IHByb3RvY29scywgZGVmYXVsdFByb3RvY29sIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbGluaykge1xuICAgICAgcGx1Z2lucy5wdXNoKFxuICAgICAgICBhdXRvbGluayh7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICB2YWxpZGF0ZTogKHVybCkgPT4gdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaSh1cmwsIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogKGhyZWYpID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2xcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzaG91bGRBdXRvTGluazogdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IHRoaXMub3B0aW9ucy5lbmFibGVDbGlja1NlbGVjdGlvblxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5saW5rT25QYXN0ZSkge1xuICAgICAgcGx1Z2lucy5wdXNoKFxuICAgICAgICBwYXN0ZUhhbmRsZXIoe1xuICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbnM7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gTGluaztcbmV4cG9ydCB7XG4gIExpbmssXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgaXNBbGxvd2VkVXJpLFxuICBwYXN0ZVJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   ListKeymap: () => (/* binding */ ListKeymap),\n/* harmony export */   ListKit: () => (/* binding */ ListKit),\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   bulletListInputRegex: () => (/* binding */ bulletListInputRegex),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   listHelpers: () => (/* binding */ listHelpers_exports),\n/* harmony export */   orderedListInputRegex: () => (/* binding */ orderedListInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/bullet-list/bullet-list.ts\n\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{ tag: \"ul\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\n\nvar ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [\n      {\n        tag: \"li\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"li\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\n\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\n\nvar findListItemPos = (typeOrName, state) => {\n  const { $from } = state.selection;\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\n\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition)(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\n\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const { $anchor } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\n\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType)(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants((child) => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode)(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\n\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive)(editor.state, name)) {\n    return false;\n  }\n  if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode)(editor.state, name)) {\n    return false;\n  }\n  const { selection } = editor.state;\n  const { $from, $to } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const { $anchor } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: \"listItem\",\n          wrapperNames: [\"bulletList\", \"orderedList\"]\n        },\n        {\n          itemName: \"taskItem\",\n          wrapperNames: [\"taskList\"]\n        }\n      ]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({ editor }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\n\n\n// src/ordered-list/ordered-list.ts\n\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: (element) => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: (element) => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"ol\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes;\n    return start === 1 ? [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: (match) => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\n\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: (element) => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: (attributes) => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"li\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n        \"data-type\": this.name\n      }),\n      [\n        \"label\",\n        [\n          \"input\",\n          {\n            type: \"checkbox\",\n            checked: node.attrs.checked ? \"checked\" : null\n          }\n        ],\n        [\"span\"]\n      ],\n      [\"div\", 0]\n    ];\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = () => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, node, checkbox.checked)) || `Task item checkbox for ${node.textContent || \"empty task item\"}`;\n      };\n      updateA11Y();\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", (event) => event.preventDefault());\n      checkbox.addEventListener(\"change\", (event) => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const { checked } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...currentNode == null ? void 0 : currentNode.attrs,\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: (updatedNode) => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y();\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          checked: match[match.length - 1] === \"x\"\n        })\n      })\n    ];\n  }\n});\n\n// src/task-list/task-list.ts\n\nvar TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, { \"data-type\": this.name }), 0];\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEMsR0FBRztBQUNIO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixrQkFBa0IsNkRBQWU7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQiwrREFBaUI7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiwrREFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDa0Y7QUFDbEYsZUFBZSw4Q0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0Isa0JBQWtCLDZEQUFnQjtBQUNsQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3lDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxtREFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQWFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9kaXN0L2luZGV4LmpzP2E4YzUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2J1bGxldC1saXN0L2J1bGxldC1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIExpc3RJdGVtTmFtZSA9IFwibGlzdEl0ZW1cIjtcbnZhciBUZXh0U3R5bGVOYW1lID0gXCJ0ZXh0U3R5bGVcIjtcbnZhciBidWxsZXRMaXN0SW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkLztcbnZhciBCdWxsZXRMaXN0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImJ1bGxldExpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcImxpc3RJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgZ3JvdXA6IFwiYmxvY2sgbGlzdFwiLFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJ1bFwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJ1bFwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSkucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtU2hpZnQtOFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRSdWxlXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9pdGVtL2xpc3QtaXRlbS50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczIsIE5vZGUgYXMgTm9kZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgTGlzdEl0ZW0gPSBOb2RlMi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RJdGVtXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogXCJidWxsZXRMaXN0XCIsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBcIm9yZGVyZWRMaXN0XCJcbiAgICB9O1xuICB9LFxuICBjb250ZW50OiBcInBhcmFncmFwaCBibG9jaypcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwibGlcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImxpXCIsIG1lcmdlQXR0cmlidXRlczIodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBcIlNoaWZ0LVRhYlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMva2V5bWFwL2xpc3Qta2V5bWFwLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaW5kZXgudHNcbnZhciBsaXN0SGVscGVyc19leHBvcnRzID0ge307XG5fX2V4cG9ydChsaXN0SGVscGVyc19leHBvcnRzLCB7XG4gIGZpbmRMaXN0SXRlbVBvczogKCkgPT4gZmluZExpc3RJdGVtUG9zLFxuICBnZXROZXh0TGlzdERlcHRoOiAoKSA9PiBnZXROZXh0TGlzdERlcHRoLFxuICBoYW5kbGVCYWNrc3BhY2U6ICgpID0+IGhhbmRsZUJhY2tzcGFjZSxcbiAgaGFuZGxlRGVsZXRlOiAoKSA9PiBoYW5kbGVEZWxldGUsXG4gIGhhc0xpc3RCZWZvcmU6ICgpID0+IGhhc0xpc3RCZWZvcmUsXG4gIGhhc0xpc3RJdGVtQWZ0ZXI6ICgpID0+IGhhc0xpc3RJdGVtQWZ0ZXIsXG4gIGhhc0xpc3RJdGVtQmVmb3JlOiAoKSA9PiBoYXNMaXN0SXRlbUJlZm9yZSxcbiAgbGlzdEl0ZW1IYXNTdWJMaXN0OiAoKSA9PiBsaXN0SXRlbUhhc1N1Ykxpc3QsXG4gIG5leHRMaXN0SXNEZWVwZXI6ICgpID0+IG5leHRMaXN0SXNEZWVwZXIsXG4gIG5leHRMaXN0SXNIaWdoZXI6ICgpID0+IG5leHRMaXN0SXNIaWdoZXJcbn0pO1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2ZpbmRMaXN0SXRlbVBvcy50c1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgZmluZExpc3RJdGVtUG9zID0gKHR5cGVPck5hbWUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3Qgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICBsZXQgY3VycmVudERlcHRoID0gJGZyb20uZGVwdGg7XG4gIGxldCBjdXJyZW50UG9zID0gJGZyb20ucG9zO1xuICBsZXQgdGFyZ2V0RGVwdGggPSBudWxsO1xuICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiB0YXJnZXREZXB0aCA9PT0gbnVsbCkge1xuICAgIGN1cnJlbnROb2RlID0gJGZyb20ubm9kZShjdXJyZW50RGVwdGgpO1xuICAgIGlmIChjdXJyZW50Tm9kZS50eXBlID09PSBub2RlVHlwZSkge1xuICAgICAgdGFyZ2V0RGVwdGggPSBjdXJyZW50RGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnREZXB0aCAtPSAxO1xuICAgICAgY3VycmVudFBvcyAtPSAxO1xuICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0RGVwdGggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4geyAkcG9zOiBzdGF0ZS5kb2MucmVzb2x2ZShjdXJyZW50UG9zKSwgZGVwdGg6IHRhcmdldERlcHRoIH07XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2dldE5leHRMaXN0RGVwdGgudHNcbmltcG9ydCB7IGdldE5vZGVBdFBvc2l0aW9uIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGdldE5leHRMaXN0RGVwdGggPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3ModHlwZU9yTmFtZSwgc3RhdGUpO1xuICBpZiAoIWxpc3RJdGVtUG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFssIGRlcHRoXSA9IGdldE5vZGVBdFBvc2l0aW9uKHN0YXRlLCB0eXBlT3JOYW1lLCBsaXN0SXRlbVBvcy4kcG9zLnBvcyArIDQpO1xuICByZXR1cm4gZGVwdGg7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZUJhY2tzcGFjZS50c1xuaW1wb3J0IHsgaXNBdFN0YXJ0T2ZOb2RlLCBpc05vZGVBY3RpdmUgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFzTGlzdEJlZm9yZS50c1xudmFyIGhhc0xpc3RCZWZvcmUgPSAoZWRpdG9yU3RhdGUsIG5hbWUsIHBhcmVudExpc3RUeXBlcykgPT4ge1xuICBjb25zdCB7ICRhbmNob3IgfSA9IGVkaXRvclN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgcHJldmlvdXNOb2RlUG9zID0gTWF0aC5tYXgoMCwgJGFuY2hvci5wb3MgLSAyKTtcbiAgY29uc3QgcHJldmlvdXNOb2RlID0gZWRpdG9yU3RhdGUuZG9jLnJlc29sdmUocHJldmlvdXNOb2RlUG9zKS5ub2RlKCk7XG4gIGlmICghcHJldmlvdXNOb2RlIHx8ICFwYXJlbnRMaXN0VHlwZXMuaW5jbHVkZXMocHJldmlvdXNOb2RlLnR5cGUubmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RJdGVtQmVmb3JlLnRzXG52YXIgaGFzTGlzdEl0ZW1CZWZvcmUgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7ICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgJHRhcmdldFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKCRhbmNob3IucG9zIC0gMik7XG4gIGlmICgkdGFyZ2V0UG9zLmluZGV4KCkgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCgoX2EgPSAkdGFyZ2V0UG9zLm5vZGVCZWZvcmUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpICE9PSB0eXBlT3JOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2tleW1hcC9saXN0SGVscGVycy9saXN0SXRlbUhhc1N1Ykxpc3QudHNcbmltcG9ydCB7IGdldE5vZGVUeXBlIGFzIGdldE5vZGVUeXBlMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBsaXN0SXRlbUhhc1N1Ykxpc3QgPSAodHlwZU9yTmFtZSwgc3RhdGUsIG5vZGUpID0+IHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUyKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gIGxldCBoYXNTdWJMaXN0ID0gZmFsc2U7XG4gIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IG5vZGVUeXBlKSB7XG4gICAgICBoYXNTdWJMaXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGFzU3ViTGlzdDtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlQmFja3NwYWNlLnRzXG52YXIgaGFuZGxlQmFja3NwYWNlID0gKGVkaXRvciwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSA9PiB7XG4gIGlmIChlZGl0b3IuY29tbWFuZHMudW5kb0lucHV0UnVsZSgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAhPT0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50bykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzTm9kZUFjdGl2ZShlZGl0b3Iuc3RhdGUsIG5hbWUpICYmIGhhc0xpc3RCZWZvcmUoZWRpdG9yLnN0YXRlLCBuYW1lLCBwYXJlbnRMaXN0VHlwZXMpKSB7XG4gICAgY29uc3QgeyAkYW5jaG9yIH0gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0ICRsaXN0UG9zID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKCRhbmNob3IuYmVmb3JlKCkgLSAxKTtcbiAgICBjb25zdCBsaXN0RGVzY2VuZGFudHMgPSBbXTtcbiAgICAkbGlzdFBvcy5ub2RlKCkuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3REZXNjZW5kYW50cy5wdXNoKHsgbm9kZSwgcG9zIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxhc3RJdGVtID0gbGlzdERlc2NlbmRhbnRzLmF0KC0xKTtcbiAgICBpZiAoIWxhc3RJdGVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0ICRsYXN0SXRlbVBvcyA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZSgkbGlzdFBvcy5zdGFydCgpICsgbGFzdEl0ZW0ucG9zICsgMSk7XG4gICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmN1dCh7IGZyb206ICRhbmNob3Iuc3RhcnQoKSAtIDEsIHRvOiAkYW5jaG9yLmVuZCgpICsgMSB9LCAkbGFzdEl0ZW1Qb3MuZW5kKCkpLmpvaW5Gb3J3YXJkKCkucnVuKCk7XG4gIH1cbiAgaWYgKCFpc05vZGVBY3RpdmUoZWRpdG9yLnN0YXRlLCBuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzQXRTdGFydE9mTm9kZShlZGl0b3Iuc3RhdGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKG5hbWUsIGVkaXRvci5zdGF0ZSk7XG4gIGlmICghbGlzdEl0ZW1Qb3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgJHByZXYgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUobGlzdEl0ZW1Qb3MuJHBvcy5wb3MgLSAyKTtcbiAgY29uc3QgcHJldk5vZGUgPSAkcHJldi5ub2RlKGxpc3RJdGVtUG9zLmRlcHRoKTtcbiAgY29uc3QgcHJldmlvdXNMaXN0SXRlbUhhc1N1Ykxpc3QgPSBsaXN0SXRlbUhhc1N1Ykxpc3QobmFtZSwgZWRpdG9yLnN0YXRlLCBwcmV2Tm9kZSk7XG4gIGlmIChoYXNMaXN0SXRlbUJlZm9yZShuYW1lLCBlZGl0b3Iuc3RhdGUpICYmICFwcmV2aW91c0xpc3RJdGVtSGFzU3ViTGlzdCkge1xuICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuam9pbkl0ZW1CYWNrd2FyZCgpO1xuICB9XG4gIHJldHVybiBlZGl0b3IuY2hhaW4oKS5saWZ0TGlzdEl0ZW0obmFtZSkucnVuKCk7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhbmRsZURlbGV0ZS50c1xuaW1wb3J0IHsgaXNBdEVuZE9mTm9kZSwgaXNOb2RlQWN0aXZlIGFzIGlzTm9kZUFjdGl2ZTIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvbmV4dExpc3RJc0RlZXBlci50c1xudmFyIG5leHRMaXN0SXNEZWVwZXIgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgY29uc3QgbGlzdERlcHRoID0gZ2V0TmV4dExpc3REZXB0aCh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcyB8fCAhbGlzdERlcHRoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsaXN0RGVwdGggPiBsaXN0SXRlbVBvcy5kZXB0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvbmV4dExpc3RJc0hpZ2hlci50c1xudmFyIG5leHRMaXN0SXNIaWdoZXIgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgY29uc3QgbGlzdERlcHRoID0gZ2V0TmV4dExpc3REZXB0aCh0eXBlT3JOYW1lLCBzdGF0ZSk7XG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKTtcbiAgaWYgKCFsaXN0SXRlbVBvcyB8fCAhbGlzdERlcHRoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsaXN0RGVwdGggPCBsaXN0SXRlbVBvcy5kZXB0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFuZGxlRGVsZXRlLnRzXG52YXIgaGFuZGxlRGVsZXRlID0gKGVkaXRvciwgbmFtZSkgPT4ge1xuICBpZiAoIWlzTm9kZUFjdGl2ZTIoZWRpdG9yLnN0YXRlLCBuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzQXRFbmRPZk5vZGUoZWRpdG9yLnN0YXRlLCBuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yLnN0YXRlO1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcbiAgaWYgKCFzZWxlY3Rpb24uZW1wdHkgJiYgJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuZXh0TGlzdElzRGVlcGVyKG5hbWUsIGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuZm9jdXMoZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgNCkubGlmdChuYW1lKS5qb2luQmFja3dhcmQoKS5ydW4oKTtcbiAgfVxuICBpZiAobmV4dExpc3RJc0hpZ2hlcihuYW1lLCBlZGl0b3Iuc3RhdGUpKSB7XG4gICAgcmV0dXJuIGVkaXRvci5jaGFpbigpLmpvaW5Gb3J3YXJkKCkuam9pbkJhY2t3YXJkKCkucnVuKCk7XG4gIH1cbiAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUZvcndhcmQoKTtcbn07XG5cbi8vIHNyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFzTGlzdEl0ZW1BZnRlci50c1xudmFyIGhhc0xpc3RJdGVtQWZ0ZXIgPSAodHlwZU9yTmFtZSwgc3RhdGUpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7ICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgJHRhcmdldFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKCRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXQgLSAyKTtcbiAgaWYgKCR0YXJnZXRQb3MuaW5kZXgoKSA9PT0gJHRhcmdldFBvcy5wYXJlbnQuY2hpbGRDb3VudCAtIDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCgoX2EgPSAkdGFyZ2V0UG9zLm5vZGVBZnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgIT09IHR5cGVPck5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBzcmMva2V5bWFwL2xpc3Qta2V5bWFwLnRzXG52YXIgTGlzdEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImxpc3RLZXltYXBcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlzdFR5cGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtTmFtZTogXCJsaXN0SXRlbVwiLFxuICAgICAgICAgIHdyYXBwZXJOYW1lczogW1wiYnVsbGV0TGlzdFwiLCBcIm9yZGVyZWRMaXN0XCJdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtTmFtZTogXCJ0YXNrSXRlbVwiLFxuICAgICAgICAgIHdyYXBwZXJOYW1lczogW1widGFza0xpc3RcIl1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBEZWxldGU6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZURlbGV0ZShlZGl0b3IsIGl0ZW1OYW1lKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9LFxuICAgICAgXCJNb2QtRGVsZXRlXCI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZURlbGV0ZShlZGl0b3IsIGl0ZW1OYW1lKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9LFxuICAgICAgQmFja3NwYWNlOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcyB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZUJhY2tzcGFjZShlZGl0b3IsIGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICAgIH0sXG4gICAgICBcIk1vZC1CYWNrc3BhY2VcIjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVCYWNrc3BhY2UoZWRpdG9yLCBpdGVtTmFtZSwgd3JhcHBlck5hbWVzKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9raXQvaW5kZXgudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb24yIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG4vLyBzcmMvb3JkZXJlZC1saXN0L29yZGVyZWQtbGlzdC50c1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIGFzIG1lcmdlQXR0cmlidXRlczMsIE5vZGUgYXMgTm9kZTMsIHdyYXBwaW5nSW5wdXRSdWxlIGFzIHdyYXBwaW5nSW5wdXRSdWxlMiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBMaXN0SXRlbU5hbWUyID0gXCJsaXN0SXRlbVwiO1xudmFyIFRleHRTdHlsZU5hbWUyID0gXCJ0ZXh0U3R5bGVcIjtcbnZhciBvcmRlcmVkTGlzdElucHV0UmVnZXggPSAvXihcXGQrKVxcLlxccyQvO1xudmFyIE9yZGVyZWRMaXN0ID0gTm9kZTMuY3JlYXRlKHtcbiAgbmFtZTogXCJvcmRlcmVkTGlzdFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6IFwibGlzdEl0ZW1cIixcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICBrZWVwQXR0cmlidXRlczogZmFsc2VcbiAgICB9O1xuICB9LFxuICBncm91cDogXCJibG9jayBsaXN0XCIsXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XG4gIH0sXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgfHwgXCJcIiwgMTApIDogMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJvbFwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCB7IHN0YXJ0LCAuLi5hdHRyaWJ1dGVzV2l0aG91dFN0YXJ0IH0gPSBIVE1MQXR0cmlidXRlcztcbiAgICByZXR1cm4gc3RhcnQgPT09IDEgPyBbXCJvbFwiLCBtZXJnZUF0dHJpYnV0ZXMzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgYXR0cmlidXRlc1dpdGhvdXRTdGFydCksIDBdIDogW1wib2xcIiwgbWVyZ2VBdHRyaWJ1dGVzMyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZTIsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZTIpKS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC03XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KClcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZTIoe1xuICAgICAgZmluZDogb3JkZXJlZExpc3RJbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgZ2V0QXR0cmlidXRlczogKG1hdGNoKSA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxuICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlMih7XG4gICAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lMikgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpbnB1dFJ1bGVdO1xuICB9XG59KTtcblxuLy8gc3JjL3Rhc2staXRlbS90YXNrLWl0ZW0udHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyBhcyBtZXJnZUF0dHJpYnV0ZXM0LCBOb2RlIGFzIE5vZGU0LCB3cmFwcGluZ0lucHV0UnVsZSBhcyB3cmFwcGluZ0lucHV0UnVsZTMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgaW5wdXRSZWdleCA9IC9eXFxzKihcXFsoWyggfHhdKT9cXF0pXFxzJC87XG52YXIgVGFza0l0ZW0gPSBOb2RlNC5jcmVhdGUoe1xuICBuYW1lOiBcInRhc2tJdGVtXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5lc3RlZDogZmFsc2UsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICB0YXNrTGlzdFR5cGVOYW1lOiBcInRhc2tMaXN0XCIsXG4gICAgICBhMTF5OiB2b2lkIDBcbiAgICB9O1xuICB9LFxuICBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubmVzdGVkID8gXCJwYXJhZ3JhcGggYmxvY2sqXCIgOiBcInBhcmFncmFwaCtcIjtcbiAgfSxcbiAgZGVmaW5pbmc6IHRydWUsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFDaGVja2VkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNoZWNrZWRcIik7XG4gICAgICAgICAgcmV0dXJuIGRhdGFDaGVja2VkID09PSBcIlwiIHx8IGRhdGFDaGVja2VkID09PSBcInRydWVcIjtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+ICh7XG4gICAgICAgICAgXCJkYXRhLWNoZWNrZWRcIjogYXR0cmlidXRlcy5jaGVja2VkXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogYGxpW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgIHByaW9yaXR5OiA1MVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwibGlcIixcbiAgICAgIG1lcmdlQXR0cmlidXRlczQodGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywge1xuICAgICAgICBcImRhdGEtdHlwZVwiOiB0aGlzLm5hbWVcbiAgICAgIH0pLFxuICAgICAgW1xuICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgIFtcbiAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgY2hlY2tlZDogbm9kZS5hdHRycy5jaGVja2VkID8gXCJjaGVja2VkXCIgOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXCJzcGFuXCJdXG4gICAgICBdLFxuICAgICAgW1wiZGl2XCIsIDBdXG4gICAgXTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3Qgc2hvcnRjdXRzID0ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5uZXN0ZWQpIHtcbiAgICAgIHJldHVybiBzaG9ydGN1dHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5zaG9ydGN1dHMsXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpXG4gICAgfTtcbiAgfSxcbiAgYWRkTm9kZVZpZXcoKSB7XG4gICAgcmV0dXJuICh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzLCBnZXRQb3MsIGVkaXRvciB9KSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgIGNvbnN0IGNoZWNrYm94U3R5bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3QgdXBkYXRlQTExWSA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2hlY2tib3guYXJpYUxhYmVsID0gKChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5hMTF5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2hlY2tib3hMYWJlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5vZGUsIGNoZWNrYm94LmNoZWNrZWQpKSB8fCBgVGFzayBpdGVtIGNoZWNrYm94IGZvciAke25vZGUudGV4dENvbnRlbnQgfHwgXCJlbXB0eSB0YXNrIGl0ZW1cIn1gO1xuICAgICAgfTtcbiAgICAgIHVwZGF0ZUExMVkoKTtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlICYmIHR5cGVvZiBnZXRQb3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKHZvaWQgMCwgeyBzY3JvbGxJbnRvVmlldzogZmFsc2UgfSkuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3NpdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmIHRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKG5vZGUsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IG5vZGUuYXR0cnMuY2hlY2tlZDtcbiAgICAgIGNoZWNrYm94V3JhcHBlci5hcHBlbmQoY2hlY2tib3gsIGNoZWNrYm94U3R5bGVyKTtcbiAgICAgIGxpc3RJdGVtLmFwcGVuZChjaGVja2JveFdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogbGlzdEl0ZW0sXG4gICAgICAgIGNvbnRlbnRET006IGNvbnRlbnQsXG4gICAgICAgIHVwZGF0ZTogKHVwZGF0ZWROb2RlKSA9PiB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWROb2RlLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgIHVwZGF0ZUExMVkoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB3cmFwcGluZ0lucHV0UnVsZTMoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCkgPT4gKHtcbiAgICAgICAgICBjaGVja2VkOiBtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PT0gXCJ4XCJcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy90YXNrLWxpc3QvdGFzay1saXN0LnRzXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgYXMgbWVyZ2VBdHRyaWJ1dGVzNSwgTm9kZSBhcyBOb2RlNSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBUYXNrTGlzdCA9IE5vZGU1LmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFza0xpc3RcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiBcInRhc2tJdGVtXCIsXG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBncm91cDogXCJibG9jayBsaXN0XCIsXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IGB1bFtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICBwcmlvcml0eTogNTFcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJ1bFwiLCBtZXJnZUF0dHJpYnV0ZXM1KHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHsgXCJkYXRhLXR5cGVcIjogdGhpcy5uYW1lIH0pLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZVRhc2tMaXN0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiTW9kLVNoaWZ0LTlcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVGFza0xpc3QoKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMva2l0L2luZGV4LnRzXG52YXIgTGlzdEtpdCA9IEV4dGVuc2lvbjIuY3JlYXRlKHtcbiAgbmFtZTogXCJsaXN0S2l0XCIsXG4gIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCdWxsZXRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RJdGVtICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEl0ZW0pKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXN0S2V5bWFwICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RLZXltYXAuY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0S2V5bWFwKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goT3JkZXJlZExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhc2tJdGVtICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhc2tJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFza0l0ZW0pKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXNrTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUYXNrTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRhc2tMaXN0KSk7XG4gICAgfVxuICAgIHJldHVybiBleHRlbnNpb25zO1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIEJ1bGxldExpc3QsXG4gIExpc3RJdGVtLFxuICBMaXN0S2V5bWFwLFxuICBMaXN0S2l0LFxuICBPcmRlcmVkTGlzdCxcbiAgVGFza0l0ZW0sXG4gIFRhc2tMaXN0LFxuICBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgaW5wdXRSZWdleCxcbiAgbGlzdEhlbHBlcnNfZXhwb3J0cyBhcyBsaXN0SGVscGVycyxcbiAgb3JkZXJlZExpc3RJbnB1dFJlZ2V4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/paragraph.ts\n\nvar Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"paragraph\",\n  priority: 1e3,\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  content: \"inline*\",\n  parseHTML() {\n    return [{ tag: \"p\" }];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.setNode(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-0\": () => this.editor.commands.setParagraph()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Paragraph;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQiw2REFBZTtBQUNoQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvZGlzdC9pbmRleC5qcz9hOWIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9wYXJhZ3JhcGgudHNcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBQYXJhZ3JhcGggPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIHByaW9yaXR5OiAxZTMsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fVxuICAgIH07XG4gIH0sXG4gIGdyb3VwOiBcImJsb2NrXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogXCJwXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInBcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1BbHQtMFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRQYXJhZ3JhcGgoKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gUGFyYWdyYXBoO1xuZXhwb3J0IHtcbiAgUGFyYWdyYXBoLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/strike.ts\n\nvar inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\nvar pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\nvar Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"strike\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"s\"\n      },\n      {\n        tag: \"del\"\n      },\n      {\n        tag: \"strike\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"line-through\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"s\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-s\": () => this.editor.commands.toggleStrike()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n// src/index.ts\nvar index_default = Strike;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRjtBQUNuRjtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUIsNkRBQWU7QUFDaEMsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLE9BQU87QUFDUCw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLE9BQU87QUFDUCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSwyREFBYTtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9kaXN0L2luZGV4LmpzPzNmMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0cmlrZS50c1xuaW1wb3J0IHsgTWFyaywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xudmFyIGlucHV0UmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKSQvO1xudmFyIHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xudmFyIFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJzdHJpa2VcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkZWxcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInN0cmlrZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IChzdHlsZSkgPT4gc3R5bGUuaW5jbHVkZXMoXCJsaW5lLXRocm91Z2hcIikgPyB7fSA6IGZhbHNlXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wic1wiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC1TaGlmdC1zXCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RyaWtlO1xuZXhwb3J0IHtcbiAgU3RyaWtlLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGlucHV0UmVnZXgsXG4gIHBhc3RlUmVnZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/text.ts\n\nvar Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"text\",\n  group: \"inline\"\n});\n\n// src/index.ts\nvar index_default = Text;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ29DO0FBQ3BDLFdBQVcsOENBQUk7QUFDZjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanM/MWIwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdGV4dC50c1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbnZhciBUZXh0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRcIixcbiAgZ3JvdXA6IFwiaW5saW5lXCJcbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gVGV4dDtcbmV4cG9ydCB7XG4gIFRleHQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n// src/underline.ts\n\nvar Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"underline\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"u\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"underline\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"u\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setUnderline: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleUnderline: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetUnderline: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-u\": () => this.editor.commands.toggleUnderline(),\n      \"Mod-U\": () => this.editor.commands.toggleUnderline()\n    };\n  }\n});\n\n// src/index.ts\nvar index_default = Underline;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDcUQ7QUFDckQsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLDZEQUFlO0FBQ2hDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxPQUFPO0FBQ1AsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanM/N2NkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdW5kZXJsaW5lLnRzXG5pbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG52YXIgVW5kZXJsaW5lID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcInVuZGVybGluZVwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge31cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IFwidGV4dC1kZWNvcmF0aW9uXCIsXG4gICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgIGdldEF0dHJzOiAoc3R5bGUpID0+IHN0eWxlLmluY2x1ZGVzKFwidW5kZXJsaW5lXCIpID8ge30gOiBmYWxzZVxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcInVcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtdVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICAgIFwiTW9kLVVcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKClcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZGVmYXVsdCA9IFVuZGVybGluZTtcbmV4cG9ydCB7XG4gIFVuZGVybGluZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extensions/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/extensions/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCount: () => (/* binding */ CharacterCount),\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   Focus: () => (/* binding */ Focus),\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   TrailingNode: () => (/* binding */ TrailingNode),\n/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\");\n// src/character-count/character-count.ts\n\n\nvar CharacterCount = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"characterCount\",\n  addOptions() {\n    return {\n      limit: null,\n      mode: \"textSize\",\n      textCounter: (text) => text.length,\n      wordCounter: (text) => text.split(\" \").filter((word) => word !== \"\").length\n    };\n  },\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0\n    };\n  },\n  onBeforeCreate() {\n    this.storage.characters = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const mode = (options == null ? void 0 : options.mode) || this.options.mode;\n      if (mode === \"textSize\") {\n        const text = node.textBetween(0, node.content.size, void 0, \" \");\n        return this.options.textCounter(text);\n      }\n      return node.nodeSize;\n    };\n    this.storage.words = (options) => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const text = node.textBetween(0, node.content.size, \" \", \" \");\n      return this.options.wordCounter(text);\n    };\n  },\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"characterCount\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return;\n          }\n          const limit = this.options.limit;\n          if (limit === null || limit === void 0 || limit === 0) {\n            initialEvaluationDone = true;\n            return;\n          }\n          const initialContentSize = this.storage.characters({ node: newState.doc });\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit;\n            const from = 0;\n            const to = over;\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`\n            );\n            const tr = newState.tr.deleteRange(from, to);\n            initialEvaluationDone = true;\n            return tr;\n          }\n          initialEvaluationDone = true;\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit;\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {\n            return true;\n          }\n          const oldSize = this.storage.characters({ node: state.doc });\n          const newSize = this.storage.characters({ node: transaction.doc });\n          if (newSize <= limit) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true;\n          }\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false;\n          }\n          const isPaste = transaction.getMeta(\"paste\");\n          if (!isPaste) {\n            return false;\n          }\n          const pos = transaction.selection.$head.pos;\n          const over = newSize - limit;\n          const from = pos - over;\n          const to = pos;\n          transaction.deleteRange(from, to);\n          const updatedSize = this.storage.characters({ node: transaction.doc });\n          if (updatedSize > limit) {\n            return false;\n          }\n          return true;\n        }\n      })\n    ];\n  }\n});\n\n// src/drop-cursor/drop-cursor.ts\n\n\nvar Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"dropCursor\",\n  addOptions() {\n    return {\n      color: \"currentColor\",\n      width: 1,\n      class: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_2__.dropCursor)(this.options)];\n  }\n});\n\n// src/focus/focus.ts\n\n\n\nvar Focus = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"focus\",\n  addOptions() {\n    return {\n      className: \"has-focus\",\n      mode: \"all\"\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focus\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!isEditable || !isFocused) {\n              return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, []);\n            }\n            let maxLevels = 0;\n            if (this.options.mode === \"deepest\") {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return;\n                }\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n                if (!isCurrent) {\n                  return false;\n                }\n                maxLevels += 1;\n              });\n            }\n            let currentLevel = 0;\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false;\n              }\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n              if (!isCurrent) {\n                return false;\n              }\n              currentLevel += 1;\n              const outOfScope = this.options.mode === \"deepest\" && maxLevels - currentLevel > 0 || this.options.mode === \"shallowest\" && currentLevel > 1;\n              if (outOfScope) {\n                return this.options.mode === \"deepest\";\n              }\n              decorations.push(\n                _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className\n                })\n              );\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/gap-cursor/gap-cursor.ts\n\n\nvar Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"gapCursor\",\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_4__.gapCursor)()];\n  },\n  extendNodeSchema(extension) {\n    var _a;\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) != null ? _a : null\n    };\n  }\n});\n\n// src/placeholder/placeholder.ts\n\n\n\nvar Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      placeholder: \"Write something \\u2026\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!active) {\n              return null;\n            }\n            const isEmptyDoc = this.editor.isEmpty;\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeEmpty)(node);\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                  \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                    editor: this.editor,\n                    node,\n                    pos,\n                    hasAnchor\n                  }) : this.options.placeholder\n                });\n                decorations.push(decoration);\n              }\n              return this.options.includeChildren;\n            });\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/selection/selection.ts\n\n\n\nvar Selection = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"selection\",\n  addOptions() {\n    return {\n      className: \"selection\"\n    };\n  },\n  addProseMirrorPlugins() {\n    const { editor, options } = this;\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selection\"),\n        props: {\n          decorations(state) {\n            if (state.selection.empty || editor.isFocused || !editor.isEditable || (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection) || editor.view.dragging) {\n              return null;\n            }\n            return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n              _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className\n              })\n            ]);\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/trailing-node/trailing-node.ts\n\n\nfunction nodeEqualsType({ types, node }) {\n  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;\n}\nvar TrailingNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"trailingNode\",\n  addOptions() {\n    return {\n      node: \"paragraph\",\n      notAfter: []\n    };\n  },\n  addProseMirrorPlugins() {\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(this.name);\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(this.options.node).includes(node.name));\n    return [\n      new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size;\n          const type = schema.nodes[this.options.node];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n          return tr.insert(endPosition, type.create());\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n            const lastNode = tr.doc.lastChild;\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes });\n          }\n        }\n      })\n    ];\n  }\n});\n\n// src/undo-redo/undo-redo.ts\n\n\nvar UndoRedo = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n  name: \"undoRedo\",\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.undo)(state, dispatch);\n      },\n      redo: () => ({ state, dispatch }) => {\n        return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.redo)(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [(0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_5__.history)(this.options)];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-z\": () => this.editor.commands.undo(),\n      \"Shift-Mod-z\": () => this.editor.commands.redo(),\n      \"Mod-y\": () => this.editor.commands.redo(),\n      // Russian keyboard layouts\n      \"Mod-\\u044F\": () => this.editor.commands.undo(),\n      \"Shift-Mod-\\u044F\": () => this.editor.commands.redo()\n    };\n  }\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNZO0FBQ3JELHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQU07QUFDaEIsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUN1RDtBQUNKO0FBQ25ELGlCQUFpQixtREFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksaUVBQVU7QUFDdEI7QUFDQSxDQUFDOztBQUVEO0FBQ3VEO0FBQ3VCO0FBQ2xCO0FBQzVELFlBQVksbURBQVU7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QUNuQixPQUFPO0FBQ1AscUJBQXFCLGlCQUFpQjtBQUN0QyxlQUFlLHdEQUFJO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLDJEQUFPO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFVQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9ucy9kaXN0L2luZGV4LmpzP2M4NTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NoYXJhY3Rlci1jb3VudC9jaGFyYWN0ZXItY291bnQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbnZhciBDaGFyYWN0ZXJDb3VudCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiBcImNoYXJhY3RlckNvdW50XCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgbW9kZTogXCJ0ZXh0U2l6ZVwiLFxuICAgICAgdGV4dENvdW50ZXI6ICh0ZXh0KSA9PiB0ZXh0Lmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudGVyOiAodGV4dCkgPT4gdGV4dC5zcGxpdChcIiBcIikuZmlsdGVyKCh3b3JkKSA9PiB3b3JkICE9PSBcIlwiKS5sZW5ndGhcbiAgICB9O1xuICB9LFxuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFyYWN0ZXJzOiAoKSA9PiAwLFxuICAgICAgd29yZHM6ICgpID0+IDBcbiAgICB9O1xuICB9LFxuICBvbkJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgbW9kZSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpIHx8IHRoaXMub3B0aW9ucy5tb2RlO1xuICAgICAgaWYgKG1vZGUgPT09IFwidGV4dFNpemVcIikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgdm9pZCAwLCBcIiBcIik7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGV4dENvdW50ZXIodGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5ub2RlU2l6ZTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcmFnZS53b3JkcyA9IChvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubm9kZSkgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jO1xuICAgICAgY29uc3QgdGV4dCA9IG5vZGUudGV4dEJldHdlZW4oMCwgbm9kZS5jb250ZW50LnNpemUsIFwiIFwiLCBcIiBcIik7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndvcmRDb3VudGVyKHRleHQpO1xuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBsZXQgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gZmFsc2U7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJjaGFyYWN0ZXJDb3VudFwiKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChpbml0aWFsRXZhbHVhdGlvbkRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLm9wdGlvbnMubGltaXQ7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB2b2lkIDAgfHwgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluaXRpYWxDb250ZW50U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogbmV3U3RhdGUuZG9jIH0pO1xuICAgICAgICAgIGlmIChpbml0aWFsQ29udGVudFNpemUgPiBsaW1pdCkge1xuICAgICAgICAgICAgY29uc3Qgb3ZlciA9IGluaXRpYWxDb250ZW50U2l6ZSAtIGxpbWl0O1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IDA7XG4gICAgICAgICAgICBjb25zdCB0byA9IG92ZXI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBbQ2hhcmFjdGVyQ291bnRdIEluaXRpYWwgY29udGVudCBleGNlZWRlZCBsaW1pdCBvZiAke2xpbWl0fSBjaGFyYWN0ZXJzLiBDb250ZW50IHdhcyBhdXRvbWF0aWNhbGx5IHRyaW1tZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbEV2YWx1YXRpb25Eb25lID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMub3B0aW9ucy5saW1pdDtcbiAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgbGltaXQgPT09IDAgfHwgbGltaXQgPT09IG51bGwgfHwgbGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyh7IG5vZGU6IHN0YXRlLmRvYyB9KTtcbiAgICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKG5ld1NpemUgPD0gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplIDw9IG9sZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YShcInBhc3RlXCIpO1xuICAgICAgICAgIGlmICghaXNQYXN0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb24uJGhlYWQucG9zO1xuICAgICAgICAgIGNvbnN0IG92ZXIgPSBuZXdTaXplIC0gbGltaXQ7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHBvcyAtIG92ZXI7XG4gICAgICAgICAgY29uc3QgdG8gPSBwb3M7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRTaXplID4gbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9kcm9wLWN1cnNvci9kcm9wLWN1cnNvci50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjIgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZHJvcGN1cnNvclwiO1xudmFyIERyb3BjdXJzb3IgPSBFeHRlbnNpb24yLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZHJvcEN1cnNvclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3IodGhpcy5vcHRpb25zKV07XG4gIH1cbn0pO1xuXG4vLyBzcmMvZm9jdXMvZm9jdXMudHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb24zIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIsIFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcIkB0aXB0YXAvcG0vc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwiQHRpcHRhcC9wbS92aWV3XCI7XG52YXIgRm9jdXMgPSBFeHRlbnNpb24zLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZm9jdXNcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NOYW1lOiBcImhhcy1mb2N1c1wiLFxuICAgICAgbW9kZTogXCJhbGxcIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjIoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkyKFwiZm9jdXNcIiksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZGVjb3JhdGlvbnM6ICh7IGRvYywgc2VsZWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSwgaXNGb2N1c2VkIH0gPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0VkaXRhYmxlIHx8ICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1heExldmVscyA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09IFwiZGVlcGVzdFwiKSB7XG4gICAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heExldmVscyArPSAxO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSAwO1xuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemUgLSAxO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2ZTY29wZSA9IHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRlZXBlc3RcIiAmJiBtYXhMZXZlbHMgLSBjdXJyZW50TGV2ZWwgPiAwIHx8IHRoaXMub3B0aW9ucy5tb2RlID09PSBcInNoYWxsb3dlc3RcIiAmJiBjdXJyZW50TGV2ZWwgPiAxO1xuICAgICAgICAgICAgICBpZiAob3V0T2ZTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJkZWVwZXN0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5vcHRpb25zLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9nYXAtY3Vyc29yL2dhcC1jdXJzb3IudHNcbmltcG9ydCB7IGNhbGxPclJldHVybiwgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjQsIGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSBcIkB0aXB0YXAvcG0vZ2FwY3Vyc29yXCI7XG52YXIgR2FwY3Vyc29yID0gRXh0ZW5zaW9uNC5jcmVhdGUoe1xuICBuYW1lOiBcImdhcEN1cnNvclwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtnYXBDdXJzb3IoKV07XG4gIH0sXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBhbGxvd0dhcEN1cnNvcjogKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgXCJhbGxvd0dhcEN1cnNvclwiLCBjb250ZXh0KSkpICE9IG51bGwgPyBfYSA6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL3BsYWNlaG9sZGVyL3BsYWNlaG9sZGVyLnRzXG5pbXBvcnQgeyBFeHRlbnNpb24gYXMgRXh0ZW5zaW9uNSwgaXNOb2RlRW1wdHkgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMywgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMiwgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MiB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbjUuY3JlYXRlKHtcbiAgbmFtZTogXCJwbGFjZWhvbGRlclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiBcImlzLWVkaXRvci1lbXB0eVwiLFxuICAgICAgZW1wdHlOb2RlQ2xhc3M6IFwiaXMtZW1wdHlcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBcIldyaXRlIHNvbWV0aGluZyBcXHUyMDI2XCIsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4zKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5MyhcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlXaGVuRWRpdGFibGU7XG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eURvYyA9IHRoaXMuZWRpdG9yLmlzRW1wdHk7XG4gICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBoYXNBbmNob3IgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmIGlzTm9kZUVtcHR5KG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoKGhhc0FuY2hvciB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5Q3VycmVudCkgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbdGhpcy5vcHRpb25zLmVtcHR5Tm9kZUNsYXNzXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eURvYykge1xuICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMub3B0aW9ucy5lbXB0eUVkaXRvckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24yLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogY2xhc3Nlcy5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIFwiZGF0YS1wbGFjZWhvbGRlclwiOiB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIoe1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIGhhc0FuY2hvclxuICAgICAgICAgICAgICAgICAgfSkgOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldDIuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3NlbGVjdGlvbi9zZWxlY3Rpb24udHNcbmltcG9ydCB7IEV4dGVuc2lvbiBhcyBFeHRlbnNpb242LCBpc05vZGVTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNCwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTQgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiBhcyBEZWNvcmF0aW9uMywgRGVjb3JhdGlvblNldCBhcyBEZWNvcmF0aW9uU2V0MyB9IGZyb20gXCJAdGlwdGFwL3BtL3ZpZXdcIjtcbnZhciBTZWxlY3Rpb24gPSBFeHRlbnNpb242LmNyZWF0ZSh7XG4gIG5hbWU6IFwic2VsZWN0aW9uXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTmFtZTogXCJzZWxlY3Rpb25cIlxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbjQoe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXk0KFwic2VsZWN0aW9uXCIpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5IHx8IGVkaXRvci5pc0ZvY3VzZWQgfHwgIWVkaXRvci5pc0VkaXRhYmxlIHx8IGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pIHx8IGVkaXRvci52aWV3LmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQzLmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgRGVjb3JhdGlvbjMuaW5saW5lKHN0YXRlLnNlbGVjdGlvbi5mcm9tLCBzdGF0ZS5zZWxlY3Rpb24udG8sIHtcbiAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL3RyYWlsaW5nLW5vZGUvdHJhaWxpbmctbm9kZS50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjcgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luNSwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTUgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuZnVuY3Rpb24gbm9kZUVxdWFsc1R5cGUoeyB0eXBlcywgbm9kZSB9KSB7XG4gIHJldHVybiBub2RlICYmIEFycmF5LmlzQXJyYXkodHlwZXMpICYmIHR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZSkgfHwgKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZSkgPT09IHR5cGVzO1xufVxudmFyIFRyYWlsaW5nTm9kZSA9IEV4dGVuc2lvbjcuY3JlYXRlKHtcbiAgbmFtZTogXCJ0cmFpbGluZ05vZGVcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgIG5vdEFmdGVyOiBbXVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luS2V5NSh0aGlzLm5hbWUpO1xuICAgIGNvbnN0IGRpc2FibGVkTm9kZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmVkaXRvci5zY2hlbWEubm9kZXMpLm1hcCgoWywgdmFsdWVdKSA9PiB2YWx1ZSkuZmlsdGVyKChub2RlKSA9PiAodGhpcy5vcHRpb25zLm5vdEFmdGVyIHx8IFtdKS5jb25jYXQodGhpcy5vcHRpb25zLm5vZGUpLmluY2x1ZGVzKG5vZGUubmFtZSkpO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luNSh7XG4gICAgICAgIGtleTogcGx1Z2luLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKF8sIF9fLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZG9jLCB0ciwgc2NoZW1hIH0gPSBzdGF0ZTtcbiAgICAgICAgICBjb25zdCBzaG91bGRJbnNlcnROb2RlQXRFbmQgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW3RoaXMub3B0aW9ucy5ub2RlXTtcbiAgICAgICAgICBpZiAoIXNob3VsZEluc2VydE5vZGVBdEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHIuaW5zZXJ0KGVuZFBvc2l0aW9uLCB0eXBlLmNyZWF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBpbml0OiAoXywgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gc3RhdGUudHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcHBseTogKHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdHIuZG9jLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvdW5kby1yZWRvL3VuZG8tcmVkby50c1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIEV4dGVuc2lvbjggfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSBcIkB0aXB0YXAvcG0vaGlzdG9yeVwiO1xudmFyIFVuZG9SZWRvID0gRXh0ZW5zaW9uOC5jcmVhdGUoe1xuICBuYW1lOiBcInVuZG9SZWRvXCIsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiAxMDAsXG4gICAgICBuZXdHcm91cERlbGF5OiA1MDBcbiAgICB9O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgIH0sXG4gICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2hpc3RvcnkodGhpcy5vcHRpb25zKV07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIk1vZC16XCI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgIFwiU2hpZnQtTW9kLXpcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgXCJNb2QteVwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgIFwiTW9kLVxcdTA0NEZcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgXCJTaGlmdC1Nb2QtXFx1MDQ0RlwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKClcbiAgICB9O1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIENoYXJhY3RlckNvdW50LFxuICBEcm9wY3Vyc29yLFxuICBGb2N1cyxcbiAgR2FwY3Vyc29yLFxuICBQbGFjZWhvbGRlcixcbiAgU2VsZWN0aW9uLFxuICBUcmFpbGluZ05vZGUsXG4gIFVuZG9SZWRvXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extensions/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/commands/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2NvbW1hbmRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vZGlzdC9jb21tYW5kcy9pbmRleC5qcz83ODZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/commands/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/dropcursor/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2Ryb3BjdXJzb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvZHJvcGN1cnNvci9pbmRleC5qcz9iOWZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRyb3BjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/dropcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/gapcursor/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2dhcGN1cnNvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvZ2FwY3Vyc29yL2luZGV4LmpzP2NmM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/gapcursor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/history/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/history/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2hpc3RvcnkvaW5kZXguanM/M2FjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBoaXN0b3J5L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItaGlzdG9yeVwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/history/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/keymap/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L2tleW1hcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qva2V5bWFwL2luZGV4LmpzPzYxYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/keymap/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/model/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/model/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L21vZGVsL2luZGV4LmpzP2YyOGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/model/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/schema-list/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3NjaGVtYS1saXN0L2luZGV4LmpzPzE5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/schema-list/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/state/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/state/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3N0YXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3Qvc3RhdGUvaW5kZXguanM/NjEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/state/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/transform/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3RyYW5zZm9ybS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Rpc3QvdHJhbnNmb3JtL2luZGV4LmpzP2EyYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNmb3JtL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/transform/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dist/view/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/dist/view/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kaXN0L3ZpZXcvaW5kZXguanM/NjM2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dist/view/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Extension),\n/* harmony export */   Fragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Fragment),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Mark),\n/* harmony export */   MarkView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView),\n/* harmony export */   MarkViewContent: () => (/* binding */ MarkViewContent),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactMarkView: () => (/* binding */ ReactMarkView),\n/* harmony export */   ReactMarkViewContext: () => (/* binding */ ReactMarkViewContext),\n/* harmony export */   ReactMarkViewRenderer: () => (/* binding */ ReactMarkViewRenderer),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContentProvider: () => (/* binding */ ReactNodeViewContentProvider),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.callOrReturn),\n/* harmony export */   canInsertNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createDocument),\n/* harmony export */   createElement: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createElement),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.findParentNodeClosestToPos),\n/* harmony export */   flattenExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.flattenExtensions),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getTextSerializersFromSchema),\n/* harmony export */   h: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.h),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isActive),\n/* harmony export */   isAndroid: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAndroid),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.removeDuplicates),\n/* harmony export */   resolveExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveExtensions),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.selectionToInsertionEnd),\n/* harmony export */   sortExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.sortExtensions),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.textblockTypeInputRule),\n/* harmony export */   updateMarkViewAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.updateMarkViewAttributes),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var fast_deep_equal_es6_react_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fast-deep-equal/es6/react.js */ \"(ssr)/./node_modules/fast-deep-equal/es6/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/Context.tsx\n\n\n// src/EditorContent.tsx\n\n\n\n\nvar mergeRefs = (...refs) => {\n  return (node) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ;\n        ref.current = node;\n      }\n    });\n  };\n};\nvar Portals = ({ contentComponent }) => {\n  const renderers = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: Object.values(renderers) });\n};\nfunction getInstance() {\n  const subscribers = /* @__PURE__ */ new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach((subscriber) => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = { ...renderers };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach((subscriber) => subscriber());\n    }\n  };\n}\nvar PureEditorContent = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      if (!this.state.hasContentComponentInitialized) {\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState((prevState) => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    if (!((_a = editor.options.element) == null ? void 0 : _a.firstChild)) {\n      return;\n    }\n    const newElement = document.createElement(\"div\");\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n  render() {\n    const { editor, innerRef, ...rest } = this.props;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n      (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Portals, { contentComponent: editor.contentComponent })\n    ] });\n  }\n};\nvar EditorContentWithKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  (props, ref) => {\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n      return Math.floor(Math.random() * 4294967295).toString();\n    }, [props.editor]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props\n    });\n  }\n);\nvar EditorContent = react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n\n// src/useEditor.ts\n\n\n\n\n// src/useEditorState.ts\n\n\n\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar EditorStateManager = class {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return { editor: null, transactionNumber: 0 };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach((callback) => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on(\"transaction\", fn);\n      return () => {\n        currentEditor.off(\"transaction\", fn);\n      };\n    }\n    return void 0;\n  }\n};\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorStateManager(options.editor));\n  const selectedState = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_5__.useSyncExternalStoreWithSelector)(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector,\n    (_a = options.equalityFn) != null ? _a : fast_deep_equal_es6_react_js__WEBPACK_IMPORTED_MODULE_4__\n  );\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n  return selectedState;\n}\n\n// src/useEditor.ts\nvar isDev = \"development\" !== \"production\";\nvar isSSR = typeof window === \"undefined\";\nvar isNext = isSSR || Boolean(typeof window !== \"undefined\" && window.next);\nvar EditorInstanceManager = class _EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = /* @__PURE__ */ new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = \"\";\n    this.options = options;\n    this.subscriptions = /* @__PURE__ */ new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.subscriptions.forEach((cb) => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === void 0) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          throw new Error(\n            \"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\"\n          );\n        }\n        return null;\n      }\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      throw new Error(\n        \"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\"\n      );\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDelete: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.Editor(optionsToApply);\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every((key) => {\n      if ([\n        \"onCreate\",\n        \"onBeforeCreate\",\n        \"onDestroy\",\n        \"onUpdate\",\n        \"onTransaction\",\n        \"onFocus\",\n        \"onBlur\",\n        \"onSelectionUpdate\",\n        \"onContentError\",\n        \"onDrop\",\n        \"onPaste\"\n      ].includes(key)) {\n        return true;\n      }\n      if (key === \"extensions\" && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    return () => {\n      this.isComponentMounted = true;\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      if (this.previousDeps === null) {\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        if (currentEditor) {\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n    }, 1);\n  }\n};\nfunction useEditor(options = {}, deps = []) {\n  const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n        return null;\n      }\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\n\n// src/Context.tsx\n\nvar EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\nfunction EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}) {\n  const editor = useEditor(editorOptions);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ editor }), [editor]);\n  if (!editor) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(EditorContext.Provider, { value: contextValue, children: [\n    slotBefore,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorConsumer, { children: ({ editor: currentEditor }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(EditorContent, { editor: currentEditor, ...editorContainerProps }) }),\n    children,\n    slotAfter\n  ] });\n}\n\n// src/useReactNodeView.ts\n\nvar ReactNodeViewContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  onDragStart: () => {\n  },\n  nodeViewContentChildren: void 0,\n  nodeViewContentRef: () => {\n  }\n});\nvar ReactNodeViewContentProvider = ({ children, content }) => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children);\n};\nvar useReactNodeView = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n\n// src/NodeViewContent.tsx\n\nfunction NodeViewContent({\n  as: Tag = \"div\",\n  ...props\n}) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView();\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n          whiteSpace: \"pre-wrap\",\n          ...props.style\n        },\n        children: nodeViewContentChildren\n      }\n    )\n  );\n}\n\n// src/NodeViewWrapper.tsx\n\n\nvar NodeViewWrapper = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView();\n  const Tag = props.as || \"div\";\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\n      Tag,\n      {\n        ...props,\n        ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart,\n        style: {\n          whiteSpace: \"normal\",\n          ...props.style\n        }\n      }\n    )\n  );\n});\n\n// src/ReactMarkViewRenderer.tsx\n\n\n\n// src/ReactRenderer.tsx\n\n\n\nfunction isClassComponent(Component) {\n  return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  if (isMemoComponent(Component)) {\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\nfunction isReact19Plus() {\n  try {\n    if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n      const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split(\".\")[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {\n  }\n  return false;\n}\nvar ReactRenderer = class {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, { editor, props = {}, as = \"div\", className = \"\" }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 4294967295).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add(\"react-renderer\");\n    if (className) {\n      this.element.classList.add(...className.split(\" \"));\n    }\n    if (this.editor.isInitialized) {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = { ...props };\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      elementProps.ref = (ref) => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Component, { ...elementProps });\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props = {}) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach((key) => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n};\n\n// src/ReactMarkViewRenderer.tsx\n\nvar ReactMarkViewContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  markViewContentRef: () => {\n  }\n});\nvar MarkViewContent = (props) => {\n  const { as: Tag = \"span\", ...rest } = props;\n  const { markViewContentRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ReactMarkViewContext);\n  return (\n    // @ts-ignore\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Tag, { ...rest, ref: markViewContentRef, \"data-mark-view-content\": \"\" })\n  );\n};\nvar ReactMarkView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.MarkView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    this.didMountContentDomElement = false;\n    const { as = \"span\", attrs, className = \"\" } = options || {};\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) };\n    this.contentDOMElement = document.createElement(\"span\");\n    const markViewContentRef = (el) => {\n      if (el && this.contentDOMElement && el.firstChild !== this.contentDOMElement) {\n        el.appendChild(this.contentDOMElement);\n        this.didMountContentDomElement = true;\n      }\n    };\n    const context = {\n      markViewContentRef\n    };\n    const ReactMarkViewProvider = react__WEBPACK_IMPORTED_MODULE_0__.memo((componentProps2) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactMarkViewContext.Provider, { value: context, children: react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, componentProps2) });\n    });\n    ReactMarkViewProvider.displayName = \"ReactNodeView\";\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim()\n    });\n    if (attrs) {\n      this.renderer.updateAttributes(attrs);\n    }\n  }\n  get dom() {\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    if (!this.didMountContentDomElement) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n};\nfunction ReactMarkViewRenderer(component, options = {}) {\n  return (props) => new ReactMarkView(component, props, options);\n}\n\n// src/ReactNodeViewRenderer.tsx\n\n\n\nvar ReactNodeView = class extends _tiptap_core__WEBPACK_IMPORTED_MODULE_6__.NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n      this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n      this.contentDOMElement.style.whiteSpace = \"inherit\";\n      const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = (string) => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = (element) => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        if (element.hasAttribute(\"data-node-view-wrapper\")) {\n          element.removeAttribute(\"data-node-view-wrapper\");\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = { onDragStart, nodeViewContentRef };\n    const Component = this.component;\n    const ReactNodeViewProvider = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((componentProps) => {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactNodeViewContext.Provider, { value: context, children: (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps) });\n    });\n    ReactNodeViewProvider.displayName = \"ReactNodeView\";\n    let as = this.node.isInline ? \"span\" : \"div\";\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const { className = \"\" } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n      throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const { from, to } = this.editor.state.selection;\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return;\n      }\n      this.selectNode();\n    } else {\n      if (!this.renderer.props.selected) {\n        return;\n      }\n      this.deselectNode();\n    }\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = (props) => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === \"function\") {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === \"function\") {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({ node, decorations, innerDecorations })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({ node, decorations, innerDecorations });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === \"function\") {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_6__.getRenderedAttributes)(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n};\nfunction ReactNodeViewRenderer(component, options) {\n  return (props) => {\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzJEOztBQUUzRDtBQUMwQztBQUNUO0FBQzRDO0FBQ3JCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLG9CQUFvQiwyRkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLG9DQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBcUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEMsMkJBQTJCLHVEQUFJLENBQUMsdURBQVEsSUFBSTtBQUM1QyxzQkFBc0Isc0RBQUcsVUFBVSwwREFBMEQ7QUFDN0YsNkVBQTZFLHNEQUFHLFlBQVksMkNBQTJDO0FBQ3ZJLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFVO0FBQ3JDO0FBQ0EsZ0JBQWdCLDBDQUFhO0FBQzdCO0FBQ0EsS0FBSztBQUNMLFdBQVcsZ0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHVDQUFVOztBQUU5QjtBQUNzQztBQUMwRTtBQUNWOztBQUV0RztBQUNxRDtBQUN1QjtBQUNxQjtBQUNqRyxnRUFBZ0Usa0RBQWUsR0FBRyw0Q0FBUztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUFRO0FBQ3ZDLHdCQUF3QiwrR0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseURBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsb0RBQWE7QUFDZjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw0QkFBNEIsNkNBQU07QUFDbEM7QUFDQSw0QkFBNEIsK0NBQVM7QUFDckMsaUJBQWlCLDJGQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0RBQWM7QUFDaEIsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUMrRDtBQUMvRCxvQkFBb0Isb0RBQWE7QUFDakM7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2QkFBNkIsaURBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsOENBQU8sVUFBVSxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBSywyQkFBMkI7QUFDekQ7QUFDQSxvQkFBb0Isc0RBQUksbUJBQW1CLGFBQWEsdUJBQXVCLHFCQUFxQixzREFBSSxrQkFBa0IsZ0RBQWdELEdBQUc7QUFDN0s7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNrRztBQUNsRywyQkFBMkIsb0RBQWM7QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQyxtQkFBbUI7QUFDekQsU0FBUyxvREFBYSxrQ0FBa0MsU0FBUyxvQ0FBb0M7QUFDckc7QUFDQSw2QkFBNkIsaURBQVc7O0FBRXhDO0FBQ2dEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLDhDQUE4QztBQUN4RDtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQjtBQUNxQjtBQUNoRCxzQkFBc0IsNkNBQWlCO0FBQ3ZDLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3dDO0FBQ2I7O0FBRTNCO0FBQ2dEO0FBQ1Y7QUFDVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBWTtBQUNwQixvQ0FBb0MsMENBQVk7QUFDaEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0IsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFTO0FBQ2Y7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0RBQUksY0FBYyxpQkFBaUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDZ0Q7QUFDaEQsMkJBQTJCLGdEQUFvQjtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSxxQkFBcUIsRUFBRSw2Q0FBaUI7QUFDbEQ7QUFDQTtBQUNBLG9CQUFvQixzREFBSSxRQUFRLGdFQUFnRTtBQUNoRztBQUNBO0FBQ0Esa0NBQWtDLGtEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBVztBQUM3Qyw2QkFBNkIsc0RBQUksa0NBQWtDLDBCQUEwQixnREFBb0IsOEJBQThCO0FBQy9JLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQixFQUFFLFVBQVU7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUMrRDtBQUNVO0FBQ3pCO0FBQ2hELGtDQUFrQyxrREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLFdBQVcsZ0RBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrQ0FBa0MsMkNBQUk7QUFDdEMsNkJBQTZCLHNEQUFJLGtDQUFrQywwQkFBMEIsb0RBQWMsNkJBQTZCO0FBQ3hJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsRUFBRSxVQUFVO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1FQUFxQjtBQUNwRCx3Q0FBd0MsaUNBQWlDO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZCO0FBc0IzQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcmVhY3QvZGlzdC9pbmRleC5qcz9hZjA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9Db250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvRWRpdG9yQ29udGVudC50c3hcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQsIGpzeCwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIG1lcmdlUmVmcyA9ICguLi5yZWZzKSA9PiB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZihub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIDtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufTtcbnZhciBQb3J0YWxzID0gKHsgY29udGVudENvbXBvbmVudCB9KSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVycyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIGNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlLFxuICAgIGNvbnRlbnRDb21wb25lbnQuZ2V0U25hcHNob3QsXG4gICAgY29udGVudENvbXBvbmVudC5nZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogT2JqZWN0LnZhbHVlcyhyZW5kZXJlcnMpIH0pO1xufTtcbmZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCByZW5kZXJlcnMgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICBzdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdCgpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgfSxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHtcbiAgICAgIHJldHVybiByZW5kZXJlcnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IE5vZGVWaWV3IFJlbmRlcmVyIHRvIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlcnMgPSB7XG4gICAgICAgIC4uLnJlbmRlcmVycyxcbiAgICAgICAgW2lkXTogUmVhY3RET00uY3JlYXRlUG9ydGFsKHJlbmRlcmVyLnJlYWN0RWxlbWVudCwgcmVuZGVyZXIuZWxlbWVudCwgaWQpXG4gICAgICB9O1xuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcigpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBOb2RlVmlldyBSZW5kZXJlciBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgcmVtb3ZlUmVuZGVyZXIoaWQpIHtcbiAgICAgIGNvbnN0IG5leHRSZW5kZXJlcnMgPSB7IC4uLnJlbmRlcmVycyB9O1xuICAgICAgZGVsZXRlIG5leHRSZW5kZXJlcnNbaWRdO1xuICAgICAgcmVuZGVyZXJzID0gbmV4dFJlbmRlcmVycztcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIoKSk7XG4gICAgfVxuICB9O1xufVxudmFyIFB1cmVFZGl0b3JDb250ZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5lZGl0b3JDb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBoYXNDb250ZW50Q29tcG9uZW50SW5pdGlhbGl6ZWQ6IEJvb2xlYW4oKF9hID0gcHJvcHMuZWRpdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudENvbXBvbmVudClcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgIGlmIChlZGl0b3IgJiYgIWVkaXRvci5pc0Rlc3Ryb3llZCAmJiBlZGl0b3Iub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICBpZiAoZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWRpdG9yQ29udGVudFJlZi5jdXJyZW50O1xuICAgICAgZWxlbWVudC5hcHBlbmQoLi4uZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5jaGlsZE5vZGVzKTtcbiAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IGdldEluc3RhbmNlKCk7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQgPSBlZGl0b3IuY29udGVudENvbXBvbmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3I7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICBlZGl0b3Iudmlldy5zZXRQcm9wcyh7XG4gICAgICAgIG5vZGVWaWV3czoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZVRvQ29udGVudENvbXBvbmVudCgpO1xuICAgIH1cbiAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgaWYgKCEoKF9hID0gZWRpdG9yLm9wdGlvbnMuZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpcnN0Q2hpbGQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5ld0VsZW1lbnQuYXBwZW5kKC4uLmVkaXRvci5vcHRpb25zLmVsZW1lbnQuY2hpbGROb2Rlcyk7XG4gICAgZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgZWxlbWVudDogbmV3RWxlbWVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBtZXJnZVJlZnMoaW5uZXJSZWYsIHRoaXMuZWRpdG9yQ29udGVudFJlZiksIC4uLnJlc3QgfSksXG4gICAgICAoZWRpdG9yID09IG51bGwgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgJiYgLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWxzLCB7IGNvbnRlbnRDb21wb25lbnQ6IGVkaXRvci5jb250ZW50Q29tcG9uZW50IH0pXG4gICAgXSB9KTtcbiAgfVxufTtcbnZhciBFZGl0b3JDb250ZW50V2l0aEtleSA9IGZvcndhcmRSZWYoXG4gIChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSkudG9TdHJpbmcoKTtcbiAgICB9LCBbcHJvcHMuZWRpdG9yXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHVyZUVkaXRvckNvbnRlbnQsIHtcbiAgICAgIGtleSxcbiAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG4pO1xudmFyIEVkaXRvckNvbnRlbnQgPSBSZWFjdC5tZW1vKEVkaXRvckNvbnRlbnRXaXRoS2V5KTtcblxuLy8gc3JjL3VzZUVkaXRvci50c1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgdXNlRGVidWdWYWx1ZSBhcyB1c2VEZWJ1Z1ZhbHVlMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vLyBzcmMvdXNlRWRpdG9yU3RhdGUudHNcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbC9lczYvcmVhY3QuanNcIjtcbmltcG9ydCB7IHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG52YXIgRWRpdG9yU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsRWRpdG9yKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgdGhpcy5sYXN0VHJhbnNhY3Rpb25OdW1iZXIgPSAwO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZWRpdG9yID0gaW5pdGlhbEVkaXRvcjtcbiAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgIHRoaXMuZ2V0U25hcHNob3QgPSB0aGlzLmdldFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdCA9IHRoaXMuZ2V0U2VydmVyU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNuYXBzaG90KCkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgIH1cbiAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlciA9IHRoaXMudHJhbnNhY3Rpb25OdW1iZXI7XG4gICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgKi9cbiAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogV2F0Y2ggdGhlIGVkaXRvciBpbnN0YW5jZSBmb3IgY2hhbmdlcy5cbiAgICovXG4gIHdhdGNoKG5leHRFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICBjdXJyZW50RWRpdG9yLm9uKFwidHJhbnNhY3Rpb25cIiwgZm4pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudEVkaXRvci5vZmYoXCJ0cmFuc2FjdGlvblwiLCBmbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yU3RhdGUob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IFtlZGl0b3JTdGF0ZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvclN0YXRlTWFuYWdlcihvcHRpb25zLmVkaXRvcikpO1xuICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U25hcHNob3QsXG4gICAgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNlcnZlclNuYXBzaG90LFxuICAgIG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgKF9hID0gb3B0aW9ucy5lcXVhbGl0eUZuKSAhPSBudWxsID8gX2EgOiBkZWVwRXF1YWxcbiAgKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gIH0sIFtvcHRpb25zLmVkaXRvciwgZWRpdG9yU3RhdGVNYW5hZ2VyXSk7XG4gIHVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG4vLyBzcmMvdXNlRWRpdG9yLnRzXG52YXIgaXNEZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xudmFyIGlzTmV4dCA9IGlzU1NSIHx8IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmV4dCk7XG52YXIgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyID0gY2xhc3MgX0VkaXRvckluc3RhbmNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJzY3JpcHRpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgKiBoYXMgYmVlbiBjcmVhdGVkIG9yIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVkaXRvciBoYXMgYmVlbiBtb3VudGVkLlxuICAgICAqL1xuICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzRGVwcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpbnN0YW5jZSBJRC4gVGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBlZGl0b3IgaW5zdGFuY2UuIEFuZCB3aWxsIGJlIHJlLWdlbmVyYXRlZCBmb3IgZWFjaCBuZXcgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdGhpcy5pbnN0YW5jZUlkID0gXCJcIjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgdGhpcy5nZXRFZGl0b3IgPSB0aGlzLmdldEVkaXRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmcmVzaEVkaXRvckluc3RhbmNlID0gdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblJlbmRlciA9IHRoaXMub25SZW5kZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZUVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yLmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgZ2V0SW5pdGlhbEVkaXRvcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGlzU1NSIHx8IGlzTmV4dCkge1xuICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlRpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBwbGVhc2Ugc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgZXhwbGljaXRseSB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIgJiYgaXNTU1IgJiYgaXNEZXYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaXB0YXAgRXJyb3I6IFNTUiBoYXMgYmVlbiBkZXRlY3RlZCwgYW5kIGBpbW1lZGlhdGVseVJlbmRlcmAgaGFzIGJlZW4gc2V0IHRvIGB0cnVlYCB0aGlzIGlzIGFuIHVuc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXkgcmVzdWx0IGluIGVycm9ycywgZXhwbGljaXRseSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCB0byBgZmFsc2VgIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmN1cnJlbnQuaW1tZWRpYXRlbHlSZW5kZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVkaXRvcigpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjcmVhdGVFZGl0b3IoKSB7XG4gICAgY29uc3Qgb3B0aW9uc1RvQXBwbHkgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuY3VycmVudCxcbiAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBieSBkZWZhdWx0XG4gICAgICBvbkJlZm9yZUNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJlZm9yZUNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uQmx1cjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkJsdXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uRGVzdHJveTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRlc3Ryb3kpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkZvY3VzOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRm9jdXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNhY3Rpb246ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25UcmFuc2FjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAoLi4uYXJncykgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uVXBkYXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBvbkRyb3A6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Ecm9wKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25QYXN0ZTogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblBhc3RlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgb25EZWxldGU6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25EZWxldGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVkaXRvciA9IG5ldyBFZGl0b3Iob3B0aW9uc1RvQXBwbHkpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBnZXRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yO1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgZGlzYWJsZSB0aGUgZWRpdG9yIG9uIHRoZSBzZXJ2ZXItc2lkZS5cbiAgICovXG4gIGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAqL1xuICBzdWJzY3JpYmUob25TdG9yZUNoYW5nZSkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQob25TdG9yZUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZU9wdGlvbnMoYSwgYikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICBpZiAoW1xuICAgICAgICBcIm9uQ3JlYXRlXCIsXG4gICAgICAgIFwib25CZWZvcmVDcmVhdGVcIixcbiAgICAgICAgXCJvbkRlc3Ryb3lcIixcbiAgICAgICAgXCJvblVwZGF0ZVwiLFxuICAgICAgICBcIm9uVHJhbnNhY3Rpb25cIixcbiAgICAgICAgXCJvbkZvY3VzXCIsXG4gICAgICAgIFwib25CbHVyXCIsXG4gICAgICAgIFwib25TZWxlY3Rpb25VcGRhdGVcIixcbiAgICAgICAgXCJvbkNvbnRlbnRFcnJvclwiLFxuICAgICAgICBcIm9uRHJvcFwiLFxuICAgICAgICBcIm9uUGFzdGVcIlxuICAgICAgXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJleHRlbnNpb25zXCIgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAoYS5leHRlbnNpb25zLmxlbmd0aCAhPT0gYi5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5leHRlbnNpb25zLmV2ZXJ5KChleHRlbnNpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGRlcHMgVGhlIGRlcGVuZGVuY2llcyB0byB3YXRjaCBmb3IgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGNsZWFudXAgZnVuY3Rpb25cbiAgICovXG4gIG9uUmVuZGVyKGRlcHMpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25UaW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQgJiYgZGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCFfRWRpdG9ySW5zdGFuY2VNYW5hZ2VyLmNvbXBhcmVPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50LCB0aGlzLmVkaXRvci5vcHRpb25zKSkge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmN1cnJlbnQsXG4gICAgICAgICAgICBlZGl0YWJsZTogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlY3JlYXRlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcHNBcmVFcXVhbCA9IHRoaXMucHJldmlvdXNEZXBzLmxlbmd0aCA9PT0gZGVwcy5sZW5ndGggJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVkaXRvciAmJiAhdGhpcy5lZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgdGhpcy5wcmV2aW91c0RlcHMgPSBkZXBzO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlZHVsZSB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogVGhpcyB3aWxsIG9ubHkgZGVzdHJveSB0aGUgZWRpdG9yIGlmIGl0IHdhcyBub3QgbW91bnRlZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICovXG4gIHNjaGVkdWxlRGVzdHJveSgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5zdGFuY2VJZCA9IHRoaXMuaW5zdGFuY2VJZDtcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgY3VycmVudEVkaXRvci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjdXJyZW50RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJZCA9PT0gY3VycmVudEluc3RhbmNlSWQpIHtcbiAgICAgICAgICB0aGlzLnNldEVkaXRvcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEpO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlRWRpdG9yKG9wdGlvbnMgPSB7fSwgZGVwcyA9IFtdKSB7XG4gIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICBtb3N0UmVjZW50T3B0aW9ucy5jdXJyZW50ID0gb3B0aW9ucztcbiAgY29uc3QgW2luc3RhbmNlTWFuYWdlcl0gPSB1c2VTdGF0ZTIoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICBjb25zdCBlZGl0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgaW5zdGFuY2VNYW5hZ2VyLnN1YnNjcmliZSxcbiAgICBpbnN0YW5jZU1hbmFnZXIuZ2V0RWRpdG9yLFxuICAgIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICB1c2VEZWJ1Z1ZhbHVlMihlZGl0b3IpO1xuICB1c2VFZmZlY3QyKGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gIHVzZUVkaXRvclN0YXRlKHtcbiAgICBlZGl0b3IsXG4gICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UgfHwgb3B0aW9ucy5zaG91bGRSZXJlbmRlck9uVHJhbnNhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZWx5UmVuZGVyICYmIHRyYW5zYWN0aW9uTnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG4vLyBzcmMvQ29udGV4dC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyLCBqc3hzIGFzIGpzeHMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBlZGl0b3I6IG51bGxcbn0pO1xudmFyIEVkaXRvckNvbnN1bWVyID0gRWRpdG9yQ29udGV4dC5Db25zdW1lcjtcbnZhciB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIHNsb3RBZnRlcixcbiAgc2xvdEJlZm9yZSxcbiAgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSxcbiAgLi4uZWRpdG9yT3B0aW9uc1xufSkge1xuICBjb25zdCBlZGl0b3IgPSB1c2VFZGl0b3IoZWRpdG9yT3B0aW9ucyk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgZWRpdG9yIH0pLCBbZWRpdG9yXSk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBbXG4gICAgc2xvdEJlZm9yZSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MihFZGl0b3JDb25zdW1lciwgeyBjaGlsZHJlbjogKHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEVkaXRvckNvbnRlbnQsIHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yLCAuLi5lZGl0b3JDb250YWluZXJQcm9wcyB9KSB9KSxcbiAgICBjaGlsZHJlbixcbiAgICBzbG90QWZ0ZXJcbiAgXSB9KTtcbn1cblxuLy8gc3JjL3VzZVJlYWN0Tm9kZVZpZXcudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIGNyZWF0ZUVsZW1lbnQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdE5vZGVWaWV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKHtcbiAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgfSxcbiAgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW46IHZvaWQgMCxcbiAgbm9kZVZpZXdDb250ZW50UmVmOiAoKSA9PiB7XG4gIH1cbn0pO1xudmFyIFJlYWN0Tm9kZVZpZXdDb250ZW50UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgY29udGVudCB9KSA9PiB7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IG5vZGVWaWV3Q29udGVudENoaWxkcmVuOiBjb250ZW50IH0gfSwgY2hpbGRyZW4pO1xufTtcbnZhciB1c2VSZWFjdE5vZGVWaWV3ID0gKCkgPT4gdXNlQ29udGV4dDIoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG4vLyBzcmMvTm9kZVZpZXdDb250ZW50LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIE5vZGVWaWV3Q29udGVudCh7XG4gIGFzOiBUYWcgPSBcImRpdlwiLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IG5vZGVWaWV3Q29udGVudFJlZiwgbm9kZVZpZXdDb250ZW50Q2hpbGRyZW4gfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDMoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IG5vZGVWaWV3Q29udGVudFJlZixcbiAgICAgICAgXCJkYXRhLW5vZGUtdmlldy1jb250ZW50XCI6IFwiXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBub2RlVmlld0NvbnRlbnRDaGlsZHJlblxuICAgICAgfVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL05vZGVWaWV3V3JhcHBlci50c3hcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0My5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgb25EcmFnU3RhcnQgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgXCJkaXZcIjtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDQoXG4gICAgICBUYWcsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWYsXG4gICAgICAgIFwiZGF0YS1ub2RlLXZpZXctd3JhcHBlclwiOiBcIlwiLFxuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICk7XG59KTtcblxuLy8gc3JjL1JlYWN0TWFya1ZpZXdSZW5kZXJlci50c3hcbmltcG9ydCB7IE1hcmtWaWV3IH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlYWN0UmVuZGVyZXIudHN4XG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHJlYWN0VmVyc2lvbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5mb3J3YXJkX3JlZilcIiB8fCBDb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24gPT09IFwicmVhY3QuZm9yd2FyZF9yZWZcIikpO1xufVxuZnVuY3Rpb24gaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEodHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJiBDb21wb25lbnQuJCR0eXBlb2YgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSBcIlN5bWJvbChyZWFjdC5tZW1vKVwiIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gXCJyZWFjdC5tZW1vXCIpKTtcbn1cbmZ1bmN0aW9uIGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KSB7XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50LnR5cGU7XG4gICAgaWYgKHdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KHdyYXBwZWRDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWFjdDE5UGx1cygpIHtcbiAgdHJ5IHtcbiAgICBpZiAocmVhY3RWZXJzaW9uKSB7XG4gICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChyZWFjdFZlcnNpb24uc3BsaXQoXCIuXCIpWzBdLCAxMCk7XG4gICAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDE5O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFJlYWN0UmVuZGVyZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBjcmVhdGVzIGVsZW1lbnQgYW5kIHJlbmRlcnMgdGhlIHByb3ZpZGVkIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gXCJkaXZcIiwgY2xhc3NOYW1lID0gXCJcIiB9KSB7XG4gICAgdGhpcy5yZWYgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KS50b1N0cmluZygpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInJlYWN0LXJlbmRlcmVyXCIpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdChcIiBcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lZGl0b3IuaXNJbml0aWFsaXplZCkge1xuICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3QgaXNSZWFjdDE5ID0gaXNSZWFjdDE5UGx1cygpO1xuICAgIGNvbnN0IGNvbXBvbmVudENhblJlY2VpdmVSZWYgPSBjYW5SZWNlaXZlUmVmKENvbXBvbmVudCk7XG4gICAgY29uc3QgZWxlbWVudFByb3BzID0geyAuLi5wcm9wcyB9O1xuICAgIGlmIChlbGVtZW50UHJvcHMucmVmICYmICEoaXNSZWFjdDE5IHx8IGNvbXBvbmVudENhblJlY2VpdmVSZWYpKSB7XG4gICAgICBkZWxldGUgZWxlbWVudFByb3BzLnJlZjtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50UHJvcHMucmVmICYmIChpc1JlYWN0MTkgfHwgY29tcG9uZW50Q2FuUmVjZWl2ZVJlZikpIHtcbiAgICAgIGVsZW1lbnRQcm9wcy5yZWYgPSAocmVmKSA9PiB7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5yZWFjdEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8ganN4NShDb21wb25lbnQsIHsgLi4uZWxlbWVudFByb3BzIH0pO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRSZW5kZXJlcih0aGlzLmlkLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmUtcmVuZGVycyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggbmV3IHByb3BzLlxuICAgKi9cbiAgdXBkYXRlUHJvcHMocHJvcHMgPSB7fSkge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIChfYSA9IGVkaXRvciA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVSZW5kZXJlcih0aGlzLmlkKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9SZWFjdE1hcmtWaWV3UmVuZGVyZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlYWN0TWFya1ZpZXdDb250ZXh0ID0gUmVhY3Q0LmNyZWF0ZUNvbnRleHQoe1xuICBtYXJrVmlld0NvbnRlbnRSZWY6ICgpID0+IHtcbiAgfVxufSk7XG52YXIgTWFya1ZpZXdDb250ZW50ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgYXM6IFRhZyA9IFwic3BhblwiLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgeyBtYXJrVmlld0NvbnRlbnRSZWYgfSA9IFJlYWN0NC51c2VDb250ZXh0KFJlYWN0TWFya1ZpZXdDb250ZXh0KTtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDYoVGFnLCB7IC4uLnJlc3QsIHJlZjogbWFya1ZpZXdDb250ZW50UmVmLCBcImRhdGEtbWFyay12aWV3LWNvbnRlbnRcIjogXCJcIiB9KVxuICApO1xufTtcbnZhciBSZWFjdE1hcmtWaWV3ID0gY2xhc3MgZXh0ZW5kcyBNYXJrVmlldyB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbiAgICB0aGlzLmRpZE1vdW50Q29udGVudERvbUVsZW1lbnQgPSBmYWxzZTtcbiAgICBjb25zdCB7IGFzID0gXCJzcGFuXCIsIGF0dHJzLCBjbGFzc05hbWUgPSBcIlwiIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0geyAuLi5wcm9wcywgdXBkYXRlQXR0cmlidXRlczogdGhpcy51cGRhdGVBdHRyaWJ1dGVzLmJpbmQodGhpcykgfTtcbiAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgbWFya1ZpZXdDb250ZW50UmVmID0gKGVsKSA9PiB7XG4gICAgICBpZiAoZWwgJiYgdGhpcy5jb250ZW50RE9NRWxlbWVudCAmJiBlbC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgICAgICB0aGlzLmRpZE1vdW50Q29udGVudERvbUVsZW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG1hcmtWaWV3Q29udGVudFJlZlxuICAgIH07XG4gICAgY29uc3QgUmVhY3RNYXJrVmlld1Byb3ZpZGVyID0gUmVhY3Q0Lm1lbW8oKGNvbXBvbmVudFByb3BzMikgPT4ge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFJlYWN0TWFya1ZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBjb21wb25lbnRQcm9wczIpIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0TWFya1ZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9IFwiUmVhY3ROb2RlVmlld1wiO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVhY3RSZW5kZXJlcihSZWFjdE1hcmtWaWV3UHJvdmlkZXIsIHtcbiAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yLFxuICAgICAgcHJvcHM6IGNvbXBvbmVudFByb3BzLFxuICAgICAgYXMsXG4gICAgICBjbGFzc05hbWU6IGBtYXJrLSR7cHJvcHMubWFyay50eXBlLm5hbWV9ICR7Y2xhc3NOYW1lfWAudHJpbSgpXG4gICAgfSk7XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgIH1cbiAgfVxuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgaWYgKCF0aGlzLmRpZE1vdW50Q29udGVudERvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NRWxlbWVudDtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlYWN0TWFya1ZpZXdSZW5kZXJlcihjb21wb25lbnQsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gKHByb3BzKSA9PiBuZXcgUmVhY3RNYXJrVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL1JlYWN0Tm9kZVZpZXdSZW5kZXJlci50c3hcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcywgTm9kZVZpZXcgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyLCBjcmVhdGVSZWYsIG1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVhY3ROb2RlVmlldyA9IGNsYXNzIGV4dGVuZHMgTm9kZVZpZXcge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRET01FbGVtZW50VGFnKSB7XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5kYXRhc2V0Lm5vZGVWaWV3Q29udGVudFJlYWN0ID0gXCJcIjtcbiAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPSBcIlwiO1xuICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gXCJpbmhlcml0XCI7XG4gICAgICBjb25zdCBjb250ZW50VGFyZ2V0ID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGUtdmlldy1jb250ZW50XVwiKTtcbiAgICAgIGlmICghY29udGVudFRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250ZW50VGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0dXAgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQ2FsbGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgbW91bnQoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICBpbm5lckRlY29yYXRpb25zOiB0aGlzLmlubmVyRGVjb3JhdGlvbnMsXG4gICAgICB2aWV3OiB0aGlzLnZpZXcsXG4gICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHRoaXMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICBnZXRQb3M6ICgpID0+IHRoaXMuZ2V0UG9zKCksXG4gICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcbiAgICAgIHJlZjogY3JlYXRlUmVmKClcbiAgICB9O1xuICAgIGlmICghdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUpIHtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVGaXJzdENoYXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY29tcG9uZW50LmRpc3BsYXlOYW1lID0gY2FwaXRhbGl6ZUZpcnN0Q2hhcih0aGlzLmV4dGVuc2lvbi5uYW1lKTtcbiAgICB9XG4gICAgY29uc3Qgb25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgY29uc3Qgbm9kZVZpZXdDb250ZW50UmVmID0gKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIikpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IG9uRHJhZ1N0YXJ0LCBub2RlVmlld0NvbnRlbnRSZWYgfTtcbiAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBSZWFjdE5vZGVWaWV3UHJvdmlkZXIgPSBtZW1vKChjb21wb25lbnRQcm9wcykgPT4ge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY3JlYXRlRWxlbWVudDIoQ29tcG9uZW50LCBjb21wb25lbnRQcm9wcykgfSk7XG4gICAgfSk7XG4gICAgUmVhY3ROb2RlVmlld1Byb3ZpZGVyLmRpc3BsYXlOYW1lID0gXCJSZWFjdE5vZGVWaWV3XCI7XG4gICAgbGV0IGFzID0gdGhpcy5ub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcbiAgICAgIGFzID0gdGhpcy5vcHRpb25zLmFzO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYXNzTmFtZSA9IFwiXCIgfSA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSA9IHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZWFjdFJlbmRlcmVyKFJlYWN0Tm9kZVZpZXdQcm92aWRlciwge1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIHByb3BzLFxuICAgICAgYXMsXG4gICAgICBjbGFzc05hbWU6IGBub2RlLSR7dGhpcy5ub2RlLnR5cGUubmFtZX0gJHtjbGFzc05hbWV9YC50cmltKClcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci5vbihcInNlbGVjdGlvblVwZGF0ZVwiLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50QXR0cmlidXRlcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIERPTSBlbGVtZW50LlxuICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG5vZGUgdmlldy5cbiAgICovXG4gIGdldCBkb20oKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgJiYgISgoX2EgPSB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdmlldy13cmFwcGVyXCIpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJQbGVhc2UgdXNlIHRoZSBOb2RlVmlld1dyYXBwZXIgY29tcG9uZW50IGZvciB5b3VyIG5vZGUgdmlldy5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29udGVudCBET00gZWxlbWVudC5cbiAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSByaWNoLXRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICovXG4gIGdldCBjb250ZW50RE9NKCkge1xuICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGVkaXRvciBzZWxlY3Rpb24gdXBkYXRlLCBjaGVjayBpZiB0aGUgbm9kZSBpcyBzZWxlY3RlZC5cbiAgICogSWYgaXQgaXMsIGNhbGwgYHNlbGVjdE5vZGVgLCBvdGhlcndpc2UgY2FsbCBgZGVzZWxlY3ROb2RlYC5cbiAgICovXG4gIGhhbmRsZVNlbGVjdGlvblVwZGF0ZSgpIHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICBpZiAodHlwZW9mIHBvcyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zICsgdGhpcy5ub2RlLm5vZGVTaXplKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlci5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNlbGVjdE5vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbiB1cGRhdGUsIHVwZGF0ZSB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBUbyBwcmV2ZW50IHVubmVjZXNzYXJ5IHVwZGF0ZXMsIHRoZSBgdXBkYXRlYCBvcHRpb24gY2FuIGJlIHVzZWQuXG4gICAqL1xuICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMpIHtcbiAgICBjb25zdCByZXJlbmRlckNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBvbGROb2RlID0gdGhpcy5ub2RlO1xuICAgICAgY29uc3Qgb2xkRGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zO1xuICAgICAgY29uc3Qgb2xkSW5uZXJEZWNvcmF0aW9ucyA9IHRoaXMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBpbm5lckRlY29yYXRpb25zO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy51cGRhdGUoe1xuICAgICAgICBvbGROb2RlLFxuICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgbmV3Tm9kZTogbm9kZSxcbiAgICAgICAgbmV3RGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxuICAgICAgICBvbGRJbm5lckRlY29yYXRpb25zLFxuICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICB1cGRhdGVQcm9wczogKCkgPT4gcmVyZW5kZXJDb21wb25lbnQoeyBub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucyB9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB0aGlzLm5vZGUgJiYgdGhpcy5kZWNvcmF0aW9ucyA9PT0gZGVjb3JhdGlvbnMgJiYgdGhpcy5pbm5lckRlY29yYXRpb25zID09PSBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gaW5uZXJEZWNvcmF0aW9ucztcbiAgICByZXJlbmRlckNvbXBvbmVudCh7IG5vZGUsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgdGhlIG5vZGUuXG4gICAqIEFkZCB0aGUgYHNlbGVjdGVkYCBwcm9wIGFuZCB0aGUgYFByb3NlTWlycm9yLXNlbGVjdGVkbm9kZWAgY2xhc3MuXG4gICAqL1xuICBzZWxlY3ROb2RlKCkge1xuICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xuICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgfVxuICAvKipcbiAgICogRGVzZWxlY3QgdGhlIG5vZGUuXG4gICAqIFJlbW92ZSB0aGUgYHNlbGVjdGVkYCBwcm9wIGFuZCB0aGUgYFByb3NlTWlycm9yLXNlbGVjdGVkbm9kZWAgY2xhc3MuXG4gICAqL1xuICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmVkaXRvci5vZmYoXCJzZWxlY3Rpb25VcGRhdGVcIiwgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQXBwbHlpbmcgdGhlIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiB0aGUgYGF0dHJzYCBvcHRpb24uXG4gICAqL1xuICB1cGRhdGVFbGVtZW50QXR0cmlidXRlcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJzKSB7XG4gICAgICBsZXQgYXR0cnNPYmogPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmF0dHJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXModGhpcy5ub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnMoeyBub2RlOiB0aGlzLm5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnNPYmogPSB0aGlzLm9wdGlvbnMuYXR0cnM7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cnNPYmopO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFJlYWN0Tm9kZVZpZXdSZW5kZXJlcihjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChwcm9wcykgPT4ge1xuICAgIGlmICghcHJvcHMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWFjdE5vZGVWaWV3KGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpO1xuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmV4cG9ydCB7XG4gIEVkaXRvckNvbnN1bWVyLFxuICBFZGl0b3JDb250ZW50LFxuICBFZGl0b3JDb250ZXh0LFxuICBFZGl0b3JQcm92aWRlcixcbiAgTWFya1ZpZXdDb250ZW50LFxuICBOb2RlVmlld0NvbnRlbnQsXG4gIE5vZGVWaWV3V3JhcHBlcixcbiAgUHVyZUVkaXRvckNvbnRlbnQsXG4gIFJlYWN0TWFya1ZpZXcsXG4gIFJlYWN0TWFya1ZpZXdDb250ZXh0LFxuICBSZWFjdE1hcmtWaWV3UmVuZGVyZXIsXG4gIFJlYWN0Tm9kZVZpZXcsXG4gIFJlYWN0Tm9kZVZpZXdDb250ZW50UHJvdmlkZXIsXG4gIFJlYWN0Tm9kZVZpZXdDb250ZXh0LFxuICBSZWFjdE5vZGVWaWV3UmVuZGVyZXIsXG4gIFJlYWN0UmVuZGVyZXIsXG4gIHVzZUN1cnJlbnRFZGl0b3IsXG4gIHVzZUVkaXRvcixcbiAgdXNlRWRpdG9yU3RhdGUsXG4gIHVzZVJlYWN0Tm9kZVZpZXdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-list */ \"(ssr)/./node_modules/@tiptap/extension-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extensions */ \"(ssr)/./node_modules/@tiptap/extensions/dist/index.js\");\n// src/starter-kit.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_16__.Extension.create({\n  name: \"starterKit\",\n  addExtensions() {\n    var _a, _b, _c, _d;\n    const extensions = [];\n    if (this.options.bold !== false) {\n      extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n    }\n    if (this.options.blockquote !== false) {\n      extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n    }\n    if (this.options.bulletList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.code !== false) {\n      extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_2__.Code.configure(this.options.code));\n    }\n    if (this.options.codeBlock !== false) {\n      extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_3__.CodeBlock.configure(this.options.codeBlock));\n    }\n    if (this.options.document !== false) {\n      extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_4__.Document.configure(this.options.document));\n    }\n    if (this.options.dropcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Dropcursor.configure(this.options.dropcursor));\n    }\n    if (this.options.gapcursor !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.Gapcursor.configure(this.options.gapcursor));\n    }\n    if (this.options.hardBreak !== false) {\n      extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_5__.HardBreak.configure(this.options.hardBreak));\n    }\n    if (this.options.heading !== false) {\n      extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_6__.Heading.configure(this.options.heading));\n    }\n    if (this.options.undoRedo !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.UndoRedo.configure(this.options.undoRedo));\n    }\n    if (this.options.horizontalRule !== false) {\n      extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_7__.HorizontalRule.configure(this.options.horizontalRule));\n    }\n    if (this.options.italic !== false) {\n      extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_8__.Italic.configure(this.options.italic));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));\n    }\n    if (this.options.link !== false) {\n      extensions.push(_tiptap_extension_link__WEBPACK_IMPORTED_MODULE_9__.Link.configure((_b = this.options) == null ? void 0 : _b.link));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(_tiptap_extension_list__WEBPACK_IMPORTED_MODULE_10__.OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.paragraph !== false) {\n      extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_11__.Paragraph.configure(this.options.paragraph));\n    }\n    if (this.options.strike !== false) {\n      extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_12__.Strike.configure(this.options.strike));\n    }\n    if (this.options.text !== false) {\n      extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_13__.Text.configure(this.options.text));\n    }\n    if (this.options.underline !== false) {\n      extensions.push(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_14__.Underline.configure((_c = this.options) == null ? void 0 : _c.underline));\n    }\n    if (this.options.trailingNode !== false) {\n      extensions.push(_tiptap_extensions__WEBPACK_IMPORTED_MODULE_15__.TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));\n    }\n    return extensions;\n  }\n});\n\n// src/index.ts\nvar index_default = StarterKit;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUNpQjtBQUNaO0FBQ0E7QUFDVztBQUNIO0FBQ0c7QUFDTDtBQUNlO0FBQ2pCO0FBQ0o7QUFDeUM7QUFDL0I7QUFDTjtBQUNKO0FBQ1U7QUFDMkI7QUFDbkYsaUJBQWlCLG9EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixvRUFBVTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixtRUFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFRO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVU7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQiwwREFBUztBQUMvQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsOERBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQix5REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLDZFQUFjO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsNERBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQiw2REFBUTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixnRUFBVztBQUNqQztBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQU07QUFDNUI7QUFDQTtBQUNBLHNCQUFzQix5REFBSTtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFTO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanM/ZTM4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3RhcnRlci1raXQudHNcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IEJsb2NrcXVvdGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZVwiO1xuaW1wb3J0IHsgQm9sZCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ib2xkXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvZGVcIjtcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrXCI7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudFwiO1xuaW1wb3J0IHsgSGFyZEJyZWFrIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWtcIjtcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGVhZGluZ1wiO1xuaW1wb3J0IHsgSG9yaXpvbnRhbFJ1bGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlXCI7XG5pbXBvcnQgeyBJdGFsaWMgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taXRhbGljXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpbmtcIjtcbmltcG9ydCB7IEJ1bGxldExpc3QsIExpc3RJdGVtLCBMaXN0S2V5bWFwLCBPcmRlcmVkTGlzdCB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1saXN0XCI7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoXCI7XG5pbXBvcnQgeyBTdHJpa2UgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlXCI7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRleHRcIjtcbmltcG9ydCB7IFVuZGVybGluZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmVcIjtcbmltcG9ydCB7IERyb3BjdXJzb3IsIEdhcGN1cnNvciwgVHJhaWxpbmdOb2RlLCBVbmRvUmVkbyB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbnNcIjtcbnZhciBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwic3RhcnRlcktpdFwiLFxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW107XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ib2xkKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGVCbG9jay5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGVCbG9jaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZG9jdW1lbnQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEdhcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmdhcGN1cnNvcikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oYXJkQnJlYWspKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkaW5nICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oZWFkaW5nKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudW5kb1JlZG8gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kb1JlZG8uY29uZmlndXJlKHRoaXMub3B0aW9ucy51bmRvUmVkbykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pdGFsaWMgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaXRhbGljKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucy5saXN0SXRlbSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RLZXltYXAgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEtleW1hcC5jb25maWd1cmUoKF9hID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGlzdEtleW1hcCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmsgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGluay5jb25maWd1cmUoKF9iID0gdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IubGluaykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMucGFyYWdyYXBoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFN0cmlrZS5jb25maWd1cmUodGhpcy5vcHRpb25zLnN0cmlrZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51bmRlcmxpbmUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVW5kZXJsaW5lLmNvbmZpZ3VyZSgoX2MgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYy51bmRlcmxpbmUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFpbGluZ05vZGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVHJhaWxpbmdOb2RlLmNvbmZpZ3VyZSgoX2QgPSB0aGlzLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC50cmFpbGluZ05vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9kZWZhdWx0ID0gU3RhcnRlcktpdDtcbmV4cG9ydCB7XG4gIFN0YXJ0ZXJLaXQsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ })

};
;